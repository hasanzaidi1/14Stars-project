’valuealphaopacityredgreenblue	withAlphawithOpacitywithRed	withGreenwithBlue_linearizeColorComponentcomputeLuminancelerp
alphaBlendgetAlphaFromOpacity==hashCodetoStringclearsrcdstsrcOverdstOversrcIndstInsrcOutdstOutsrcATopdstATopxorplusmodulatescreenoverlaydarkenlighten
colorDodge	colorBurn	hardLight	softLight
difference	exclusionmultiplyhue
saturationcolor
luminositynonelowmediumhighbuttroundsquaremiterbevelfillstrokehardEdge	antiAliasantiAliasWithSaveLayer_data_kIsAntiAliasIndex_kColorIndex_kBlendModeIndex_kStyleIndex_kStrokeWidthIndex_kStrokeCapIndex_kStrokeJoinIndex_kStrokeMiterLimitIndex_kFilterQualityIndex_kMaskFilterIndex_kMaskFilterBlurStyleIndex_kMaskFilterSigmaIndex_kInvertColorIndex_kDitherIndex_kIsAntiAliasOffset_kColorOffset_kBlendModeOffset_kStyleOffset_kStrokeWidthOffset_kStrokeCapOffset_kStrokeJoinOffset_kStrokeMiterLimitOffset_kFilterQualityOffset_kMaskFilterOffset_kMaskFilterBlurStyleOffset_kMaskFilterSigmaOffset_kInvertColorOffset_kDitherOffset_kDataByteCount_objects_ensureObjectsInitialized_kShaderIndex_kColorFilterIndex_kImageFilterIndex_kObjectCountisAntiAlias_kColorDefault_kBlendModeDefault	blendModestylestrokeWidth	strokeCap
strokeJoin_kStrokeMiterLimitDefaultstrokeMiterLimit
maskFilterfilterQualityshadercolorFilterimageFilterinvertColors_ditherenableDitheringsRGBextendedSRGBrawRgbarawStraightRgbarawUnmodifiedrawExtendedRgba128pngrgba8888bgra8888rgbaFloat32_imageonCreate	onDispose_debugStackwidthheight	_disposeddisposedebugDisposed
toByteData
colorSpacedebugGetOpenHandleStackTracesclone	isCloneOf_toByteData_dispose_handlesdurationimage
frameCountrepetitionCountgetNextFrame_cachedFrameCount_frameCount_cachedRepetitionCount_repetitionCount_getNextFramenonZeroevenOdd	intersectunionreverseDifferencefillTypemoveTorelativeMoveTolineTorelativeLineToquadraticBezierTorelativeQuadraticBezierTocubicTorelativeCubicToconicTorelativeConicToarcTo
arcToPointrelativeArcToPointaddRectaddOvaladdArc
addPolygonaddRRectaddPathextendWithPathcloseresetcontainsshift	transform	getBoundscombinecomputeMetrics_constructor_clone_getFillType_setFillType_arcTo_arcToPoint_relativeArcToPoint_addRect_addOval_addArc_addPolygon	_addRRect_addPath_addPathWithMatrix_extendWithPath_extendWithPathAndMatrix	_contains_shift
_transform
_getBounds_oppositionvectorangle	_iteratoriterator_pathMetric_pathMeasurecurrentmoveNextlengthisClosedcontourIndex_measuregetTangentForOffsetextractPath_length
_getPosTan_extractPath	_isClosed_nextContour_nativeNextContourcurrentContourIndexnormalsolidouterinner_style_sigma	_TypeNone	_TypeBlur_color
_blendMode_matrix_type
_kTypeMode_kTypeMatrix_kTypeLinearToSrgbGamma_kTypeSrgbToLinearGamma_toNativeImageFilter_toNativeColorFilter_shortDescriptioncreator	_initMode_initMatrix_initLinearToSrgbGamma_initSrgbToLinearGammadatanativeFiltersigmaXsigmaYtileMode_modeStringradiusXradiusYinnerFilterouterFilter	_initBlur_initDilate
_initErode_initColorFilter_initComposed_debugDisposedclamprepeatedmirrordecal_initLinear_initRadial_initConical
_initSweep_validateColorStops_initWithImage
_debugName	fromAsset_shaderRegistry_reinitializeShader_uniformFloatCount_samplerCount_initFromAssetfragmentShader_kEmptyFloat32List_floatssetFloatsetImageSampler_setImageSampler_validateSamplers	trianglestriangleStriptriangleFan_initpointslinespolygonsave	saveLayerrestorerestoreToCountgetSaveCount	translatescalerotateskewgetTransformclipRect	clipRRectclipPathgetLocalClipBoundsgetDestinationClipBounds	drawColordrawLine	drawPaintdrawRect	drawRRect
drawDRRectdrawOval
drawCircledrawArcdrawPath	drawImagedrawImageRectdrawImageNinedrawPicturedrawParagraph
drawPointsdrawRawPointsdrawVertices	drawAtlasdrawRawAtlas
drawShadow	_recorder_saveLayerWithoutBounds
_saveLayer_scale_getTransform	_clipRect
_clipRRect	_clipPath_getLocalClipBounds_getDestinationClipBounds
_drawColor	_drawLine
_drawPaint	_drawRect
_drawRRect_drawDRRect	_drawOval_drawCircle_drawArc	_drawPath
_drawImage_drawImageRect_drawImageNine_drawPicture_drawPoints_drawVertices
_drawAtlas_drawShadowtoImagetoImageSyncapproximateBytesUsed_toImage_toImageSyncisRecordingendRecording_endRecording_canvas_kBytesPerShadow	_kXOffset	_kYOffset_kBlurOffsetoffset
blurRadiusconvertRadiusToSigma	blurSigmatoPaintlerpList_encodeShadowsfromUint8ListfromFilePath_initFromFileencodedbytesPerPixelinstantiateCodec_initEncoded_initRaw_width	_getWidth_height
_getHeight_bytesPerPixel_getBytesPerPixel_instantiateCodecmessagestackS_rectIsValid_rrectIsValid_offsetIsValid_matrix4IsValid_radiusIsValid_scaleAlphaColor	BlendModeFilterQuality	StrokeCap
StrokeJoinPaintingStyleClipPaint
ColorSpaceImageByteFormatPixelFormatImageEventCallbackImage_ImageImageDecoderCallback	FrameInfoCodec_NativeCodecinstantiateImageCodecinstantiateImageCodecFromBufferinstantiateImageCodecWithSize_getDefaultImageSizeTargetImageSizeCallbackTargetImageSizedecodeImageFromList_decodeImageFromListAsyncdecodeImageFromPixelsPathFillTypePathOperationEngineLayer_NativeEngineLayerPath_NativePathTangentPathMetricsPathMetricIterator
PathMetric_PathMeasure	BlurStyle
MaskFilterColorFilter_ColorFilterImageFilter_MatrixImageFilter_GaussianBlurImageFilter_DilateImageFilter_ErodeImageFilter_ComposeImageFilter_ImageFilterShaderTileMode_encodeColorList_encodePointList_encodeTwoPointsGradientImageShaderFragmentProgramFragmentShader
VertexModeVertices	PointModeClipOpCanvas_NativeCanvasPictureEventCallbackPicture_NativePicturePictureRecorder_NativePictureRecorderShadowImmutableBufferImageDescriptor_NativeImageDescriptor	_Callback_Callbacker	_futurizePictureRasterizationExceptiondartuiboolRecthasNaNRRectOffsetdxisNaNdyFloat64ListlengtheverydoublevalueisFiniteRadiusxy	withAlphaalpharoundclampintpragmafromRGBOfromARGBmathpowHSVColormaterialColorstransparentCurveselasticInOutAnimationController	_clampInt_lerpInttoIntredgreenblueclampDoubleoverrideObject	identicalruntimeTypehashCodeStringtoRadixStringpadLeftsrcdstclear	saveLayerrestore	blendModesrcOverdstInsrcOutsrcIndstOutdstATopdstOversrcATopmultiplyscreenoverlaymodulate	hardLight
colorDodge	colorBurncolor	exclusion
difference
luminosityhue	softLight
saturationblurBackdropFilternonelowmediumhighfilterQualitymatrix	drawImagedrawImageRectdrawImageNine	drawAtlas	strokeCapAsquarestrokeWidthbuttdrawPath
drawPoints
strokeJoinstrokeMiterLimitstyle
drawCirclehardEdge	antiAliasantiAliasWithSaveLayerisAntiAliasByteDataListfilledgetInt32_kFakeHostEndiansetInt32indexvaluesfillstroke
getFloat32
setFloat32miterbevel	_TypeNone	_TypeBlur_style_sigmadebugDisposed_validateSamplers	Exception
_debugNamecreator_toNativeColorFilter_toNativeImageFilterfromEnvironmenttoStringStringBufferwritetoStringAsFixed
toByteDataextendedSRGBrawExtendedRgba128
colorSpacevoidwidgets
StackTracecurrent_handlesaddcallMemoryAllocations	_disposedcontainsremoveisEmptydispose
StateErrorformatrawRgbaFuturesRGBUnsupportedErrormaphandle_debugStacktoList__imageNativeFieldWrapperClass1NativeInt32PointerVoidsymbolisLeaf	Uint8Listcallbackencodedbuffer
asByteDataHandleSetgetNextFramecloneDurationimage	CompletersyncdecodeErrorcompleteErrorcompletewidthheightdurationmillisecondsdurationMillisecondsfuturefromUint8ListtargetWidthtargetHeightallowUpscalinggetTargetSizeintrinsicWidthintrinsicHeightinstantiateCodecthenrawrowBytespixelFormatcodec	frameInfofillTypecombinereverseDifferencexor	intersectSceneBuilderclipPath_clonenonZerozero
fromCircle_opextractPathIterablefromDoublelefttoprightbottomBoolradiusrotationlargeArc	clockwiseFloat32List_getValue32matrix4fromLTRBforceClosedgetTangentForOffsetcossinatan2computeMetricslineTomoveToIterableBaseIterator
RangeError_nextContourcurrentContourIndexisClosedcloseaddRectstartWithMoveTonextContour
maskFilter
drawShadowhashcolorFilterfromColorFiltermodelinearToSrgbGammasrgbToLinearGamma_type_listEquals_matrix_color
_blendModehashAll
_kTypeMode_kTypeMatrixfromList_kTypeLinearToSrgbGamma_kTypeSrgbToLinearGammaImageFilteredpushBackdropFilterpushImageFiltersigmaXsigmaYtileModeradiusXradiusYMatrix4	diagonal3ArgumentErrordatainnerFilterinnerouterFilteroutermirrorrepeateddecaldilateerodecomposed_shortDescriptionshaderpaintingGradientLinearGradientRadialGradientBoxDecorationlinearradial	Int32ListiNoSuchMethodError
colorStopsfocalfocalRadiuspi
startAngleendAngle
isNotEmptyUripath
encodeFulltarget	microtask
_fromAssetWeakReferenceMap_initFromAsset	debugNamefragmentShader_uniformFloatCount_samplerCountdrawVertices	trianglestriangleStriptriangleFannew
Uint16ListcolorstextureCoordinatesindicesdrawRawPointsclipRectSceneendRecordingCustomPainterpaintsydoAntiAliasarcTo	ParagraphlayoutParagraphStyleParagraphBuilder	TextAlignParagraphConstraintspointslinespolygonRSTransformscosssintxtyisRecording_canvascullRectlargest_objects_dataclipOpUint32stack_NativeParagraph_needsLayout_paint
addPicturedrawPicture	onDisposeUint64	_recorderonCreate	TextStylenormaloffset
blurRadiusscalelerp_lerpDoubleminshadowIndex_kColorDefaultconvertRadiusToSigma_init_length_initFromFile_initEncodedTttoImageSyncwritelnNativeFieldWrapperClass1CodecEngineLayerPathIterableBaseIteratorImageFilterShaderCanvasPicturePictureRecorderImageDescriptor	ExceptionÆM{óåpz.â’hèÉ=5      	dart:coreÀiÔ ÀH·›E <€†€¤€µ€¶€Î€ï-Fz­®û‚E‚•‚æƒ6ƒ„ƒÕ„„„d„Š„‹„ª„ê„ù„û„ü……`…o…q…r…—…ñ† †††/†p†Î†İ†ß†à‡‡]‡l‡n‡o‡›‡Û‡İ‡Şˆˆˆfˆ¶‰‰-‰1‰a‰e‰q‰™‰ÖŠŠFŠNŠRŠ£Šò‹B‹n‹r‹~‹ËŒŒŒŒ-Œ1Œ„ŒÊŒØEKs™Àåë;‰·½Pu‘ÈÉ	\l‘¸Şä‘'‘-‘x‘…‘º‘Ü‘ş’ ’N’O’¤’ª’Ï’ö““i“™“Ÿ“â“è”0”n”¤”Ú••R•S••‡•¯•µ•İ––*–O–b–c–œ–¢–ñ——B—C—v—|—Í—ï˜˜˜M˜z˜{˜´˜â˜ã™™H™I™’™È™Îšš!šQšUšVšŸšçší›%›K›y›ª›®›¯›ÿœ,œ2œjœƒœµœ¹œº9?w’ÂÆÇEKƒÎÒÓŸŸNŸnŸŸ”ŸÕŸÙŸÚ % +   £ á ÿ¡?¡z¡·¡ó¢$¢(¢)¢X¢^¢¦¢é¢ï£9£†£Å¤¤¤^¤¨¤ó¥?¥¥İ¦*¦{¦¨¦®¦ı§§R§g§~§“§¢§Ê§Ò§ß§ö¨¨'¨F¨Š¨Ê©©P©[©c©i©m©n©±©÷©ıªIªªÛ«*«u«µ«İ¬¬5¬;¬b¬ˆ¬¿¬Ü¬ê­0­z­Â­Ë­è®®H®h®…®—®â¯1¯~¯‡¯¯‘¯’¯ß¯å°°C°~°‚°ƒ°°²°Ô°ç°í±±-±3±M±n±r±s±±¥±¦±²² ²²²6²:²‡²Ñ²ğ²ô³E³’³á´/´´Êµµµbµ­µş¶J¶˜¶å·,·w·Æ¸¸'¸+¸y¸Æ¹¹b¹¯º ºAºEºlºpº¾ºÿ»P»»î¼=¼Œ¼§¼«¼¹¼½½½½*½y½Œ½Ò½Ó¾¾¾Y¾_¾¼¾Å¾Æ¿¿¿Z¿i¿o¿ª¿°À @À @À @À @RÀ @XÀ @£À @´À @ºÀ @üÀ AÀ A]À AdÀ AeÀ A¢À A¨À AöÀ BGÀ BdÀ BjÀ B¸À BåÀ BëÀ CJÀ CUÀ CVÀ C”À CšÀ CÃÀ CÉÀ DÀ DÀ D|À D‚À DÑÀ DüÀ EÀ EÀ EPÀ EÀ EêÀ EøÀ EşÀ F=À FCÀ FÀ FØÀ FèÀ FîÀ G:À G@À GÀ G¦À G§À GôÀ HBÀ HŒÀ H’À HÌÀ HÒÀ IÀ IqÀ IwÀ IÃÀ IÉÀ J&À J/À J0À JÀ JÒÀ K!À K'À KgÀ KmÀ KºÀ LÀ LÀ L^À LdÀ LÂÀ LÌÀ LÍÀ M!À MoÀ M¹À M¿À MúÀ N À NRÀ NÀ N¤À NñÀ N÷À OUÀ O_À O`À O¯À OÏÀ OÕÀ P#À P)À PyÀ PÅÀ PùÀ PÿÀ QJÀ Q[À QaÀ QÀÀ QËÀ QÌÀ RÀ R6À R<À RŠÀ RÀ RàÀ S'À S[À SaÀ S¬À S½À SÃÀ T"À T-À T.À T~À T²À T¸À UÀ UÀ UfÀ UmÀ UnÀ U­À U³À VÀ VNÀ VtÀ VzÀ VÈÀ VÎÀ W*À W2À W3À W}À WƒÀ WÒÀ X!À X'À XxÀ X¡À X§À XøÀ XşÀ Y^À YdÀ YtÀ YzÀ Y¼À ZÀ Z À ZjÀ ZÀ ZÀ ZÀ ZÖÀ Z×À ["À [HÀ [NÀ [šÀ [çÀ \À \À \mÀ \¹À \ßÀ \åÀ ]5À ]„À ]ÕÀ ]ÛÀ ^*À ^LÀ ^RÀ ^°À ^¶À ^ÆÀ ^ÌÀ _À _-À _uÀ _‘À _ÛÀ _òÀ `À `À `_À `À `”À `åÀ a3À a„À a£À a©À aõÀ bBÀ bqÀ bwÀ bÖÀ bÜÀ bìÀ bòÀ c+À crÀ cÂÀ cíÀ cøÀ cùÀ dGÀ dfÀ dlÀ dµÀ dÆÀ dÌÀ e*À e4À e5À e„À e£À e©À eòÀ fÀ f	À fhÀ fsÀ ftÀ f¯À fµÀ gÀ gNÀ g}À gƒÀ gåÀ góÀ gôÀ hGÀ hMÀ h™À hæÀ iÀ iÀ i|À i‰À iŠÀ iÓÀ iıÀ jÀ jSÀ jœÀ jêÀ kÀ kÀ kiÀ k¶À kåÀ këÀ lLÀ lRÀ lbÀ lhÀ l¡À lèÀ m7À mcÀ mpÀ mqÀ m¿À m×À mİÀ nÀ n%À n†À nŒÀ nœÀ n¢À nÛÀ nèÀ néÀ o2À o8À o‡À oÀ o¤À oíÀ oşÀ pÀ p<À pBÀ p¤À p²À p³À pÿÀ qÀ qÀ qbÀ qyÀ qÀ qÈÀ qÙÀ qßÀ rÀ rÀ r~À r‹À rŒÀ rÚÀ róÀ rùÀ sHÀ s—À sÀ séÀ t6À t~À t„À tÓÀ t÷À tıÀ u]À u†À u‡À uØÀ uñÀ u÷À v@À vFÀ vÀ vßÀ wÀ wÀ wfÀ wlÀ w|À w‚À wÒÀ wûÀ xJÀ x{À x‚À xƒÀ xÔÀ xíÀ xóÀ y<À yŒÀ y¹À y¿À zÀ z À z0À z6À zxÀ zÇÀ zİÀ zëÀ zìÀ {=À {VÀ {\À {¥À {«À {ôÀ |DÀ |yÀ |À |ÜÀ |âÀ |òÀ |øÀ }.À }|À }ÊÀ }ÓÀ }ÔÀ ~%À ~>À ~DÀ ~À ~İÀ 
À À rÀ xÀ ˆÀ À İÀ óÀ €>À €WÀ €eÀ €gÀ €hÀ €ÀÀ €ûÀ €ÿÀ \À £À §À üÀ ‚PÀ ‚¦À ‚úÀ ‚şÀ ƒLÀ ƒ‡À ƒ‹À ƒäÀ ƒèÀ „5À „}À „œÀ „ À „®À „²À „ıÀ …6À …LÀ …iÀ …„À …£À …ÂÀ …İÀ …òÀ †HÀ †pÀ †qÀ †µÀ †»À ‡À ‡FÀ ‡NÀ ‡OÀ ‡‡À ‡À ‡ÏÀ ‡şÀ ˆÀ ˆÀ ˆPÀ ˆxÀ ˆ~À ˆÉÀ ‰À ‰_À ‰ªÀ ‰°À ‰àÀ ‰ğÀ ‰öÀ ŠEÀ ŠyÀ ŠÀ Š˜À Š™À ŠéÀ ŠöÀ ŠüÀ ‹JÀ ‹‡À ‹À ‹´À ‹ºÀ ŒÀ Œ\À Œ§À Œ­À ŒÚÀ ŒâÀ ŒäÀ ŒåÀ 	À À À À TÀ —À ÓÀ äÀ $À *À {À ßÀ åÀ 3À eÀ mÀ nÀ ©À ¯À ùÀ IÀ ¹À ¿À ‘À ‘4À ‘=À ‘>À ‘À ‘ÆÀ ‘ëÀ ‘ñÀ ’@À ’±À ’·À “À “,À “2À “€À “ À “ªÀ “¬À “­À “×À “ÛÀ ”(À ”lÀ ”pÀ ”~À ”‚À ”ÎÀ ”ÚÀ •À •RÀ •dÀ •šÀ • À –	À –À –WÀ –§À –³À –¹À –ÉÀ –ÏÀ —À —.À —À —¸À —ÁÀ —ÂÀ —÷À —ıÀ ˜dÀ ˜jÀ ˜²À ™À ™À ™À ™$À ™*À ™xÀ ™‰À ™’À ™“À ™áÀ šÀ šÀ š€À š†À šÎÀ ›À ›*À ›0À ›@À ›FÀ ›”À ›¥À ›®À ›°À ›±À ›ëÀ ›ïÀ œÀ œBÀ œWÀ œ¢À œ°À œ±À œ÷À =À dÀ lÀ mÀ ±À ÷À >À |À †À ˆÀ ‰À ¸À ÄÀ ÚÀ àÀ Ÿ+À Ÿ|À Ÿ‚À ŸÎÀ ŸäÀ  1À  ŠÀ  ßÀ  øÀ ¡ À ¡À ¡-À ¡3À ¡ŒÀ ¡½À ¡ÃÀ ¢À ¢	À ¢aÀ ¢¼À ¢ÂÀ ¢ÒÀ ¢ØÀ £4À £XÀ £dÀ £eÀ £„À £ŠÀ £ÖÀ £ÜÀ ¤/À ¤5À ¤|À ¤‚À ¤×À ¤öÀ ¥MÀ ¥SÀ ¥cÀ ¥iÀ ¥±À ¥üÀ ¦-À ¦ŠÀ ¦—À ¦˜À ¦äÀ ¦êÀ §=À §À §¸À §¾À ¨À ¨]À ¨¯À ©À ©À ©WÀ ©§À ©õÀ ªEÀ ª‹À ª‘À ª¡À ª§À ªõÀ «À «À «À «TÀ «XÀ «À «½À «ËÀ ¬À ¬)À ¬5À ¬PÀ ¬fÀ ¬lÀ ¬pÀ ¬qÀ ¬ À ¬¥À ¬ğÀ ­;À ­ŠÀ ­ØÀ ®'À ®,À ®|À ®ÍÀ ®ŞÀ ®ãÀ ¯+À ¯,À ¯MÀ ¯iÀ ¯À ¯À ¯ÉÀ ¯îÀ °À °<À °gÀ °À °ºÀ °êÀ ±À ±AÀ ±uÀ ±¥À ±ÑÀ ±øÀ ±ùÀ ²;À ²qÀ ²¯À ²åÀ ³'À ³eÀ ³¥À ³ñÀ ´7À ´wÀ ´ÉÀ µÀ µUÀ µÀ µÎÀ µ÷À µøÀ ¶<À ¶]À ¶yÀ ¶”À ¶•À ¶ÃÀ ·À ·
À ·À ·1À ·\À ·‡À ·ÛÀ ·ÜÀ ¸"À ¸0À ¸6À ¸NÀ ¸gÀ ¸®À ¸²À ¸ÒÀ ¹"À ¹LÀ ¹sÀ ¹·À ¹»À ¹¼À ¹ôÀ º$À º%À º^À ºdÀ º„À ºŠÀ ºšÀ º À ºæÀ »À »_À »eÀ »­À »ÂÀ »ÖÀ ¼À ¼KÀ ¼OÀ ¼jÀ ¼ À ¼ŞÀ ¼âÀ ¼ãÀ ½À ½\À ½]À ½©À ½¯À ½ñÀ ¾BÀ ¾“À ¾´À ¾ºÀ ¿À ¿(À ¿.À ¿UÀ ¿[À ¿kÀ ¿qÀ ¿ÀÀ ¿ôÀ À>À ÀTÀ ÀpÀ À½À ÀøÀ ÀüÀ ÁÀ ÁYÀ Á›À ÁŸÀ Á À ÁäÀ ÁêÀ ÂÀ Â.À Â€À Â„À Â§À ÂÌÀ Ã
À ÃÀ ÃÀ ÃIÀ Ã˜À ÃÕÀ ÃÛÀ ÄÀ Ä3À ÄwÀ Ä{À ÄÀ Ä¿À ÅÀ Å	À Å
À ÅKÀ Å{À ÅÀ Å³À ÅÏÀ Æ!À Æ%À ÆHÀ ÆmÀ Æ¯À Æ³À Æ´À ÆõÀ ÆûÀ ÇLÀ Ç—À ÇÀ Ç×À ÇİÀ ÇûÀ ÈÀ ÈjÀ ÈpÀ È×À ÈİÀ ÉDÀ ÉJÀ É–À ÉçÀ ÉóÀ ÉùÀ Ê	À ÊÀ Ê^À ÊŠÀ ÊÓÀ ËÀ Ë0À Ë„À ËˆÀ Ë­À ËÒÀ ÌÀ ÌÀ ÌÀ ÌRÀ Ì‰À ÌŠÀ ÌÕÀ Í#À ÍnÀ Í»À Î	À ÎÀ ÎTÀ ÎZÀ Î¨À ÎÌÀ ÎÒÀ Ï;À ÏAÀ ÏªÀ Ï°À ĞÀ ĞÀ ĞkÀ Ğ¼À ĞÈÀ ĞÎÀ ĞŞÀ ĞäÀ Ñ.À ÑIÀ Ñ’À Ñ²À ÑûÀ ÑÿÀ Ò&À ÒdÀ Ò¯À Ò³À Ò´À ÓÀ ÓBÀ ÓHÀ ÓlÀ Ó‹À ÓÏÀ ÓğÀ ÔÀ Ô&À ÔFÀ Ô¡À ÔèÀ ÔóÀ ÔùÀ Õ
À ÕÀ Õ4À ÕMÀ ÕŸÀ ÕçÀ Ö/À Ö<À Ö‰À Ö»À ×À ×fÀ ×·À ×½À ×ÁÀ ×ÂÀ ØÀ ØhÀ Ø´À ØºÀ ØâÀ Ù/À ÙSÀ Ù­À Ù±À ÙÜÀ ÚÀ ÚGÀ ÚKÀ ÚLÀ Ú†À ÚŒÀ ÚÂÀ ÚÈÀ ÚØÀ ÚŞÀ ÛÀ ÛRÀ Û„À ÛÌÀ ÛãÀ ÜÀ ÜÀ Ü5À ÜEÀ ÜSÀ Ü‚À Ü¹À ÜÂÀ ÜÕÀ ÜßÀ ÜïÀ İÀ İ>À İÀ İ¨À İ°À İÃÀ İÍÀ ŞÀ Ş	À Ş
À ŞQÀ ŞcÀ ŞiÀ ŞÀ Ş”À ŞåÀ ßÀ ß]À ßÀ ßƒÀ ß«À ßñÀ àÀ à/À à]À àeÀ àrÀ à¸À à¾À àÂÀ àÃÀ àşÀ áÀ áKÀ áeÀ ákÀ áyÀ á¦À áÀÀ áÒÀ áìÀ â<À âGÀ âOÀ âYÀ â_À âoÀ âuÀ â°À âÑÀ ã(À ãJÀ ãNÀ ãvÀ ãÀ ã­À ãÛÀ ããÀ ãğÀ ä1À ä‡À ä²À äöÀ äşÀ åÀ åÀ å	À åHÀ åNÀ åšÀ åäÀ æÀ æ/À ævÀ æzÀ æ›À æåÀ æéÀ æêÀ æÿÀ çAÀ çEÀ çaÀ ç¦À çªÀ ç«À çãÀ çéÀ è5À è{À è®À è´À èúÀ éÀ é!À énÀ éºÀ éİÀ éãÀ ê*À êxÀ êŸÀ ê À ê¬À êÂÀ êûÀ ëÀ ë À ëPÀ ëkÀ ë‡À ë°À ëÎÀ ëîÀ ì*À ì9À ì\À ìdÀ ìÀ ì²À ìºÀ ìæÀ í#À íxÀ í‚À í‘À í·À í¿À í×À íİÀ íüÀ î-À îEÀ îKÀ î{À î£À î»À îÁÀ îòÀ ïÀ ï6À ï<À ï[À ï˜À ï°À ï¶À ïÔÀ ğÀ ğ'À ğ-À ğ\À ğÀ ğµÀ ğ»À ğÕÀ ñÀ ñ À ñ&À ñEÀ ñ‚À ñšÀ ñ À ñ¸À ññÀ ñ÷À ò
À ò>À òDÀ ò[À òyÀ ò}À òÀ ò€À òËÀ òÏÀ óÀ ó\À ó§À óÙÀ óİÀ ôÀ ôÀ ôLÀ ô^À ôzÀ ô€À ôÍÀ ôùÀ ôÿÀ õ2À õ:À õ‡À õÕÀ öÀ öFÀ öVÀ öXÀ öYÀ ö›À ö³À ÷À ÷NÀ ÷–À ÷àÀ ÷÷À øÀ øÀ ørÀ ø}À ø~À øÀ ø¤À øıÀ ùÀ ùÀ ù.À ù4À ù„À ù¿À ùĞÀ ùÑÀ ù÷À ùıÀ úIÀ úvÀ ú|À ú‘À ú—À ú¥À úÃÀ úãÀ úéÀ û1À ûOÀ û¥À ûçÀ üÀ ü"À ü<À üVÀ üpÀ ü{À üƒÀ üÀ ü£À ü¤À ü¶À ü¼À ıÀ ıZÀ ı¦À ıóÀ ş<À şBÀ ş“À şŸÀ ş¥À şµÀ ş»À ÿÀ ÿ_À ÿfÀ ÿhÀ ÿiÀ ÿ¨À ÿ»À 	À YÀ ŒÀ ˜À ™À èÀ7ÀjÀvÀwÀÇÀÀ]À˜À§À©ÀªÀÖÀÀÀFÀJÀŠÀÀÜÀôÀøÀGÀ–ÀİÀ%ÀsÀÀ…ÀÑÀ ÀgÀkÀyÀ}ÀëÀ:À`À¯À½ÀïÀÿÀ'À:ÀDÀcÀ}ÀÀ‚À£À¿ÀÖÀ×À	À	À	fÀ	¨À	ÉÀ	ğÀ	ñÀ
0À
6À
À
ÄÀ
åÀÀÀ)À*ÀnÀÀ‚ÀÄÀØÀÙÀóÀ@ÀqÀwÀÈÀãÀéÀ4ÀÀÎÀîÀÀÀIÀuÀ‹ÀÂÀ×ÀúÀÀÀÀÀaÀgÀµÀËÀæÀúÀ
À&À9ÀCÀ±ÀµÀ¶ÀëÀñÀ=ÀMÀSÀ˜ÀçÀ.À4ÀÀšÀêÀ9ÀƒÀÏÀ$ÀQÀÀƒÀ„ÀÀÀÆÀÀaÀÀ“ÀâÀ0ÀcÀ¯ÀÜÀúÀ-ÀLÀZÀzÀˆÀ°À¿ÀÀÀÀÀiÀ‹À‘ÀÑÀÀ%À5À‰ÀœÀ¦À¹À½À¾ÀïÀõÀDÀ“ÀäÀ0À|ÀÊÀÀ4À:ÀˆÀ±À·ÀÿÀPÀfÀlÀ¢À¨À¶ÀÑÀñÀ	ÀÀGÀ†À¥ÀïÀ ÀÀ2À‚ÀĞÀöÀ ,À 7À XÀ `À fÀ ˆÀ ¼À!À!2À!uÀ!¹À!öÀ"À"À"QÀ"À"‡À"¤À"¾À"ÄÀ"æÀ#À#À#'À#-À#IÀ#lÀ#rÀ#À#“À#¶À#ïÀ#ùÀ#ÿÀ$*À$2À$<À$BÀ$‡À$ÕÀ$ùÀ%À% À%8À%cÀ%´À&À&DÀ&MÀ&SÀ&rÀ&À&¡À&¢À&îÀ'4À':À'‡À'ÑÀ(!À(pÀ(ºÀ)À)@À)AÀ)MÀ)wÀ)yÀ)zÀ)”À)ÉÀ*À*-À*2À*€À*¢À*¾À*ÌÀ*ÍÀ+À+6À+7À+‡À+¢À+£À+øÀ,.À,lÀ,œÀ,¦À,®À,²À,³À,ïÀ-EÀ-‘À-’À-¬À-¿À-×À-ãÀ-ûÀ.HÀ.`À.ªÀ.âÀ.éÀ.ÿÀ/À/À/À/_À/„À/ÆÀ/âÀ/ãÀ0À0À0SÀ0rÀ0sÀ0À0¯À0±À0²À0äÀ1 À1!À1UÀ1YÀ1•À1¯À1³À1ıÀ2FÀ2”À2ÚÀ3%À3NÀ3RÀ3‹À3À3›À3§À3áÀ4"À4@À4À4ØÀ4õÀ5AÀ5`À5À5‡À5À5“À5©À5­À5¹À5ÆÀ6 À6AÀ6À6ÀÀ7À7&À7uÀ7½À7ŞÀ7äÀ7ìÀ7şÀ8HÀ8dÀ8jÀ8¨À8ÄÀ9À9À92À98À9…À9 À9¡À9ÊÀ9ĞÀ:À:À:jÀ:À:À:‚À:¢À:¦À:îÀ;À;À;DÀ;aÀ;xÀ;À;´À;µÀ;äÀ;êÀ<À<CÀ<^À<_À<‡À<À<ÑÀ<×À=(À=.À=oÀ=ŸÀ=ÃÀ=ÄÀ>À>7À>=À>ˆÀ>­À>¿À>ÁÀ>ÂÀ>ÜÀ?(À?-À?vÀ?‘À?–À?ÏÀ?íÀ@	À@À@À@8À@9À@EÀ@€À@À@ÕÀ@õÀ@öÀAÀAÀA"ÀAlÀAmÀAÆÀAëÀAìÀAøÀB#ÀBkÀBÓÀBîÀCÀCrÀC|ÀCµÀCÄÀCìÀD(ÀDjÀDvÀD~ÀD†ÀDŸÀD½ÀDÃÀDàÀDäÀDåÀE!ÀErÀEÂÀEÃÀEÏÀFÀF,ÀF.ÀF/ÀFRÀFVÀF¥ÀFõÀGCÀGfÀGjÀG¼ÀH
ÀH%ÀHeÀHŠÀHÛÀI!ÀImÀI½ÀIĞÀIÔÀJÀJiÀJ¹ÀKÀKTÀK¥ÀKôÀL<ÀLxÀL|ÀLÆÀMÀM`ÀMœÀM ÀMíÀMùÀNÀN2ÀNFÀN[ÀNyÀN„ÀNĞÀNúÀOÀO$ÀODÀOhÀOmÀOoÀOpÀO“ÀO—ÀOæÀP6ÀP„ÀP§ÀP«ÀPÿÀQMÀQ†ÀQŠÀQÜÀR,ÀR8ÀR<ÀR‡ÀRÑÀS!ÀSpÀS¼ÀTÀT\ÀT¤ÀTàÀTäÀU.ÀUxÀUÈÀVÀVÀVUÀVaÀVeÀVŠÀVÀVŞÀW)ÀWtÀWœÀWËÀWçÀWûÀXÀX.ÀX3ÀX[ÀXgÀX¦ÀXÃÀYÀY/ÀY9ÀY€ÀYªÀY´ÀY¼ÀZÀZÀZÀZÀZÀZ6ÀZ:ÀZ…ÀZ‰ÀZÖÀ[%À[dÀ[hÀ[±À\ À\À\À\hÀ\µÀ]À]BÀ]‘À]áÀ^1À^À^¸À^¼À_À_PÀ_„À_ˆÀ_ÕÀ_áÀ_åÀ`
À`À`^À`©À`ôÀaÀaIÀaeÀaÀašÀaÄÀbÀbÀbsÀb²ÀbóÀcÀc@ÀcgÀcnÀc|Àc’Àc–Àc˜Àc™ÀcéÀdÀdÀdÀd]Àd†ÀdŠÀd˜ÀdœÀdæÀeÀeCÀeYÀepÀesÀetÀe¹Àe½ÀeËÀeÏÀfÀfYÀfÀf™ÀfÅÀfËÀgÀg2ÀgeÀg‘Àg¿ÀgÀÀgîÀgôÀhCÀh“ÀháÀi.ÀiYÀi_Ài•Ài©ÀiªÀiÙÀißÀj/Àj~ÀjËÀkÀkCÀkIÀkÀk”Àk•Àk¡ÀkİÀkßÀkàÀl)Àl-Àl|ÀlÊÀmÀm[ÀmˆÀmŠÀm‹ÀméÀn"Àn\ÀnyÀn{Àn|Àn¹Àn½ÀoÀoVÀonÀorÀo¾ÀpÀpNÀpRÀpÀpçÀq7Àq†ÀqÒÀr#ÀrrÀrºÀröÀrúÀsDÀsÀsŞÀtÀt6ÀtJÀtWÀteÀt{ÀtÀt¯ÀtÃÀtØÀtöÀtûÀuÀuLÀuPÀunÀu¤Àu¨Àu©ÀuÑÀuöÀv4ÀvDÀvZÀvrÀvÀv«Àv´ÀvµÀvÒÀwÀwBÀwLÀw•ÀwÁÀwËÀwÓÀwÔÀwåÀx Àx$ÀxJÀxTÀxrÀx¶ÀxÑÀxíÀxøÀyÀy:ÀyZÀy[Ày‡Ày“Ày™Ày›ÀyœÀyéÀyùÀyıÀz4ÀzHÀz’Àz˜ÀzéÀ{8À{‡À{²À{¸À{ğÀ{ûÀ{üÀ|>À|DÀ|•À|æÀ|ìÀ}%À}0À}2À}3À}WÀ}[À}iÀ}mÀ}¼À}âÀ}÷À~+À~1À~À~ÊÀÀÀ!À'ÀvÀÀÀíÀ€À€À€gÀ€µÀ€ÏÀ€ÕÀ€åÀÀ)ÀtÀzÀÈÀ‚À‚HÀ‚QÀ‚œÀ‚ÕÀ‚ÛÀƒ)Àƒ}ÀƒƒÀƒ“ÀƒĞÀƒ×À„À„À„_À„ªÀ„ëÀ„ñÀ…À…À…PÀ…iÀ…~À…€À…À…ÒÀ…ïÀ†?À†bÀ†hÀ†¸À‡À‡RÀ‡›À‡µÀ‡»Àˆ
ÀˆVÀˆÀˆ–ÀˆáÀ‰À‰À‰À‰À‰5À‰À‰×À‰óÀŠÀŠ)ÀŠ*ÀŠ6ÀŠ~ÀŠ™ÀŠ›ÀŠœÀŠÎÀŠÒÀ‹À‹À‹^À‹À‹±À‹µÀ‹ûÀŒ&ÀŒ*ÀŒiÀŒ¬ÀŒÔÀŒØÀÀUÀkÀ‹ÀŒÀ´ÀºÀÀVÀyÀ­ÀİÀôÀøÀùÀ7À=À‚ÀŸÀÃÀÄÀùÀÀÀeÀ’À“ÀÚÀçÀ‘
À‘À‘RÀ‘„À‘±À‘²À‘õÀ’5À’DÀ’JÀ’»À“0À“vÀ“wÀ“ºÀ”À”FÀ”SÀ”¡À”¢À”çÀ•.À•=À•CÀ•°À–!À–sÀ–tÀ–¹À— À—EÀ—ZÀ—´À—µÀ—ûÀ˜?À˜„À˜ËÀ˜ğÀ˜öÀ™cÀ™ÔÀšÀšÀšaÀš¥ÀšêÀ›1À›wÀ›ŸÀ›íÀ›îÀœ1ÀœSÀœYÀœœÀœÀÀœÆÀÀMÀ”ÀØÀÀcÀ‘À—ÀÜÀŸÀŸcÀŸdÀŸ³ÀŸøÀŸşÀ MÀ –À ÚÀ¡À¡À¡LÀ¡›À¡çÀ¡íÀ¢À¢1À¢LÀ¢gÀ¢‚À¢ˆÀ¢‰À¢ØÀ£À£#À£WÀ£]À£¬À£úÀ¤=À¤‡À¤À¤ĞÀ¥À¥kÀ¥‚À¥À¥·À¥ØÀ¥óÀ¦À¦)À¦/À¦0À¦wÀ¦À¦©À¦ªÀ¦ìÀ§À§ À§rÀ§ÀÀ§ÛÀ§ÜÀ¨$À¨aÀ¨ À¨áÀ©'À©kÀ©¯À©»À©ÁÀª-ÀªÀª£À«À«‡À«ÇÀ«ÈÀ¬À¬(À¬.À¬}À¬¢À¬¨À¬ïÀ­#À­$À­fÀ­©À­¹À­×À­ØÀ®À®$À®qÀ®¿À®êÀ¯,À¯-À¯sÀ¯²À¯ïÀ¯õÀ°BÀ°“À°¾À±À±À±MÀ±À±À±ŸÀ±äÀ²(À²CÀ²SÀ²TÀ²¤À²ñÀ³À³À³^À³dÀ³©À³ÈÀ³ÉÀ´	À´8À´UÀ´VÀ´–À´ÆÀ´íÀ´îÀµ#Àµ)ÀµyÀµÆÀ¶À¶PÀ¶VÀ¶§À¶öÀ·HÀ·•À·ßÀ¸-À¸;À¸€À¸”À¸•À¸áÀ¸ôÀ¸úÀ¹JÀ¹˜À¹ÒÀºÀºGÀº˜Àº«Àº±À»(À»,À»-À»|À»­À»³À»ÿÀ¼GÀ¼–À¼åÀ½/À½gÀ½mÀ½¸À¾À¾NÀ¾‚À¾ˆÀ¾ØÀ¿%À¿uÀ¿¸ÀÀÀÀRÀÀ¡ÀÀñÀÁ@ÀÁFÀÁ”ÀÁãÀÂÀÂÀÂnÀÂ¹ÀÂóÀÂõÀÂöÀÃÀÃZÀÃ‚ÀÃÀÃÂÀÃÃÀÄÀÄVÀÄiÀÄjÀÄ£ÀÄÃÀÄÄÀÅÀÅ1ÀÅ2ÀÅ>ÀÅ‚ÀÅÀÅÏÀÅĞÀÆ$ÀÆCÀÆDÀÆÀÆÊÀÆËÀÆ×ÀÇ5ÀÇaÀÇbÀÇnÀÇÔÀÈ
ÀÈÀÈÀÈuÀÈ¡ÀÈ¢ÀÈ®ÀÉÀÉJÀÉKÀÉWÀÉĞÀÊÀÊ ÀÊ,ÀÊ­ÀÊØÀËÀËÀËÀË—ÀËòÀËóÀËÿÀÌ†ÀÌéÀÌêÀÌöÀÍmÀÍ¼ÀÍ½ÀÍÉÀÎHÀÎŸÀÎ ÀÎ¬ÀÎşÀÏÀÏ}ÀÏÀÏ‚ÀĞÀĞ‹ÀĞŒÀĞ˜ÀĞ»ÀĞÜÀĞ÷ÀÑÀÑ-ÀÑ4ÀÑXÀÑ|ÀÑÖÀÑÚÀÑÛÀÒaÀÒîÀÒïÀÒûÀÓÀÓ0ÀÓQÀÓlÀÓ‡ÀÓ¢ÀÓ©ÀÓÒÀÓöÀÔbÀÔfÀÔgÀÔõÀÕÀÕ0ÀÕFÀÕ\ÀÕrÀÕ‰ÀÕÀÕµÀÕ¶ÀÕÂÀÕŞÀÕşÀÖ:ÀÖ>ÀÖ?ÀÖ®ÀÖşÀÖÿÀ×À×'À×GÀ×ƒÀ×‡À×ˆÀ×÷ÀØGÀØHÀØTÀØ•ÀØµÀÙÀÙÀÙÀÙ‹ÀÚ ÀÚÀÚÀÚBÀÚtÀÚxÀÚyÀÚËÀÛÀÛ	ÀÛÀÛ4ÀÛVÀÛzÀÛ~ÀÛÀÛÉÀÛ÷ÀÛøÀÜÀÜGÀÜkÀÜ†ÀÜ®ÀÜüÀİ	ÀİDÀİJÀİNÀİOÀİ¯ÀİñÀİòÀŞdÀŞÄÀŞÅÀŞÑÀßÀß?ÀßZÀß‚ÀßÖÀßãÀà%Àà+Àà/Àà0Àà—ÀààÀàáÀáYÀá¿ÀáÀÀáÌÀâÀâ2Àâ3Àâ?ÀâŒÀâ¥Àâ¦Àâ²ÀâÒÀâõÀãÀã#Àã$Àã„Àã³Àã´ÀãÀÀãŞÀäÀä0ÀäXÀäiÀämÀänÀäÅÀåÀåÀåÀå6Àå\ÀåŠÀå©ÀåºÀå¾Àå¿ÀæÀæQÀæRÀæ^ÀæsÀæÀæÜÀæàÀæáÀç&ÀçKÀçLÀç­Àç÷ÀçøÀèÀè?ÀèlÀèpÀèrÀèsÀèµÀè¹ÀèÇÀé%Àé5ÀéfÀélÀé’Àé¿ÀéÀÀêÀêÀê`ÀêŒÀêÉÀëÀëÀëÀë5Àë;ÀëÀëÒÀëëÀëìÀìÀìÀìpÀìÂÀìŞÀìõÀìöÀí&Àí,Àí|ÀíËÀíçÀííÀî;ÀîŠÀîÙÀï'Àï8Àï}Àï¶Àï¸Àï¹ÀğÀğÀğVÀğ¢ÀğèÀğìÀñ2Àñ6Àñ‚ÀñÑÀñïÀñóÀò=ÀòÀò®ÀòîÀóÀósÀótÀóœÀóÀó©ÀóÛÀóİÀóŞÀô-ÀôGÀô‚Àô­Àô®ÀôÉÀôìÀôíÀôùÀõÀõGÀõhÀõ€ÀõãÀö?Àö³Àö¼ÀöÂÀöÜÀöàÀöáÀöíÀ÷À÷(À÷XÀ÷kÀ÷qÀ÷‰À÷›À÷ŸÀ÷¡À÷¢À÷áÀ÷åÀø-ÀøxÀøÆÀøêÀøîÀù<Àù‹Àù×Àú'ÀúuÀúƒÀú–Àú´ÀúòÀû4ÀûgÀûhÀûÀû¤ÀûíÀü7Àü€Àü—Àü˜Àü½ÀüÃÀıÀıWÀı§ÀıÆÀıİÀıŞÀş	ÀşÀş_Àş¦ÀşôÀÿCÀÿ|Àÿ‚ÀÿĞÀ  À oÀ ¨À ÂÀ ÃÀ âÀ ãÀ3ÀZÀ`À¯ÀüÀÀÀOÀUÀ›ÀÍÀÀÀÀ\ÀbÀ¤ÀèÀ6À“À—À˜À¤ÀÀÀÀJÀÀ¤À¨À©ÀşÀ@ÀAÀeÀÛÀıÀÀÀcÀÀ‘ÀÕÀÀSÀ–ÀÑÀíÀ	 À	À	#À	IÀ	nÀ	wÀ	}À	À	‚À	İÀ
#À
$À
cÀ
ŠÀ À.ÀqÀ‚À†À‡À÷ÀeÀfÀŠÀ À$À(À)À‡À´ÀµÀàÀåÀ:ÀdÀ|À¨À¸ÀÕÀÛÀìÀğÀñÀKÀqÀrÀ¾ÀÄÀÀ%À'À(À]À™ÀªÀâÀãÀ0ÀsÀ}À~ÀÌÀÀFÀOÀPÀÀîÀ1À:À;À‹À™À¢À¤À¥ÀòÀBÀTÀXÀ©À¼ÀÀÀAÀGÀ˜ÀÀíÀ;À‹ÀœÀ¢ÀñÀ÷ÀÀ#À3À9À†ÀŸÀ°ÀÁÀÆÀÇÀáÀøÀùÀ?ÀŠÀ´ÀêÀëÀ÷ÀÀ9À[À~À‚ÀƒÀÀÂÀÃÀÏÀ À"À#ÀtÀÃÀÀ]ÀÀ’ÀÛÀèÀÀ`À±ÀõÀûÀLÀšÀÇÀÀÀ:ÀRÀnÀoÀ½ÀÀ	ÀVÀ~À„À·ÀêÀ À PÀ ƒÀ ‰À ØÀ!$À!*À!8À!xÀ!À!¦À!½À!ÔÀ!ŞÀ!èÀ!îÀ" À"À"'À"-À";À"yÀ"•À"±À"ÍÀ"éÀ"óÀ"ıÀ#À#ŠÀ#À#À#ÛÀ#şÀ$!À$DÀ$gÀ$qÀ${À$À%
À%À%À%_À%…À%«À%ÑÀ%÷À&À&À&;À&RÀ&mÀ&‡À&¥À&¦À&òÀ'À'*À'AÀ'\À'tÀ'À'À'ìÀ(À(/À(FÀ(aÀ(yÀ(¢À(£À(ºÀ(ÙÀ(øÀ)À)À)<À)qÀ)µÀ)şÀ*GÀ*HÀ*`À*lÀ*¹À*ºÀ*ãÀ*øÀ+À+CÀ+ZÀ+dÀ+ŒÀ+¥À+ÄÀ+ÛÀ+åÀ,2À,\À,€À,µÀ,ÙÀ-À-À-_À-eÀ-iÀ-jÀ-vÀ-™À-ÅÀ-ÙÀ-ßÀ-ÿÀ.À.VÀ.xÀ.£À.§À.¨À.´À/%À/&À/2À/SÀ/hÀ/À/¸À/ÑÀ0 À0$À0VÀ0zÀ0¬À0»À0àÀ0æÀ0êÀ0ëÀ0÷À1À1"À19À1rÀ1‹À1ºÀ1ŞÀ2À24À2fÀ2uÀ3À3À3À3À3À3\À3`À3°À3ûÀ4MÀ4cÀ4À4ÀÀ4øÀ5À5MÀ5QÀ5RÀ5vÀ5°À5ÄÀ5ıÀ6À60À6uÀ6‰À6§À6«À6¬À6ÛÀ7 À74À7RÀ7VÀ7WÀ7¥À7ËÀ7èÀ7éÀ8)À8IÀ8JÀ8¯À8äÀ8åÀ98À9iÀ9jÀ9ÎÀ9øÀ9ùÀ:]À:‡À:‰À:ŠÀ:½À:ÁÀ:ÏÀ:ÓÀ;"À;oÀ;¾À;æÀ<2À<]À<zÀ<ÌÀ<ùÀ<úÀ=6À=¥À=şÀ>À>À>PÀ>–À>åÀ?(À?,À?-À?qÀ?ÃÀ@À@SÀ@WÀ@XÀ@œÀ@¢À@ğÀA:ÀAlÀA¸ÀAØÀBÀBÀB~ÀB‚ÀBƒÀBÍÀBÓÀC"ÀCYÀC~ÀCÚÀD"ÀD&ÀD'ÀDxÀDÅÀDìÀDíÀE6ÀEnÀEÀEÀE‘ÀEÃÀFÀFÀF)ÀFNÀFOÀFpÀF´ÀFÀÀF÷ÀFøÀGÀGGÀGHÀGTÀG˜ÀG™ÀG¥ÀGÈÀGôÀHÀHÀH5ÀHeÀH—ÀH›ÀHœÀH¨ÀHğÀHòÀHóÀI+ÀIÀIÀI§ÀI¾ÀIÙÀIÚÀIîÀJ0ÀJ<ÀJsÀJtÀJÀJ§ÀJÒÀJÿÀK0ÀK[ÀKaÀKeÀKfÀKrÀK¼ÀK½ÀKÉÀLÀLÀL!ÀLDÀLpÀL„ÀLŠÀL·ÀLÙÀLûÀM"ÀM&ÀM'ÀM3ÀMfÀMhÀMiÀM›ÀMãÀMäÀMüÀNÀNÀNYÀNeÀNœÀNÀN©ÀNéÀNêÀNöÀO7ÀO8ÀODÀOgÀO“ÀO§ÀO­ÀOÔÀOøÀPÀP!ÀP"ÀP.ÀPcÀPeÀPfÀP—ÀPŞÀPßÀP÷ÀQÀQÀQSÀQ_ÀQ–ÀQ—ÀQ£ÀQâÀQãÀQïÀR/ÀR0ÀR<ÀR_ÀR‹ÀRŸÀR¥ÀRËÀRïÀSÀSÀSÀS%ÀSZÀS\ÀS]ÀSÀSáÀSâÀTÀT$ÀT%ÀT?ÀT…ÀT‘ÀTÈÀTÉÀTÕÀU?ÀU@ÀULÀU¢ÀU£ÀU¯ÀUÒÀUşÀVÀVÀV@ÀVlÀV™ÀVÀVÀVªÀVçÀVéÀVêÀW)ÀW-ÀW}ÀWĞÀXÀXOÀX‹ÀXÀÀXÙÀXíÀY1ÀY5ÀY6ÀYƒÀYÉÀYúÀZÀZ'ÀZXÀZ\ÀZ]ÀZ¡ÀZóÀ["À[;À[OÀ[À[ƒÀ[„À[ÈÀ[ÎÀ\À\fÀ\—À\°À\ÔÀ]À]À],À]fÀ]jÀ]kÀ]À]ĞÀ]éÀ]ıÀ^CÀ^gÀ^kÀ^lÀ^ŸÀ^ÓÀ^ìÀ_ À_VÀ_¬À_åÀ_éÀ_êÀ`*À`JÀ`KÀ`¹Àa ÀaÀajÀa§Àa¨ÀbÀbLÀbMÀb§ÀbìÀbíÀcLÀc‰ÀcŠÀcúÀdMÀdNÀdœÀdÂÀdßÀdáÀdâÀe(Àe]Àe’ÀeÜÀeøÀfÀf"Àf#ÀfBÀfCÀflÀfrÀfÃÀfŞÀföÀgÀg'Àg:ÀgDÀgYÀg]Àg^Àg®ÀgÑÀg×Àh$ÀhnÀh·ÀiÀiÀiLÀi_ÀioÀiÀi«Ài¾ÀiÈÀiÌÀiÎÀiÏÀj$Àj=ÀjAÀjÀjÜÀk)ÀkyÀk}ÀkÒÀl&ÀlÀl×Àm*ÀmSÀmWÀm±ÀmÖÀmÚÀmèÀmìÀn0ÀnzÀnÊÀnôÀo>Ào†Ào­ÀoúÀpHÀpbÀpÀp­ÀqÀqÀqYÀqŸÀq¥ÀqıÀrÀr#Àr†ÀréÀsKÀsTÀsUÀs¦Às¬ÀtÀtbÀtÀt”ÀtîÀuKÀuQÀu·ÀvÀv‚ÀvÀvÀvâÀvèÀw@Àw˜ÀwîÀx	ÀxÀxiÀx¿ÀxÔÀxÚÀy>Ày¢ÀzÀzÀzÀzPÀzVÀz°À{À{À{!À{zÀ{šÀ{ À|À|fÀ|ÈÀ|ÑÀ|ÓÀ|ÔÀ}À}-À}_À}ˆÀ}©À}­À}¾À}ÀÀ}ÁÀ}õÀ~À~WÀ~€À~À~ÁÀ~åÀÀ'ÀFÀJÀ[À]À^À›À½ÀßÀ€À€%À€>À€WÀ€pÀ€À€ƒÀ€„À€ÌÀ€ĞÀ"À5À9ÀGÀKÀÁÀÅÀêÀ‚À‚%À‚tÀ‚ÅÀƒÀƒDÀƒJÀƒ™ÀƒÏÀƒÕÀ„8À„›À„ÿÀ…eÀ…kÀ…¶À…üÀ†À†À†jÀ†½À†ıÀ‡À‡!À‡0À‡JÀ‡hÀ‡À‡ªÀ‡ÏÀ‡òÀˆ.ÀˆAÀˆnÀˆ²ÀˆïÀ‰WÀ‰kÀ‰ÆÀ‰ÊÀ‰ËÀŠÀŠ6ÀŠ<ÀŠ‹ÀŠÜÀ‹&À‹[À‹aÀ‹¯À‹åÀ‹ëÀŒNÀŒ±ÀÀ{ÀÀÒÀÀ3À9À†ÀÙÀÀÀkÀ¹ÀÀQÀ ÀÅÀØÀëÀşÀ‘À‘6À‘^À‘xÀ‘‹À‘¨À‘ÏÀ’À’À’KÀ’ˆÀ’ğÀ’ñÀ“VÀ“²À“öÀ”À”vÀ”ƒÀ”ìÀ•À•À•”À•˜À•™À•éÀ–À–À–XÀ–¦À–áÀ–çÀ—6À—‡À—ÑÀ˜À˜À˜\À˜À˜£À™À™gÀ™ÊÀš/Àš5Àš„ÀšÔÀš÷ÀšıÀ›JÀ›À›İÀ›ïÀœÀœÀœ:ÀœbÀœÀœ¢Àœ¼ÀœãÀ	ÀEÀXÀ…ÀÂÀ*À>À³À·À¸ÀõÀŸÀŸÀŸ…À À 	À ˆÀ ¥À »À ÑÀ æÀ şÀ¡À¡1À¡NÀ¡OÀ¡ïÀ¢À¢"À¢7À¢QÀ¢dÀ¢wÀ¢À¢§À¢ÆÀ¢ÚÀ¢÷À¢øÀ£~À£šÀ£°À£ÆÀ£ŞÀ£ıÀ¤À¤*À¤AÀ¤]À¤^À¤À¤·À¤ÕÀ¤õÀ¥MÀ¥UÀ¥bÀ¥’À¥îÀ¥öÀ¥üÀ¦ À¦À¦À¦AÀ¦iÀ¦À¦•À¦ÑÀ§ À§fÀ§˜À§À§îÀ¨=À¨KÀ¨QÀ¨˜À¨ŞÀ©À©À©WÀ©§À©ôÀªÀª-Àª{ÀªÀª¤ÀªÆÀªÖÀªöÀ«4À«:À«NÀ«ÁÀ«ÚÀ«øÀ«şÀ¬À¬À¬À¬"À¬7À¬GÀ¬KÀ¬LÀ¬ŒÀ¬¬À¬­À­)À­™À­šÀ­åÀ®
À®RÀ®nÀ®pÀ®qÀ®»À®ĞÀ®ÔÀ®şÀ¯NÀ¯ŒÀ¯¨À¯ØÀ¯ìÀ° À°=À°\À°bÀ°rÀ°À°¢À°¬À°°À°±À°ÇÀ°ÈÀ±À±À±\À±¡À±îÀ²À²BÀ²‡À²ĞÀ³À³GÀ³À³ÙÀ³ôÀ´)À´/À´aÀ´¯À´üÀµÀµÀµÀµÀµXÀµ©Àµ÷À¶GÀ¶SÀ¶ À¶ÒÀ¶ÓÀ·À·SÀ·¡À·ÍÀ¸À¸=À¸KÀ¸QÀ¸RÀ¸ŠÀ¸¥À¸³À¸¹À¸ºÀ¸öÀ¹À¹DÀ¹JÀ¹NÀ¹OÀ¹kÀ¹ŠÀ¹‹À¹§À¹ÁÀ¹ÂÀºÀº&Àº'ÀºƒÀº¶Àº·ÀºëÀ»?À»AÀ»BÀ»uÀ»yÀ»®À»öÀ¼FÀ¼”À¼ºÀ¼¾À½À½XÀ½¦À½ïÀ¾(À¾SÀ¾¼À¾ØÀ¾çÀ¿	À¿&À¿-À¿1À¿2À¿NÀ¿OÀ¿À¿»À¿¼À¿ğÀ¿öÀÀDÀÀ’ÀÀİÀÁ+ÀÁ{ÀÁ¥ÀÁ«ÀÁòÀÁøÀÂÀÂ"ÀÂDÀÂcÀÂ~ÀÂˆÀÂÀÂÜÀÂæÀÂìÀÂúÀÃKÀÃvÀÃ§ÀÃØÀÃŞÀÄÀÄ\ÀÄ§ÀÄòÀÅ=ÀÅCÀÅjÀÅ”ÀÅœÀÅ¦ÀÅ¬ÀÅùÀÆNÀÆ_ÀÆeÀÆ¯ÀÆÚÀÇ/ÀÇKÀÇOÀÇPÀÇ†ÀÇŒÀÇäÀÈ'ÀÈ-ÀÈzÀÈ›ÀÈÌÀÉ ÀÉKÀÉOÀÉPÀÉ’ÀÉ˜ÀÉçÀÊ3ÀÊnÀÊzÀÊÀÊ¢ÀÊÄÀÊÔÀÊØÀÊÙÀË>ÀË¤ÀË¥ÀÌÀÌMÀÌNÀÌªÀÌÏÀÌĞÀÍ#ÀÍ?ÀÍAÀÍBÀÍ“ÀÍ—ÀÍºÀÍ÷ÀÎ	ÀÎQÀÎ^ÀÎ_ÀÎ­ÀÎ¾ÀÎ¿ÀÏÀÏ%ÀÏ+ÀÏvÀÏ´ÀÏõÀĞÀĞÀĞÀĞ?ÀĞCÀĞ’ÀĞØÀÑ#ÀÑoÀÑ¿ÀÑåÀÑéÀÒ6ÀÒ„ÀÒÓÀÒãÀÒçÀÓ3ÀÓ‚ÀÓÑÀÔÀÔkÀÔ»ÀÕ
ÀÕWÀÕrÀÕvÀÕÃÀÖÀÖZÀÖ|ÀÖ€ÀÖÏÀ×À×aÀ×²ÀØÀØSÀØvÀØ­ÀØôÀØúÀÙHÀÙ•ÀÙãÀÚ.ÀÚ]ÀÚcÀÚ°ÀÚÙÀÚßÀÛ0ÀÛ~ÀÛÍÀÜ
ÀÜ(ÀÜ.ÀÜ}ÀÜÌÀÜÒÀİ$ÀİMÀİSÀİ£ÀİôÀŞEÀŞ‘ÀŞßÀß*ÀßuÀß…Àß‹ÀßÙÀàÀà	ÀàGÀàMÀà™ÀàêÀá;Àá‡Àá®ÀáºÀáÏÀáíÀâÀâ,ÀâDÀâKÀâŠÀâÕÀâÛÀã2Àã‰ÀãÀãªÀãêÀäÀä;Àä‡ÀäÎÀåÀå&Àå0Àå8Àå>Àå„ÀåÔÀæÀæÀæCÀædÀærÀæ©ÀæÎÀæÜÀæİÀçMÀçÀç•Àç™ÀçšÀçëÀèÀè ÀènÀè»Àé	ÀéTÀéƒÀé‰ÀéÖÀê ÀêlÀê»ÀêÎÀêÔÀë%ÀëtÀë»ÀìÀì]Àì¬ÀìãÀìéÀí8Àí‡ÀíØÀî!ÀîZÀî`Àî°ÀïÀïRÀï¢ÀïìÀğ8Àğ‰Àğ¶Àğ¼Àñ
ÀñZÀñ©Àñ×ÀñİÀòÀò+Àò@Àò]ÀòtÀò™Àò²Àò¹ÀòŞÀóNÀóTÀó—ÀóâÀóèÀô?Àô–ÀôœÀô·Àô÷Àõ-ÀõLÀõ˜ÀõäÀö/Àö<ÀöFÀöNÀöTÀö¨ÀöêÀöğÀöôÀöõÀ÷WÀ÷ŠÀ÷±À÷åÀø#ÀøSÀø†Àø‡Àø×ÀøúÀùÀù%Àù5ÀùMÀù`ÀùjÀùzÀù~ÀùÀùÊÀùïÀú4ÀúPÀúQÀúkÀúµÀú»Àû	ÀûÀû:ÀûNÀû^ÀûzÀûÀû—ÀüÀüÀüÀüÀü]ÀüaÀüÀüáÀüòÀıÀıÀıhÀı²ÀıëÀıñÀş>ÀşÀş£Àş­Àş®ÀşèÀşîÀÿ4Àÿ:Àÿ|Àÿ’Àÿ›ÀÿœÀÿÒÀÿØÀ À 0À ;À =À >À ˆÀ ”À ˜À ·À ÅÀ ıÀÀÀEÀRÀTÀUÀŠÀÀÕÀÀZÀ^À§À÷À@À]ÀaÀ±ÀúÀ/À3À€À¿À×ÀÀ8À>À‡ÀÏÀÀnÀ»ÀşÀÀKÀaÀ±À²ÀúÀ À,À2ÀBÀHÀ™ÀÎÀİÀŞÀ	/À	€À	ÏÀ
À
'À
-À
yÀ
ÊÀÀ`À®ÀøÀşÀKÀQÀuÀ{ÀÉÀÀeÀµÀÚÀàÀ.ÀwÀÈÀÀdÀ´ÀüÀ)À/ÀyÀ’À˜À¦ÀÓÀûÀÀRÀ{À²ÀëÀÀÀ'À1À7À†ÀÔÀ"À@ÀFÀTÀÀÄÀìÀÀCÀzÀ³ÀÍÀÕÀßÀåÀ6À|ÀÆÀÌÀÚÀÀÀrÀ«ÀÅÀÜÀ=ÀvÀÀ˜À¢À¨ÀóÀ<ÀÀÅÀËÀïÀõÀ4À:ÀˆÀÖÀ'ÀrÀÁÀÀZÀ¥ÀöÀGÀbÀhÀxÀ~ÀÎÀğÀ8ÀNÀ{À|À¼ÀÛÀáÀ À&ÀoÀ³ÀÅÀÆÀ"ÀoÀÁÀÇÀ À À ZÀ ªÀ ÌÀ îÀ ïÀ!2À!wÀ!¾À!óÀ!ùÀ"À"4À"5À"…À"ÕÀ"ıÀ"şÀ#MÀ#—À#¨À#®À#ôÀ$À$-À$.À$ƒÀ$¢À$£À$ôÀ%@À%À%¸À%ÛÀ%ÜÀ&,À&gÀ&À&À&âÀ'8À'TÀ'ZÀ'¬À'úÀ(JÀ(wÀ(•À(–À(äÀ(ûÀ)À)WÀ)]À)¡À)§À)ùÀ*AÀ*jÀ*pÀ*ºÀ*ÎÀ+)À+*À+xÀ+—À+À+ôÀ+úÀ,>À,DÀ,–À,ŞÀ-.À-hÀ-iÀ-·À-ËÀ-ÑÀ.'À.-À.qÀ.wÀ.ÉÀ/À/:À/qÀ/rÀ/ÃÀ0À0hÀ0yÀ0À0ÓÀ1&À1xÀ1ÇÀ2À2iÀ2¼À3À3\À3xÀ3~À3¶À4À4\À4«À4íÀ4óÀ5AÀ5hÀ5nÀ5|À5À5¼À5õÀ62À6QÀ6‹À6ÇÀ6ÖÀ6ŞÀ6èÀ6îÀ7?À7‹À7æÀ8:À8JÀ8PÀ8–À8ãÀ9À9À9mÀ9¼À:À: À:5À:RÀ:SÀ:¤À:öÀ;IÀ;OÀ;ŸÀ;ñÀ<AÀ<‘À<ãÀ=7À=ŠÀ=—À=À=ÒÀ=õÀ=öÀ>9À>…À>¢À>ÖÀ>×À?&À?nÀ?tÀ?ÂÀ?ÈÀ@3À@¢À@ÖÀ@×ÀAÀAÀAQÀAlÀA‹ÀAŒÀAÜÀBÀBÀBˆÀB÷ÀC ÀC!ÀCrÀC´ÀCºÀD&ÀD–ÀDÂÀDÃÀEÀEcÀE‰ÀEÀEÔÀFÀFÀF\ÀF­ÀFĞÀFÖÀGAÀG°ÀGÙÀGÚÀH%ÀHwÀHÆÀHéÀHïÀI\ÀIÍÀJÀJÀJCÀJIÀJ‰ÀJÖÀK ÀKtÀKÅÀLÀLAÀLGÀL¶ÀM)ÀM/ÀM‡ÀMåÀMæÀNÀN!ÀNjÀN³ÀNßÀOÀO	ÀOWÀO®ÀOéÀOêÀP9ÀP…ÀP‹ÀPÚÀPóÀPùÀQEÀQÀQ¡ÀQåÀQæÀR-ÀR3ÀRÀRÏÀSÀSiÀS¬ÀS²ÀT ÀTMÀT›ÀTâÀTóÀU:ÀU;ÀU‚ÀU›ÀUÀÀUÁÀVÀVÀV#ÀVnÀV{ÀVÀVÍÀWÀWXÀW^ÀW­ÀWùÀWÿÀXPÀXÀXêÀXğÀY:ÀY†ÀYÓÀZÀZÀZSÀZYÀZ ÀZ¦ÀZìÀ[6À[<À[LÀ[RÀ[¢À[»À\À\À\KÀ\QÀ\¡À\îÀ\ôÀ]:À]„À]ŠÀ]šÀ] À]îÀ^À^XÀ^YÀ^£À^©À^õÀ_À_À_UÀ_¦À_½À_ÃÀ`À`ZÀ`¦À`îÀa>Àa‰ÀaÔÀb#ÀbtÀbÂÀbüÀcÀc)Àc/Àc?ÀcÀcÜÀdÀdUÀdŸÀd ÀdäÀdêÀe;Àe”ÀeçÀf;ÀfsÀfyÀfÉÀgÀgiÀg»ÀhÀh_Àh«Àh±ÀiÀiRÀi§ÀişÀj.Àj‚ÀjĞÀkÀkÀkmÀk¼ÀlÀlUÀlªÀl°ÀmÀmUÀmÀm¤ÀmõÀnÀnÀn$Àn9ÀnbÀnuÀnŒÀn”ÀnšÀnÈÀnşÀoÀo]Ào{ÀoœÀo¢Ào´ÀoãÀpÀp;ÀpoÀp™Àp¸ÀpÔÀqÀq/ÀqMÀq“ÀqÁÀqïÀr ÀrÀrIÀrŒÀr³Àr½ÀrÃÀrÒÀrÚÀräÀrêÀsCÀsIÀsWÀslÀs°ÀsÃÀsÚÀsíÀtÀtÀtÀtBÀtxÀt~Àt×ÀtõÀuÀuÀu.Àu]Àu~ÀuµÀuéÀvÀv>ÀvZÀv—ÀvµÀvÓÀwÀwGÀwuÀw†Àw›ÀwÏÀxÀx(Àx\ÀxÀx¼ÀxÆÀxÌÀxÛÀxãÀxíÀxóÀy<Ày‡ÀyºÀyÀÀyĞÀyÖÀz$Àz;ÀzYÀzˆÀz«ÀzÑÀzøÀ{À{8À{9À{}À{ƒÀ{ÔÀ|-À|€À|ÔÀ}&À}xÀ}¯À}µÀ~À~MÀ~SÀ~¤À~äÀÀÀcÀ­À³ÀÿÀ€LÀ€œÀ€¢À€ıÀÀÀ"À7À`ÀsÀŠÀ’À˜ÀÆÀüÀ‚À‚[À‚yÀ‚šÀ‚ À‚²À‚áÀƒ1Àƒ€ÀƒÑÀƒíÀ„2À„|À„´À„ßÀ…À…>À…eÀ…•À…½À…ÃÀ†À†wÀ†ÑÀ‡À‡?À‡kÀ‡ªÀ‡éÀ‡õÀˆÀˆtÀˆ~Àˆ„Àˆ“Àˆ›Àˆ¥Àˆ«À‰À‰
À‰À‰-À‰qÀ‰„À‰›À‰®À‰ÇÀ‰ÏÀ‰ÕÀŠÀŠ9ÀŠ?ÀŠ˜ÀŠ¶ÀŠ×ÀŠİÀŠïÀ‹À‹nÀ‹½ÀŒÀŒ*ÀŒoÀŒ¹ÀŒ÷À/ÀZÀÀ¹ÀàÀÀ8À>À™ÀğÀKÀ¨ÀóÀ9ÀbÀ|À·ÀÓÀïÀ‘3À‘_À‘‹À‘šÀ‘ÑÀ’À’=À’rÀ’xÀ’ÒÀ“,À“„À“ËÀ“úÀ”À”'À”•À”ŸÀ”¥À”´À”¼À”ÆÀ”ÌÀ”ÜÀ”âÀ•/À•DÀ•eÀ•”À•»À•âÀ–À–0À–RÀ–SÀ– À–¦À–öÀ—À—À—7À—À—À—‘À—ßÀ—ûÀ˜<À˜\À˜¹À˜¿À˜óÀ™À™1À™À™‘À™’À™üÀšqÀšrÀšÎÀ›*À›oÀ›”À›•À›¡À›ïÀœÀœÀœÀœBÀœ\Àœ˜Àœ¥ÀœÉÀ.À4À8À9À›ÀõÀöÀkÀîÀïÀûÀŸLÀŸgÀŸhÀŸtÀŸÓÀŸşÀŸÿÀ À bÀ À ‚À À ñÀ¡"À¡#À¡/À¡nÀ¡oÀ¡ÎÀ¡üÀ¡ıÀ¢	À¢aÀ¢‰À¢ŠÀ¢–À¢ôÀ£ À£!À£-À£UÀ£uÀ£³À£¹À£ÒÀ£ÖÀ£×À¤$À¤UÀ¤VÀ¤bÀ¤À¤²À¤ÎÀ¤âÀ¤æÀ¤çÀ¥7À¥kÀ¥lÀ¥xÀ¥ÔÀ¥ôÀ¦LÀ¦PÀ¦QÀ¦ĞÀ§?À§@À§LÀ§‡À§©À§ÛÀ§ßÀ§àÀ¨3À¨tÀ¨uÀ¨À¨¹À¨êÀ¨îÀ¨ïÀ©HÀ©‡À©ˆÀ©”À©²À©áÀªÀªHÀªLÀªMÀª£ÀªÜÀªİÀªéÀ«À«<À«cÀ«©À«­À«®À¬
À¬IÀ¬JÀ¬VÀ¬‹À¬¹À¬½À¬¾À­ À­VÀ­WÀ­cÀ­˜À­¸À­ØÀ® À®$À®%À®™À¯À¯À¯À¯>À¯kÀ¯oÀ¯pÀ¯ÅÀ°À°À°À°IÀ°iÀ°ÃÀ°ÇÀ°ÈÀ±<À±¾À±¿À±ËÀ±øÀ²À²\À²`À²aÀ²¾À³À³À³+À³fÀ³ˆÀ³ªÀ´À´À´À´mÀ´áÀ´âÀ´îÀµÀµ8Àµ’Àµ–Àµ—À¶À¶À¶À¶šÀ¶ÔÀ¶óÀ·5À·9À·:À·¨À¸À¸À¸&À¸…À¸¥À¹!À¹%À¹&À¹¯À¹ÉÀ¹ÜÀ¹îÀºÀºÀº0ÀºIÀº_Àº‚ÀºÀºÀºªÀºÔÀ»À»À»À»}À»ÛÀ»ÜÀ»èÀ¼$À¼FÀ¼jÀ¼ìÀ½À½SÀ½YÀ½]À½^À½ÛÀ¾eÀ¾fÀ¾rÀ¾·À¾ÙÀ¾øÀ¿À¿NÀ¿À¿³À¿çÀÀÀÀOÀÀÀÀµÀÀêÀÁ#ÀÁYÀÁÀÁ·ÀÂÀÂÀÂÀÂÀÂÁÀÂäÀÂøÀÃÀÃ#ÀÃ:ÀÃRÀÃhÀÃ}ÀÃ”ÀÃ¬ÀÃÏÀÃéÀÄÀÄ	ÀÄÀÄ]ÀÄÀÄ¡ÀÄÀÀÄ÷ÀÅ-ÀÅbÀÅ™ÀÅÑÀÆÀÆ6ÀÆjÀÆŸÀÆØÀÇÀÇSÀÇlÀÇºÀÇÀÀÇÄÀÇÅÀÈvÀÈ™ÀÈ­ÀÈÆÀÈŞÀÈøÀÉÀÉ)ÀÉ>ÀÉUÀÉmÀÉÀÉªÀÉÉÀÉÊÀÉÖÀÉüÀÊ ÀÊMÀÊQÀÊRÀÊ¨ÀÊŞÀÊßÀÊëÀË&ÀËrÀËÀËÂÀËíÀÌ%ÀÌ)ÀÌ*ÀÌ6ÀÌÀÌÚÀÌŞÀÌßÀÌëÀÍ8ÀÍZÀÍ¥ÀÍ«ÀÍòÀÍöÀÍ÷ÀÎ\ÀÎÍÀÎÎÀÎÚÀÏ%ÀÏJÀÏ•ÀÏ™ÀÏšÀĞÀĞzÀĞ{ÀĞ‡ÀĞ¥ÀĞÔÀĞ÷ÀÑÀÑDÀÑeÀÑ…ÀÑ§ÀÑêÀÑëÀÒÀÒ=ÀÒˆÀÒÀÒÛÀÓCÀÓIÀÓJÀÓ‘ÀÓĞÀÓÑÀÓûÀÔÀÔ@ÀÔeÀÔŠÀÔÀÀÔâÀÕÀÕ:ÀÕpÀÕ¤ÀÕØÀÕşÀÖ#ÀÖJÀÖrÀÖxÀÖyÀÖâÀ×#À×[À×\À×‚À×áÀØ'ÀØ.ÀØ/ÀØHÀØ–ÀØœÀØ ÀØ¡ÀØ­ÀØÎÀØıÀÙ$ÀÙKÀÙuÀÙ™ÀÙ¼ÀÙíÀÙîÀÚÀÚCÀÚ‘ÀÚ—ÀÚµÀÛÀÛÀÛUÀÛÎÀÛÔÀÜÀÜÀÜ3ÀÜˆÀÜÒÀÜÙÀÜÚÀÜóÀİAÀİGÀİKÀİLÀİàÀİÿÀŞ"ÀŞ<ÀŞZÀŞnÀŞÀŞ¨ÀŞÁÀŞÖÀŞôÀŞõÀßÀßYÀß¬Àß°Àß±ÀàÀà‚Àà„Àà…Àà³ÀàòÀàóÀá;Àá?ÀásÀáwÀá¾Àâ ÀâBÀâ[ÀâšÀâ ÀâëÀã-ÀãNÀãwÀãxÀã¹Àã¿Àä
ÀäMÀänÀä˜Àä™ÀäÃÀäÉÀåÀågÀå°ÀåàÀåáÀæ#Àæ)Àæ`Àæ¯ÀæşÀçGÀçMÀçÀçëÀèÀèÀènÀè·ÀèĞÀèÖÀé%Àé:ÀéfÀégÀé·ÀéÚÀéìÀéíÀê3Àê9Àê‡ÀêÀê·Àê¸ÀëÀëÀëXÀëŠÀëªÀë¬Àë­ÀëÇÀìÀìaÀì}ÀìƒÀì¹ÀìÕÀìëÀììÀìøÀí)ÀíAÀífÀíšÀí Àí¶ÀîÀî#Àî=ÀîNÀîÀî—Àî¡Àî¨Àî¬Àî­ÀïÀï`ÀïaÀïmÀïšÀï²Àï×ÀğÀğÀğÀğ7Àğ_Àğ•Àğ™ÀğšÀğúÀñ@ÀñAÀñMÀñ`ÀñxÀñˆÀñ Àñ³Àñ½ÀñàÀñğÀñôÀñõÀò@ÀòeÀò©ÀòÅÀòÆÀòàÀòáÀòíÀóÀóÀó,ÀóHÀó[ÀóeÀóÕÀóÙÀóÚÀóæÀôDÀômÀôoÀôpÀô·Àô»Àõ ÀõEÀõfÀõ§ÀõîÀö
Àö@ÀöAÀö|Àö‚ÀöÆÀ÷À÷DÀ÷‰À÷ÅÀ÷İÀ÷ŞÀøÀøÀø^Àø®ÀøóÀùÀùÀùÀùpÀùŒÀù»Àù¼Àú Àú Àú!Àú-ÀúXÀúYÀúeÀú€Àú›ÀúßÀúåÀûÀû8ÀûWÀûkÀû¾ÀüÀü*Àü>ÀüBÀüCÀüœÀüÖÀü×ÀüñÀüóÀüôÀı	ÀıÀıIÀıXÀırÀıxÀıÃÀşÀş(Àş.ÀşoÀşuÀşÄÀşİÀşîÀÿÀÿ;ÀÿVÀÿ«Àÿ¬ÀÿÜÀ  À *À UÀ |À £À ÍÀ ÎÀ şÀÀVÀyÀÀÀÎÀÔÀ"ÀnÀ°ÀÇÀÈÀÀ5À6ÀhÀnÀ¡À§ÀÔÀGÀ}À±ÀµÀ¶ÀòÀøÀ+ÀgÀhÀµÀ»ÀøÀGÀnÀtÀ¸ÀÀPÀrÀ†À™À¯ÀòÀöÀ÷ÀIÀWÀwÀŠÀÀ½ÀäÀëÀïÀğÀ	 À	&À	oÀ	´À	ØÀ	ŞÀ
À
QÀ
›À
æÀ2À€ÀĞÀÀaÀgÀ¶ÀÖÀëÀ#À8ÀOÀdÀsÀ”ÀœÀ©ÀÀÀÛÀêÀÀ4ÀkÀ­À¸ÀÀÀÆÀÊÀËÀÀ
ÀRÀXÀ{ÀÉÀëÀşÀÀÀ0À\À—ÀÇÀöÀüÀ3ÀZÀ`À—À¸À¾ÀÑÀÕÀÖÀâÀÀ'À:À@À[À{ÀÀÈÀÌÀÍÀÙÀÀÀdÀ¶ÀÒÀÀ'ÀAÀGÀHÀ…À»À¼ÀÖÀ#ÀUÀŠÀ‹ÀÄÀÀÀCÀpÀqÀ¨ÀÕÀÖÀ%À_À…À‹ÀŒÀ¤À¨À©ÀµÀøÀúÀûÀBÀFÀ•À«ÀéÀÀÀ[ÀpÀ±ÀöÀ(ÀUÀsÀwÀxÀ²À¸ÀñÀ/ÀtÀ½ÀÀ4À|À·ÀèÀ$À?ÀYÀ…ÀÀ¶À¾ÀÂÀÃÀôÀúÀ3ÀpÀ«ÀÜÀÀ,ÀFÀ€ÀˆÀ±À¹À½À¾À À VÀ WÀ ´À!À!À!^À!ªÀ!«À!ßÀ!üÀ"À"À"+À",À"UÀ"[À"¬À"ÇÀ"ßÀ"ïÀ#À##À#-À#BÀ#FÀ#GÀ#—À#ºÀ#ÀÀ$À$WÀ$¤À$ñÀ%?À%]À%pÀ%€À%ŸÀ%¼À%ÏÀ%ÙÀ%éÀ%íÀ%îÀ&9À&^À&ªÀ&ÆÀ&ÈÀ&ÉÀ'À'À'gÀ'À' À'ÙÀ'ßÀ(/À(À(›À(¡À(ïÀ)BÀ)ƒÀ)ÀÀ)ßÀ)ıÀ*À*.À*AÀ*gÀ*ŠÀ*‹À*ÖÀ+À+cÀ+•À+ÍÀ+íÀ+ñÀ+òÀ,À,"À,]À,nÀ,oÀ,šÀ, À,ÛÀ,íÀ,îÀ- À-&À-]À-vÀ-wÀ-ÇÀ-êÀ-ğÀ.;À.`À.rÀ.sÀ.ÁÀ.İÀ.ãÀ/.À/{À/ŒÀ/’À/àÀ0À0QÀ0SÀ0TÀ0´À0ÒÀ0ÓÀ1À1À1bÀ1´À1ÎÀ1ÔÀ2"À2uÀ2¶À2óÀ3À3/À3GÀ3`À3sÀ3™À3 À3´À3ÊÀ4À4'À4uÀ4yÀ4zÀ4ÜÀ5/À50À5™À6'À6(À67À68À6‘À6­À6®À6ºÀ6åÀ6æÀ6öÀ6÷À7QÀ7nÀ7oÀ7{À7©À7ªÀ7ÁÀ7ÂÀ8#À8GÀ8HÀ8TÀ8—À8˜À8¤À8ğÀ9À9À9À9hÀ9›À9µÀ9»À9ğÀ:À:À:À:IÀ:dÀ:À:¿À:şÀ;!À;_À;€À;¶À;¼À;İÀ;ÿÀ< À<*À<eÀ<wÀ<{À<|À<çÀ==À=?À=@À=uÀ=¥À=¦À=ŞÀ=âÀ>,À>9À>|À>}À>ÌÀ>áÀ>äÀ?1À?NÀ?QÀ?À? À?²À?µÀ?ÀÀ?ôÀ?÷À@2À@oÀ@tÀ@wÀ@–À@ÆÀ@ËÀ@ÒÀ@ÕÀA*ÀA€ÀA¬ÀA¯ÀBÀB9ÀBoÀB¶ÀBúÀC7ÀCKÀCwÀCŒÀCÀCËÀCÚÀDÀD"ÀD/ÀDLÀDRÀDXÀDhÀDÀD›ÀDŸÀDºÀD¼ÀD½ÀEÀEZÀE^ÀE®ÀEşÀF3ÀFnÀF³ÀF´ÀFéÀGÀGÀGTÀGoÀGpÀG|ÀG’ÀGìÀHÀHÀHdÀHÀH“ÀH±ÀHµÀH·       ,‡Şª#ŒĞ„ë/// An immutable 32 bit color value in ARGB format.
///
/// Consider the light teal of the Flutter logo. It is fully opaque, with a red
/// channel value of 0x42 (66), a green channel value of 0xA5 (165), and a blue
/// channel value of 0xF5 (245). In the common "hash syntax" for color values,
/// it would be described as `#42A5F5`.
///
/// Here are some ways it could be constructed:
///
/// ```dart
/// Color c1 = const Color(0xFF42A5F5);
/// Color c2 = const Color.fromARGB(0xFF, 0x42, 0xA5, 0xF5);
/// Color c3 = const Color.fromARGB(255, 66, 165, 245);
/// Color c4 = const Color.fromRGBO(66, 165, 245, 1.0);
/// ```
///
/// If you are having a problem with `Color` wherein it seems your color is just
/// not painting, check to make sure you are specifying the full 8 hexadecimal
/// digits. If you only specify six, then the leading two digits are assumed to
/// be zero, which means fully-transparent:
///
/// ```dart
/// Color c1 = const Color(0xFFFFFF); // fully transparent white (invisible)
/// Color c2 = const Color(0xFFFFFFFF); // fully opaque white (visible)
/// ```
///
/// See also:
///
///  * [Colors](https://api.flutter.dev/flutter/material/Colors-class.html), which
///    defines the colors found in the Material Design specification. ŒÚ‚í ™‚|/// Construct a color from the lower 32 bits of an [int].
///
/// The bits are interpreted as follows:
///
/// * Bits 24-31 are the alpha value.
/// * Bits 16-23 are the red value.
/// * Bits 8-15 are the green value.
/// * Bits 0-7 are the blue value.
///
/// In other words, if AA is the alpha value in hex, RR the red value in hex,
/// GG the green value in hex, and BB the blue value in hex, a color can be
/// expressed as `const Color(0xAARRGGBB)`.
///
/// For example, to get a fully opaque orange, you would use `const
/// Color(0xFFFF9000)` (`FF` for the alpha, `FF` for the red, `90` for the
/// green, and `00` for the blue).Ÿ	¤  
wx~²¬º´¼Ë‚‚‘’‘“‘›£/// Construct a color from the lower 8 bits of four integers.
///
/// * `a` is the alpha value, with 0 being transparent and 255 being fully
///   opaque.
/// * `r` is [red], from 0 to 255.
/// * `g` is [green], from 0 to 255.
/// * `b` is [blue], from 0 to 255.
///
/// Out of range values are brought into range using modulo 255.
///
/// See also [fromRGBO], which takes the alpha value as a floating point
/// value.‘œ‘¡  ‘£‘¨  ‘ª‘¯  ‘±‘¶  -‘Ä‘¾’@‘Æ’>’‘ü‘Ú‘Ç‘Ø‘Ó‘È‘Ñ‘Ë‘É‘Í‘Ö‘é‘ú‘õ‘ê‘ó‘í‘ë‘ï‘ø’’’’’’’’’’-’=’9’.’7’1’/’3’<’B’Qƒ ”=”>”FÊ/// Create a color from red, green, blue, and opacity, similar to `rgba()` in CSS.
///
/// * `r` is [red], from 0 to 255.
/// * `g` is [green], from 0 to 255.
/// * `b` is [blue], from 0 to 255.
/// * `opacity` is alpha channel of this color as a double, with 0.0 being
///   transparent and 1.0 being fully opaque.
///
/// Out of range values are brought into range using modulo 255.
///
/// See also [fromARGB], which takes the opacity as an integer value.”G”L  ”N”S  ”U”Z  ”\”d  3”x”r•D”z•B•”Ø”¢”{” ”›”|”™”“”}”‘””†”~”ˆ””•””²”Ö”Ñ”³”Ï”É”´”Ë”Ô”è••”é•”ÿ”ê••
••A•=••;•5• •7•@•F•U–[€ë/// A 32 bit value representing this color.
///
/// The bits are assigned as follows:
///
/// * Bits 24-31 are the alpha value.
/// * Bits 16-23 are the red value.
/// * Bits 8-15 are the green value.
/// * Bits 0-7 are the blue value. –e€Ü—€§/// The alpha channel of this color in an 8 bit value.
///
/// A value of 0 means this color is fully transparent. A value of 255 means
/// this color is fully opaque.   —E€Ï—ü€£/// The alpha channel of this color as a double.
///
/// A value of 0.0 means this color is fully transparent. A value of 1.0 means
/// this color is fully opaque.   ˜a˜W4/// The red channel of this color in an 8 bit value.   ˜}d˜¾6/// The green channel of this color in an 8 bit value.   ˜åb™%5/// The blue channel of this color in an 8 bit value.   ±u/±‰   ±u±v™K	š€´/// Returns a new color that matches this color with the alpha channel
/// replaced with `a` (which ranges from 0 to 255).
///
/// Out of range values will have unexpected effects. šš   šXU›-€Æ/// Returns a new color that matches this color with the alpha channel
/// replaced with the given `opacity` (which ranges from 0.0 to 1.0).
///
/// Out of range values will have unexpected effects. ›9›A   ›±œr€²/// Returns a new color that matches this color with the red channel replaced
/// with `r` (which ranges from 0 to 255).
///
/// Out of range values will have unexpected effects. œzœ   œ¼	€´/// Returns a new color that matches this color with the green channel
/// replaced with `g` (which ranges from 0 to 255).
///
/// Out of range values will have unexpected effects. ‰   É‹€³/// Returns a new color that matches this color with the blue channel replaced
/// with `b` (which ranges from 0 to 255).
///
/// Out of range values will have unexpected effects. ”™   Ÿ€ÅŸ!  Ÿ:ŸB   ŸÜ‚K ê€ú/// Returns a brightness value between 0 for darkest and 1 for lightest.
///
/// Represents the relative luminance of the color. This value is computationally
/// expensive to calculate.
///
/// See <https://en.wikipedia.org/wiki/Relative_luminance>.   ¢+‡A§-„Ç/// Linearly interpolate between two colors.
///
/// This is intended to be fast but as a result may be ugly. Consider
/// [HSVColor] or writing custom logic for interpolating colors.
///
/// If either color is null, this function linearly interpolates from a
/// transparent instance of the other color. This is usually preferable to
/// interpolating from [material.Colors.transparent] (`const
/// Color(0x00000000)`), which is specifically transparent _black_.
///
/// The `t` argument represents position on the timeline, with 0.0 meaning
/// that the interpolation has not started, returning `a` (or something
/// equivalent to `a`), 1.0 meaning that the interpolation has finished,
/// returning `b` (or something equivalent to `b`), and values in between
/// meaning that the interpolation is at the relevant point on the timeline
/// between `a` and `b`. The interpolation can be extrapolated beyond 0.0 and
/// 1.0, so negative values and values greater than 1.0 are valid (and can
/// easily be generated by curves such as [Curves.elasticInOut]). Each channel
/// will be clamped to the range 0 to 255.
///
/// Values for `t` are usually obtained from an [Animation<double>], such as
/// an [AnimationController]. §2§:  §<§D  §F§N   ©p† «„ö/// Combine the foreground color as a transparent color over top
/// of a background color, and return the resulting combined color.
///
/// This uses standard alpha blending ("SRC over DST") rules to produce a
/// blended color from two colors. This can be used as a performance
/// enhancement when trying to avoid needless alpha blending compositing
/// operations for two things that are solid colors with the same shape, but
/// overlay each other: instead, just paint one with the combined color. ««–  «¡«¨   ¯”€í°w/// Returns an alpha value representative of the provided [opacity] value.
///
/// The [opacity] value may not be null. °1°9   °…€ì°Ÿ  °¢°ª  °…°†±¨W±»   ±¨±© À «À GlÀ «Ã€ª/// A description of the style to use when drawing on a [Canvas].
///
/// Most APIs on [Canvas] take a [Paint] object to describe the style
/// to use for that operation. À «Í€¢ À ¬+À ¬0Y/// Constructs an empty [Paint] object with all fields initialized to
/// their defaults.  'À ¯OLÀ ¯z 	À ¯OÀ ¯PÀ ¯VÀ ¯gÀ ¯WÀ ¯‚À ¯ŠÀ ¯šÀ ¯‹À ¯ 'À ¯± À ¯ÆÀ ¯Ë!À ¯Ü À ¯ëÀ ¯ğ%À ° À °À °!À °* À °9À °>'À °O À °dÀ °i%À °z À °À °’&À °£ À °·À °¼,À °Í À °çÀ °ì)À °ı À ±À ±&À ±* À ±>À ±C0À ±T À ±qÀ ±w,À ±ˆ À ±¡À ±§(À ±¸ À ±ÍÀ ±Ó#À ±ä À ±ôÀ ±û>À ² À ²5À ²"À ²8À ²=2À ²N À ²kÀ ²^À ²nÀ ²s:À ²„ À ²©À ²˜À ²¬À ²±2À ²Â À ²ßÀ ²ÒÀ ²âÀ ²ç>À ²ø À ³!À ³À ³$À ³):À ³: À ³_À ³NÀ ³bÀ ³g<À ³x À ³ŸÀ ³À ³¢À ³§HÀ ³¸ À ³ëÀ ³ÓÀ ³îÀ ³óBÀ ´ À ´1À ´À ´4À ´9<À ´J À ´qÀ ´_À ´tÀ ´yNÀ ´Š À ´ÃÀ ´¨À ´ÆÀ ´ËFÀ ´Ü À µÀ ´öÀ µÀ µ>À µ& À µOÀ µ<À µRÀ µW4À µh À µ‡À µyÀ µŠÀ µĞ%À µá À µóÀ ¶_3À ¶Š À ¶_À ¶`À ¶fÀ ¶wÀ ¶gÀ ·"À · À ·.À ·3'À ·D À ·YÀ ·^'À ·o À ·„À ·‰"À ·š À ·ªÀ ¹ö,À º À ºÀ ½=À ½. À ½CÀ ½LÀ ½MÀ ½TÀ ½UÀ ÌT3À Ìh À Ì„À ç­‚ğÀ ê†‚®/// Whether to dither the output when drawing images.
///
/// If false, the default value, dithering will be enabled when the input
/// color depth is higher than the output color depth. For example,
/// drawing an RGB8 image onto an RGB565 canvas.
///
/// This value also controls dithering of [shader]s, which can make
/// gradients appear smoother.
///
/// Whether or not dithering affects the output is implementation defined.
/// Some implementations may choose to ignore this completely, if they're
/// unable to control dithering.
///
/// To ensure that dithering is consistently enabled for your entire
/// application, set this to true before invoking any drawing related code.À ê˜À ·Ş€ÓÀ ¸Yi/// Whether to apply anti-aliasing to lines and images drawn on the
/// canvas.
///
/// Defaults to true.   À ¸´À ¸¸  À ¸Ä
À ¸Ê   À º'‚'À »Î„/// The color to use when stroking or filling a shape.
///
/// Defaults to opaque black.
///
/// See also:
///
///  * [style], which controls whether to stroke or fill (or both).
///  * [colorFilter], which overrides [color].
///  * [shader], which overrides [color] with more elaborate effects.
///
/// This color is not used when compositing. To colorize a layer, use
/// [colorFilter].   À ¼Q€À ¼U  À ¼[À ¼b   À ½_ƒœÀ Àd‚Ò/// A blend mode to apply when a shape is drawn or a layer is composited.
///
/// The source colors are from the shape being drawn (e.g. from
/// [Canvas.drawPath]) or layer being composited (the graphics that were drawn
/// between the [Canvas.saveLayer] and [Canvas.restore] calls), after applying
/// the [colorFilter], if any.
///
/// The destination colors are from the background onto which the shape or
/// layer is being composited.
///
/// Defaults to [BlendMode.srcOver].
///
/// See also:
///
///  * [Canvas.saveLayer], which uses its [Paint]'s [blendMode] to composite
///    the layer when [Canvas.restore] is called.
///  * [BlendMode], which discusses the user of [Canvas.saveLayer] with
///    [blendMode].   À Àş€ À Á  À ÁÀ Á   À Á¢€áÀ Â&k/// Whether to paint inside shapes, the edges of shapes, or both.
///
/// Defaults to [PaintingStyle.fill].   À Â†€‡À ÂŠ  À ÂÀ ÂŸ   À ÃiÀ Ä%€ş/// How wide to make edges drawn when [style] is set to
/// [PaintingStyle.stroke]. The width is given in logical pixels measured in
/// the direction orthogonal to the direction of the path.
///
/// Defaults to 0.0, which correspond to a hairline width.   À Ä}€‹À Ä  À ÄÀ Ä•   À ÅÀ ÅÃ€ /// The kind of finish to place on the end of lines drawn when
/// [style] is set to [PaintingStyle.stroke].
///
/// Defaults to [StrokeCap.butt], i.e. no caps.   À Æ'€‹À Æ+  À Æ5À Æ@   À Æ¶„ÑÀ Ë#„+/// The kind of finish to place on the joins between segments.
///
/// This applies to paths drawn when [style] is set to [PaintingStyle.stroke],
/// It does not apply to points drawn as lines with [Canvas.drawPoints].
///
/// Defaults to [StrokeJoin.miter], i.e. sharp corners.
///
/// Some examples of joins:
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/miter_4_join.mp4}
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/round_join.mp4}
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/bevel_join.mp4}
///
/// The centers of the line segments are colored in the diagrams above to
/// highlight the joins, but in normal usage the join is the same color as the
/// line.
///
/// See also:
///
///  * [strokeMiterLimit] to control when miters are replaced by bevels when
///    this is set to [StrokeJoin.miter].
///  * [strokeCap] to control what is drawn at the ends of the stroke.
///  * [StrokeJoin] for the definitive list of stroke joins.   À ËŠ€À Ë  À Ë™À Ë¥   À ÌŒ…rÀ ÑŸ„Ó/// The limit for miters to be drawn on segments when the join is set to
/// [StrokeJoin.miter] and the [style] is set to [PaintingStyle.stroke]. If
/// this limit is exceeded, then a [StrokeJoin.bevel] join will be drawn
/// instead. This may cause some 'popping' of the corners of a path if the
/// angle between line segments is animated, as seen in the diagrams below.
///
/// This limit is expressed as a limit on the length of the miter.
///
/// Defaults to 4.0.  Using zero as a limit will cause a [StrokeJoin.bevel]
/// join to be used all the time.
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/miter_0_join.mp4}
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/miter_4_join.mp4}
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/miter_6_join.mp4}
///
/// The centers of the line segments are colored in the diagrams above to
/// highlight the joins, but in normal usage the join is the same color as the
/// line.
///
/// See also:
///
///  * [strokeJoin] to control the kind of finish to place on the joins
///    between segments.
///  * [strokeCap] to control what is drawn at the ends of the stroke.   À Ò€±À Ò  À ÒÀ Ò   À Ò¶‚WÀ Ó~€¯/// A mask filter (for example, a blur) to apply to a shape after it has been
/// drawn but before it has been composited into the image.
///
/// See [MaskFilter] for details.   À Õ‚°À Õ  À ÕÀ Õ,   À ×ÄìÀ ÙC/// Controls the performance vs quality trade-off to use when sampling bitmaps,
/// as with an [ImageShader], or when drawing images, as with [Canvas.drawImage],
/// [Canvas.drawImageRect], [Canvas.drawImageNine] or [Canvas.drawAtlas].
///
/// Defaults to [FilterQuality.none].   À Ù³€—À Ù·  À ÙÅÀ ÙÔ   À ÚNÈÀ ÛÚk/// The shader to use when stroking or filling a shape.
///
/// When this is null, the [color] is used instead.
///
/// See also:
///
///  * [Gradient], a shader that paints a color gradient.
///  * [ImageShader], a shader that tiles an [Image].
///  * [colorFilter], which overrides [shader].
///  * [color], which is used if [shader] and [colorFilter] are null.   À ÜïÀ Ü  À Ü$À Ü-   À ŞvÀ Şø€Î/// A color filter to apply when a shape is drawn or when a layer is
/// composited.
///
/// See [ColorFilter] for details.
///
/// When a shape is being drawn, [colorFilter] overrides [color] and [shader].   À ß…<À ß‰  À ß•À ß£   À àÅ‚ˆÀ âÃÈ/// The [ImageFilter] to use when drawing raster images.
///
/// For example, to blur an image using [Canvas.drawImage], apply an
/// [ImageFilter.blur]:
///
/// ```dart
/// void paint(Canvas canvas, Size size) {
///   canvas.drawImage(
///     _image,
///     ui.Offset.zero,
///     Paint()..imageFilter = ui.ImageFilter.blur(sigmaX: 0.5, sigmaY: 0.5),
///   );
/// }
/// ```
///
/// See also:
///
///  * [MaskFilter], which is used for drawing geometry.   À ãP·À ãT  À ã`À ãn   À ånÀ æ /// Whether the colors of the image are inverted when drawn.
///
/// Inverting the colors of an image applies a new color filter that will
/// be composed with any user provided color filters. This is primarily
/// used for implementing smart invert on iOS.   À æ|lÀ æ€  À æ
À æ“   À æìXÀ æõ    À çGbÀ çK  À çS
À çY   À ¶—rÀ ¶¥    À ê¢‡ÚÀ êµ   À ê¢À ê£ À¦hÀµ„/// Opaque handle to raw decoded image data (pixels).
///
/// To obtain an [Image] object, use the [ImageDescriptor] API.
///
/// To draw an [Image], use one of the methods on the [Canvas] class, such as
/// [Canvas.drawImage].
///
/// A class or method that receives an image object must call [dispose] on the
/// handle when it is no longer needed. To create a shareable reference to the
/// underlying image, call [clone]. The method or object that receives
/// the new instance will then be responsible for disposing it, and the
/// underlying image itself will be disposed when all outstanding handles are
/// disposed.
///
/// If `dart:ui` passes an `Image` object and the recipient wishes to share
/// that handle with other callers, [clone] must be called _before_ [dispose].
/// A handle that has been disposed cannot create new handles anymore.
///
/// See also:
///
///  * [Image](https://api.flutter.dev/flutter/widgets/Image-class.html), the class in the [widgets] library.
///  * [ImageDescriptor], which allows reading information about the image and
///    creating a codec to decode it.
///  * [instantiateImageCodec], a utility method that wraps [ImageDescriptor]. À¿€ÁÀÄÀÅÀÆ ÀÇÀÍ  ÀÔ
ÀÚ  ÀàÀæ   À¥/ÀÎ À¥À¦À¬À½À­ÀÙÀ	æ€ç/// A callback that is invoked to report an image creation.
///
/// It's preferred to use [MemoryAllocations] in flutter/foundation.dart
/// than to use [onCreate] directly because [MemoryAllocations]
/// allows multiple callbacks. À	óÀ€é/// A callback that is invoked to report the image disposal.
///
/// It's preferred to use [MemoryAllocations] in flutter/foundation.dart
/// than to use [onDispose] directly because [MemoryAllocations]
/// allows multiple callbacks. ÀÀ  À,SÀzA/// The number of image pixels along the image's horizontal axis. À„RÀĞ?/// The number of image pixels along the image's vertical axis. ÀÛÀà ÀìÀ•ÀÖ€¥/// Whether this reference to the underlying image is [dispose]d.
///
/// This only returns a valid value if asserts are enabled, and must not be
/// used otherwise.   À†ƒÀíÌ/// The color space that is used by the [Image]'s colors.
///
/// This value is a consequence of how the [Image] has been created.  For
/// example, loading a PNG that is in the Display P3 color space will result
/// in a [ColorSpace.extendedSRGB] image.
///
/// On rendering backends that don't support wide gamut colors (anything but
/// iOS impeller), wide gamut images will still report [ColorSpace.sRGB] if
/// rendering wide gamut colors isn't supported.   Àõƒ&Àõæ/// Release this handle's claim on the underlying Image. This handle is no
/// longer usable after this method is called.
///
/// Once all outstanding handles have been disposed, the underlying image will
/// be disposed as well.
///
/// In debug mode, [debugGetOpenHandleStackTraces] will return a list of
/// [StackTrace] objects from all open handles' creation points. This is
/// useful when trying to determine what parts of the program are keeping an
/// image resident in memory.   À¸ƒÊÀãÍ/// Converts the [Image] object into a byte array.
///
/// The [format] argument specifies the format in which the bytes will be
/// returned.
///
/// Using [ImageByteFormat.rawRgba] on an image in the color space
/// [ColorSpace.extendedSRGB] will result in the gamut being squished to fit
/// into the sRGB gamut, resulting in the loss of wide-gamut colors.
///
/// Returns a future that completes with the binary image data or an error
/// if encoding fails. Àï0À   ÀÀÀÀ¢Àå€°/// If asserts are enabled, returns the [StackTrace]s of each open handle from
/// [clone], in creation order.
///
/// If asserts are disabled, this method always returns null.   ÀÀŒàÀ%Š¢/// Creates a disposable handle to this image.
///
/// Holders of an [Image] must dispose of the image when they no longer need
/// to access it or draw it. However, once the underlying image is disposed,
/// it is no longer possible to use it. If a holder of an image needs to share
/// access to that image with another object or method, [clone] creates a
/// duplicate handle. The underlying image will only be disposed once all
/// outstanding handles are disposed. This allows for safe sharing of image
/// references while still disposing of the underlying resources when all
/// consumers are finished.
///
/// It is safe to pass an [Image] handle to another object or method if the
/// current holder no longer needs it.
///
/// To check whether two [Image] references are referring to the same
/// underlying image memory, use [isCloneOf] rather than the equality operator
/// or [identical].
///
/// The following example demonstrates valid usage.
///
/// ```dart
/// import 'dart:async';
/// import 'dart:typed_data';
/// import 'dart:ui';
///
/// Future<Image> _loadImage(int width, int height) {
///   final Completer<Image> completer = Completer<Image>();
///   decodeImageFromPixels(
///     Uint8List.fromList(List<int>.filled(width * height * 4, 0xFF)),
///     width,
///     height,
///     PixelFormat.rgba8888,
///     // Don't worry about disposing or cloning this image - responsibility
///     // is transferred to the caller, and that is safe since this method
///     // will not touch it again.
///     (Image image) => completer.complete(image),
///   );
///   return completer.future;
/// }
///
/// Future<void> main() async {
///   final Image image = await _loadImage(5, 5);
///   // Make sure to clone the image, because MyHolder might dispose it
///   // and we need to access it again.
///   final MyImageHolder holder = MyImageHolder(image.clone());
///   final MyImageHolder holder2 = MyImageHolder(image.clone());
///   // Now we dispose it because we won't need it again.
///   image.dispose();
///
///   final PictureRecorder recorder = PictureRecorder();
///   final Canvas canvas = Canvas(recorder);
///
///   holder.draw(canvas);
///   holder.dispose();
///
///   canvas.translate(50, 50);
///   holder2.draw(canvas);
///   holder2.dispose();
/// }
///
/// class MyImageHolder {
///   MyImageHolder(this.image);
///
///   final Image image;
///
///   void draw(Canvas canvas) {
///     canvas.drawImage(image, Offset.zero, Paint());
///   }
///
///   void dispose() => image.dispose();
/// }
/// ```
///
/// The returned object behaves identically to this image. Calling
/// [dispose] on it will only dispose the underlying native resources if it
/// is the last remaining handle.   À&¤‚›À)‚R/// Returns true if `other` is a [clone] of this and thus shares the same
/// underlying image memory, even if this or `other` is [dispose]d.
///
/// This method may return false for two images that were decoded from the
/// same underlying asset, if they are not sharing the same memory. For
/// example, if the same file is decoded using [instantiateImageCodec] twice,
/// or the same bytes are decoded using [decodeImageFromPixels] twice, there
/// will be two distinct [Image]s that render the same but do not share
/// underlying memory, and so will not be treated as clones of each other. À)À)   À)C3À)V   À)CÀ)D À)z‡6À)Ÿ  À*¤'À*ÆÀ*ÇÀ*È  À*¤À*¥À*«À*¼À*¬À-”À-™ À-¥À/å%À/ö À0À0	À0À0À0À*ÏfÀ+/   À*ÏÀ*ĞÀ*ÖÀ*ôÀ*İÀ*×À*åÀ*óÀ*æÀ*íÀ*òÀ*îÀ*õÀ+À*üÀ*öÀ*şÀ+À+À+À+9hÀ+š   À+9À+:À+@À+^À+GÀ+AÀ+OÀ+]À+PÀ+WÀ+\À+XÀ+_À+…À+fÀ+`À+hÀ+À+yÀ+À0bÀ0f   À0À0À0À04À0À0À0%À03À0&À0-À02À0.À05À0QÀ0<À06À0>À+¥À+·  À+Ã0À+Ô  À+ÜÀ+ëÀ+ìÀ,µ€ÛÀ-X9/// Returns an error message on failure, null on success. À-d
À-i  À-pÀ-‡  À,ñÀ,òÀ,øÀ-&À- À,ùÀ-À-%À-	À-À-À-À-À-À-'À-CÀ-.À-(À-0À-®dÀ-³    À/€ËÀ/Ök/// This can't be a leaf call because the native function calls Dart API
/// (Dart_SetNativeInstanceField).  À/†À/‡À/À/ªÀ/“À/À/›À/©À/œÀ/£À/¨À/¤À/«À/ÄÀ/²À/¬À/´À0u9À0ˆ   À0uÀ0vÀ)zÀ){À)À)’À)‚À1!‰_À7ò†Ê/// Information for a single frame of an animation.
///
/// To obtain an instance of the [FrameInfo] interface, see
/// [Codec.getNextFrame].
///
/// The recipient of an instance of this class is responsible for calling
/// [Image.dispose] on [image]. To share the image with other interested
/// parties, use [Image.clone]. If the [FrameInfo] object itself is passed to
/// another method or object, that method or object must assume it is
/// responsible for disposing the image when done, and the passer must not
/// access the [image] after that point.
///
/// For example, the following code sample is incorrect:
///
/// ```dart
/// /// BAD
/// Future<void> nextFrameRoutine(ui.Codec codec) async {
///   final ui.FrameInfo frameInfo = await codec.getNextFrame();
///   _cacheImage(frameInfo);
///   // ERROR - _cacheImage is now responsible for disposing the image, and
///   // the image may not be available any more for this drawing routine.
///   _drawImage(frameInfo);
///   // ERROR again - the previous methods might or might not have created
///   // handles to the image.
///   frameInfo.image.dispose();
/// }
/// ```
///
/// Correct usage is:
///
/// ```dart
/// /// GOOD
/// Future<void> nextFrameRoutine(ui.Codec codec) async {
///   final ui.FrameInfo frameInfo = await codec.getNextFrame();
///   _cacheImage(frameInfo.image.clone(), frameInfo.duration);
///   _drawImage(frameInfo.image.clone(), frameInfo.duration);
///   // This method is done with its handle, and has passed handles to its
///   // clients already.
///   // The image will live until those clients dispose of their handles, and
///   // this one must not be disposed since it will not be used again.
///   frameInfo.image.dispose();
/// }
/// ``` À8 À8ÏÀ8ĞÀ8Ñ€»/// This class is created by the engine, and should not be instantiated
/// or extended directly.
///
/// To obtain an instance of the [FrameInfo] interface, see
/// [Codec.getNextFrame].À8ÓÀ8â  À8ëÀ8ú   À9€™À9–{/// The duration this frame should be shown.
///
/// A zero duration indicates that the frame should be shown indefinitely. À9£€ÚÀ:x€¾/// The [Image] object for this frame.
///
/// This object must be disposed by the recipient of this frame info.
///
/// To share this image with other interested parties, use [Image.clone].    À:‚„>À;p€Ş/// A handle to an image codec.
///
/// This class is created by the engine, and should not be instantiated
/// or extended directly.
///
/// To obtain an instance of the [Codec] interface, see
/// [instantiateImageCodec].   À;z9À;¨#/// Number of frames in this image.   À;·€¦À<M€…/// Number of times to repeat the animation.
///
/// * 0 when the animation should be played once.
/// * -1 for infinity repetitions.   À<aaÀ=³//// Fetches the next animation frame.
///
/// Wraps back to the first frame after returning the last frame.
///
/// The returned future can complete with an error if the decoding has failed.
///
/// The caller of this method is responsible for disposing the
/// [FrameInfo.image] on the returned object.   À=Æ€øÀ>´€Ş/// Release the resources used by this object. The object is no longer usable
/// after this method is called.
///
/// This can't be a leaf call because the native function calls Dart API
/// (Dart_SetNativeInstanceField).    À>Â‡kÀ>ç  À?ï-À@À@À@  À?ïÀ?ğÀ?öÀ@À?÷À@ À@%  À@øÀ@ı  À@;DÀ@O   À@;À@<À@ƒqÀ@è   À@ƒÀ@„À@ŠÀ@¨À@‘À@‹À@™À@§À@šÀ@¡À@¦À@¢À@©À@ÓÀ@°À@ªÀ@²À@ÍÀ@ÇÀ@ÏÀASÀA,   ÀAÀAÀAo{ÀAÙ   ÀAoÀApÀAvÀA”ÀA}ÀAwÀA…ÀA“ÀA†ÀAÀA’ÀAÀA•ÀAÄÀAœÀA–ÀAÀA¾ÀA¸ÀAÀÀAî‚õÀB   ÀAîÀAïÀDç€ÚÀE…9/// Returns an error message on failure, null on success. ÀE“,ÀE¸  ÀE#ÀE$ÀE*ÀEQÀE2ÀE+ÀE:ÀEPÀE;ÀEBÀEGÀECÀEJÀERÀEpÀEYÀESÀE[ÀEÅfÀF!   ÀEÅÀEÆÀEÑÀEÒÀEØÀEõÀEŞÀEÙÀEæÀEôÀEçÀEîÀEóÀEïÀEöÀFÀEıÀE÷ÀEÿÀ>ÂÀ>ÃÀ>ÉÀ>ÚÀ>ÊÀet†jÀf‡/// A specification of the size to which an image should be decoded.
///
/// See also:
///
///  * [TargetImageSizeCallback], a callback that returns instances of this
///    class when consulted by image decoding methods such as
///    [instantiateImageCodecWithSize]. Àf›# Àg:ÀgI€/// Creates a new instance of this class.
///
/// The `width` and `height` may both be null, but if they're non-null, they
/// must be positive.ÀgK
ÀgQ  ÀgWÀg]  ÀgmÀgsÀgÀg‚ÀgzÀgtÀg}Àg‹Àg…ÀgÀg™ÀgŸÀg¼Àg¯Àg§Àg ÀgªÀg¹Àg²Àg»ÀgÂåÀi¢Â/// The width into which to load the image.
///
/// If this is non-null, the image will be decoded into the specified width.
/// If this is null and [height] is also null, the image will be decoded into
/// its intrinsic size. If this is null and [height] is non-null, the image
/// will be decoded into a width that maintains its intrinsic aspect ratio
/// while respecting the [height] value.
///
/// If this value is non-null, it must be positive. Ài¬æÀkŒÂ/// The height into which to load the image.
///
/// If this is non-null, the image will be decoded into the specified height.
/// If this is null and [width] is also null, the image will be decoded into
/// its intrinsic size. If this is null and [width] is non-null, the image
/// will be decoded into a height that maintains its intrinsic aspect ratio
/// while respecting the [width] value.
///
/// If this value is non-null, it must be positive.  Àk—EÀkª   Àk—Àk˜ À…ƒ˜À…áP/// A handle for the framework to hold and retain an engine layer across frames.    À…ñƒ&À‰‚ø/// Release the resources used by this object. The object is no longer usable
/// after this method is called.
///
/// EngineLayers indirectly retain platform specific graphics resources. Some
/// of these resources, such as images, may be memory intensive. It is
/// important to dispose of EngineLayer objects that will no longer be used as
/// soon as possible to avoid retaining these resources until the next
/// garbage collection.
///
/// Once this EngineLayer is disposed, it is no longer eligible for use as a
/// retained layer, and must not be passed as an `oldLayer` to any of the
/// [SceneBuilder] methods which accept that parameter.
///
/// This can't be a leaf call because the native function calls Dart API
/// (Dart_SetNativeInstanceField).    À‰À‰@  À‰€™ÀŠ#ÀŠ$ÀŠ%a/// This class is created by the engine, and should not be instantiated
/// or extended directly. À‰õÀ‰öÀ‰üÀŠÀ‰ı  ÀŠ,lÀŠ   ÀŠ,ÀŠ-ÀŠ8ÀŠ9ÀŠ?ÀŠ\ÀŠEÀŠ@ÀŠMÀŠ[ÀŠNÀŠUÀŠZÀŠVÀŠ]ÀŠ|ÀŠdÀŠ^ÀŠfÀ‰À‰À‰"À‰3À‰#ÀŠœ¸XÀd‚¸/// A complex, one-dimensional subset of a plane.
///
/// A path consists of a number of sub-paths, and a _current point_.
///
/// Sub-paths consist of segments of various types, such as lines,
/// arcs, or beziers. Sub-paths can be open or closed, and can
/// self-intersect.
///
/// Closed sub-paths enclose a (possibly discontiguous) region of the
/// plane based on the current [fillType].
///
/// The _current point_ is initially at the origin. After each
/// operation adding a segment to a sub-path, the current point is
/// updated to the end of that segment.
///
/// Paths can be drawn on canvases using [Canvas.drawPath], and can
/// used to create clip regions using [Canvas.clipPath]. Àm ÀuÀy   ÀiÀdÀeÀi€Á/// Creates a copy of another [Path].
///
/// This copy is fast and does not require additional memory unless either
/// the `source` path or the path returned by this constructor are modified.ÀjÀp    Àû€£À•€‚/// Determines how the interior of this path is calculated.
///
/// Defaults to the non-zero winding rule, [PathFillType.nonZero].   À¡!À¥  À®À¼   ÀÆUÀ 2/// Starts a new sub-path at the given coordinate. ÀÀ  ÀÀ   ÀrÀlE/// Starts a new sub-path at the given offset from the current point. À{	Àƒ  À†	À   À•tÀîO/// Adds a straight line segment from the current point to the given
/// point. ÀõÀı  ÀÿÀ‘   À‘€£À‘‹t/// Adds a straight line segment from the current point to the point
/// at the given offset from the current point. À‘š	À‘¢  À‘¥	À‘­   À‘´ÁÀ“7q/// Adds a quadratic bezier segment that curves from the current
/// point to the given point (x2,y2), using the control point
/// (x1,y1).
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_quadratic_to.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_quadratic_to_dark.png#gh-dark-mode-only) À“I	À“Q  À“T	À“\  À“_	À“g  À“j	À“r   À“y'À”Z€Ó/// Adds a quadratic bezier segment that curves from the current
/// point to the point at the offset (x2,y2) from the current point,
/// using the control point at the offset (x1,y1) from the current
/// point. À”t	À”|  À”	À”‡  À”Š	À”’  À”•	À”   À”¤ÎÀ–(r/// Adds a cubic bezier segment that curves from the current point
/// to the given point (x3,y3), using the control points (x1,y1) and
/// (x2,y2).
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_cubic_to.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_cubic_to_dark.png#gh-dark-mode-only) À–0	À–8  À–;	À–C  À–F	À–N  À–Q	À–Y  À–\	À–d  À–g	À–o   À–v=À—a€İ/// Adds a cubic bezier segment that curves from the current point
/// to the point at the offset (x3,y3) from the current point, using
/// the control points at the offsets (x1,y1) and (x2,y2) from the
/// current point. À—q	À—y  À—|	À—„  À—‡	À—  À—’	À—š  À—	À—¥  À—¨	À—°   À—·‚bÀ™Û‚/// Adds a bezier segment that curves from the current point to the
/// given point (x2,y2), using the control points (x1,y1) and the
/// weight w. If the weight is greater than 1, then the curve is a
/// hyperbola; if the weight equals 1, it's a parabola; and if it is
/// less than 1, it is an ellipse.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_conic_to.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_conic_to_dark.png#gh-dark-mode-only) À™ã	À™ë  À™î	À™ö  À™ù	Àš  Àš	Àš  ÀšÀš   ÀšÏÀ›¦w/// Adds a bezier segment that curves from the current point to the
/// point at the offset (x2,y2) from the current point, using the
/// control point at the offset (x1,y1) from the current point and
/// the weight w. If the weight is greater than 1, then the curve is
/// a hyperbola; if the weight equals 1, it's a parabola; and if it
/// is less than 1, it is an ellipse. À›¶	À›¾  À›Á	À›É  À›Ì	À›Ô  À›×	À›ß  À›âÀ›ê   À›ğƒrÀŸƒ/// If the `forceMoveTo` argument is false, adds a straight line
/// segment and an arc segment.
///
/// If the `forceMoveTo` argument is true, starts a new sub-path
/// consisting of an arc segment.
///
/// In either case, the arc segment consists of the arc that follows
/// the edge of the oval bounded by the given rectangle, from
/// startAngle radians around the oval up to startAngle + sweepAngle
/// radians around the oval, with zero radians being the point on
/// the right hand side of the oval that crosses the horizontal line
/// that intersects the center of the rectangle and with positive
/// angles going clockwise around the oval.
///
/// The line segment added if `forceMoveTo` is false starts at the
/// current point and ends at the start of the arc. ÀŸ	ÀŸ%  ÀŸ*ÀŸ2  ÀŸ=ÀŸE  ÀŸPÀŸV   ÀŸfƒ!À¡ô‚p/// Appends up to four conic curves weighted to describe an oval of `radius`
/// and rotated by `rotation` (measured in degrees and clockwise).
///
/// The first curve begins from the last point in the path and the last ends
/// at `arcEnd`. The curves follow a path in a direction determined by
/// `clockwise` and `largeArc` in such a way that the sweep angle
/// is always less than 360 degrees.
///
/// A simple line is appended if either radii are zero or the last
/// point in the path is `arcEnd`. The radii are scaled to fit the last path
/// point if both are greater than zero but too small to describe an arc.
/// À¡ÿÀ¢  À¢À¢  À¢5À¢=  À¢PÀ¢V  À¢kÀ¢q  À¢$À¢*À¢+À¢GÀ¢`À¢|À¢‹ƒ£À¥‰‚Ü/// Appends up to four conic curves weighted to describe an oval of `radius`
/// and rotated by `rotation` (measured in degrees and clockwise).
///
/// The last path point is described by (px, py).
///
/// The first curve begins from the last point in the path and the last ends
/// at `arcEndDelta.dx + px` and `arcEndDelta.dy + py`. The curves follow a
/// path in a direction determined by `clockwise` and `largeArc`
/// in such a way that the sweep angle is always less than 360 degrees.
///
/// A simple line is appended if either radii are zero, or, both
/// `arcEndDelta.dx` and `arcEndDelta.dy` are zero. The radii are scaled to
/// fit the last path point if both are greater than zero but too small to
/// describe an arc. À¥¡À¥©  À¥»À¥Ã  À¥ÜÀ¥ä  À¥÷À¥ı  À¦À¦  À¥ËÀ¥ÑÀ¥ÒÀ¥îÀ¦À¦#À¦2vÀ¦•Y/// Adds a new sub-path that consists of four lines that outline the
/// given rectangle. À¦	À¦£   À¦¬.À§Ç/// Adds a new sub-path that consists of a curve that forms the
/// ellipse that fills the given rectangle.
///
/// To add a circle, pass an appropriate rectangle as `oval`. [Rect.fromCircle]
/// can be used to easily describe the circle's center [Offset] and radius. À§Ï	À§Õ   À§ŞƒèÀ«ƒ/// Adds a new sub-path with one arc segment that consists of the arc
/// that follows the edge of the oval bounded by the given
/// rectangle, from startAngle radians around the oval up to
/// startAngle + sweepAngle radians around the oval, with zero
/// radians being the point on the right hand side of the oval that
/// crosses the horizontal line that intersects the center of the
/// rectangle and with positive angles going clockwise around the
/// oval.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_add_arc.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_add_arc_dark.png#gh-dark-mode-only)
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_add_arc_ccw.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/path_add_arc_ccw_dark.png#gh-dark-mode-only) À«•	À«›  À« À«¨  À«³À«»   À«ÊXÀ¬ö/// Adds a new sub-path with a sequence of line segments that connect the given
/// points.
///
/// If `close` is true, a final line segment will be added that connects the
/// last point to the first point.
///
/// The `points` argument is interpreted as offsets from the origin. À­À­  À­
À­   À­&€°À­À€/// Adds a new sub-path that consists of the straight lines and
/// curves needed to form the rounded rectangle described by the
/// argument. À­ÉÀ­Ğ   À­ÚQÀ®ñ/// Adds the sub-paths of `path`, offset by `offset`, to this path.
///
/// If `matrix4` is specified, the path will be transformed by this matrix
/// after the matrix is translated by the given offset. The matrix is a 4x4
/// matrix stored in column major order. À®ù	À®ÿ  À¯À¯  À¯À¯"   À¯/×À°Å‚/// Adds the sub-paths of `path`, offset by `offset`, to this path.
/// The current sub-path is extended with the first sub-path
/// of `path`, connecting them with a lineTo if necessary.
///
/// If `matrix4` is specified, the path will be transformed by this matrix
/// after the matrix is translated by the given `offset`.  The matrix is a 4x4
/// matrix stored in column major order. À°Ô	À°Ú  À°ßÀ°ç  À°ïÀ°ı   À±
€“À±•€/// Closes the last sub-path, as if a straight line had been drawn
/// from the current point to the first point of the sub-path.   À±¡€±À²J€/// Clears the [Path] object of all sub-paths, returning it to the
/// same state it had when it was created. The _current point_ is
/// reset to the origin.   À²VqÀ³°F/// Tests to see if the given point is within the path. (That is, whether the
/// point would be in the visible portion of the path if the path was used
/// with [Canvas.clipPath].)
///
/// The `point` argument is interpreted as an offset from the origin.
///
/// Returns true if the point is in the path, and false otherwise. À³¹À³Á   À³Ë€‰À´?j/// Returns a copy of the path with all the segments of every
/// sub-path translated by the given offset. À´EÀ´M   À´X€”À´Ík/// Returns a copy of the path with all the segments of every
/// sub-path transformed by the given matrix. À´×À´ä   À´ğƒ£À¸‡ƒ0/// Computes the bounding rectangle for this path.
///
/// A path containing only axis-aligned points on the same straight line will
/// have no area, and therefore `Rect.isEmpty` will return true for such a
/// path. Consider checking `rect.width + rect.height > 0.0` instead, or
/// using the [computeMetrics] API to check the path length.
///
/// For many more elaborate paths, the bounds may be inaccurate.  For example,
/// when a path contains a circle, the points used to compute the bounds are
/// the circle's implied control points, which form a square around the circle;
/// if the circle has a transformation applied using [transform] then that
/// square is rotated, and the (axis-aligned, non-rotated) bounding box
/// therefore ends up grossly overestimating the actual area covered by the
/// circle.   À¸—‚”À¹à0/// Combines the two paths according to the manner specified by the given
/// `operation`.
///
/// The resulting path will be constructed from non-overlapping contours. The
/// curve order is reduced where possible so that cubics may be turned into
/// quadratics, and quadratics maybe turned into lines. À¹èÀ¹÷  Àº
Àº  Àº
Àº   À»/‡ÃÀÂÇ‡M/// Creates a [PathMetrics] object for this path, which can describe various
/// properties about the contours of the path.
///
/// A [Path] is made up of zero or more contours. A contour is made up of
/// connected curves and segments, created via methods like [lineTo],
/// [cubicTo], [arcTo], [quadraticBezierTo], their relative counterparts, as
/// well as the add* methods such as [addRect]. Creating a new [Path] starts
/// a new contour once it has any drawing instructions, and another new
/// contour is started for each [moveTo] instruction.
///
/// A [PathMetric] object describes properties of an individual contour,
/// such as its length, whether it is closed, what the tangent vector of a
/// particular offset along the path is. It also provides a method for
/// creating sub-paths: [PathMetric.extractPath].
///
/// Calculating [PathMetric] objects is not trivial. The [PathMetrics] object
/// returned by this method is a lazy [Iterable], meaning it only performs
/// calculations when the iterator is moved to the next [PathMetric]. Callers
/// that wish to memoize this iterable can easily do so by using
/// [Iterable.toList] on the result of this method. In particular, callers
/// looking for information about how many contours are in the path should
/// either store the result of `path.computeMetrics().length`, or should use
/// `path.computeMetrics().toList()` so they can repeatedly check the length,
/// since calling `Iterable.length` causes traversal of the entire iterable.
///
/// In particular, callers should be aware that [PathMetrics.length] is the
/// number of contours, **not the length of the path**. To get the length of
/// a contour in a path, use [PathMetric.length].
///
/// If `forceClosed` is set to true, the contours of the path will be measured
/// as if they had been closed, even if they were not explicitly closed. ÀÂ×ÀÂİ  ÀÂê ÀÂö¥{ÀÃ  ÀÃ\e ÀÃ ÀÃ«%/// Create a new empty [Path] object. ÀÃ„ÀÃ…ÀÃ‹ÀÃœÀÃŒÀÃÅ€£ÀÄcÀÄdÀÄe€/// Avoids creating a new native backing for the path for methods that will
/// create it later, such as [Path.from], [shift] and [transform].   ÀÅ4MÀÅQ   ÀÅ4ÀÅ5ÀÅ„JÀÅ”  ÀÅÀÅ«  ÀÅ„ÀÅ…0ÀÄlVÀÄ³   ÀÄlÀÄmÀÄsÀÄ‰ÀÄyÀÄtÀÄÀÄˆÀÄ‚ÀÄŠÀÄ¡ÀÄ‘ÀÄ‹ÀÄ“ÀÄÆjÀÅ  ÀÅ"ÀÅ(  ÀÄÆÀÄÇÀÄÍÀÄòÀÄÓÀÄÎÀÄÛÀÄñÀÄÜÀÄãÀÄèÀÄäÀÄëÀÄóÀÅ	ÀÄúÀÄôÀÄüÀÅÒpÀÆ3   ÀÅÒÀÅÓÀÅÙÀÅ÷ÀÅàÀÅÚÀÅèÀÅöÀÅéÀÅğÀÅõÀÅñÀÅøÀÆ"ÀÅÿÀÅùÀÆÀÆÀÆÀÆÀÆF€ƒÀÆ®  ÀÆ»ÀÆÀ  ÀÆFÀÆGÀÆMÀÆqÀÆSÀÆNÀÆ[ÀÆpÀÆ\ÀÆcÀÆhÀÆdÀÆkÀÆrÀÆœÀÆyÀÆsÀÆ{ÀÆ–ÀÆÀÆ˜ÀÆÍ€“ÀÇE  ÀÇLÀÇT  ÀÇVÀÇ^  ÀÆÍÀÆÎÀÆÙÀÆÚÀÆàÀÇÀÆæÀÆáÀÆîÀÇÀÆïÀÆöÀÆûÀÆ÷ÀÆşÀÇÀÇÀÇ3ÀÇÀÇÀÇÀÇ-ÀÇ'ÀÇ/ÀÇd€¥ÀÇä  ÀÇó	ÀÇû  ÀÇş	ÀÈ  ÀÇdÀÇeÀÇpÀÇqÀÇwÀÇ¤ÀÇ}ÀÇxÀÇ…ÀÇ£ÀÇ†ÀÇÀÇ’ÀÇÀÇ•ÀÇÀÇ¥ÀÇÒÀÇ¬ÀÇ¦ÀÇ®ÀÇÌÀÇÆÀÇÎÀÈ€“ÀÈ…  ÀÈŒÀÈ”  ÀÈ–ÀÈ  ÀÈÀÈÀÈÀÈÀÈ ÀÈMÀÈ&ÀÈ!ÀÈ.ÀÈLÀÈ/ÀÈ6ÀÈ;ÀÈ7ÀÈ>ÀÈFÀÈNÀÈsÀÈUÀÈOÀÈWÀÈmÀÈgÀÈoÀÈ¤€¥ÀÉ$  ÀÉ3	ÀÉ;  ÀÉ>	ÀÉF  ÀÈ¤ÀÈ¥ÀÈ°ÀÈ±ÀÈ·ÀÈäÀÈ½ÀÈ¸ÀÈÅÀÈãÀÈÆÀÈÍÀÈÒÀÈÎÀÈÕÀÈİÀÈåÀÉÀÈìÀÈæÀÈîÀÉÀÉÀÉÀÉM€ÑÀÉà  ÀÉò	ÀÉú  ÀÉı	ÀÊ  ÀÊ	ÀÊ  ÀÊ	ÀÊ  ÀÉMÀÉNÀÉYÀÉZÀÉ`ÀÉÀÉfÀÉaÀÉnÀÉœÀÉoÀÉvÀÉ{ÀÉwÀÉ~ÀÉ†ÀÉÀÉ–ÀÉÀÉÎÀÉ¥ÀÉŸÀÉ§ÀÉÈÀÉÂÀÉÊÀÊ"€èÀÊ½  ÀÊŞ	ÀÊæ  ÀÊé	ÀÊñ  ÀÊô	ÀÊü  ÀÊÿ	ÀË  ÀÊ"ÀÊ#ÀÊ.ÀÊ/ÀÊ5ÀÊrÀÊ;ÀÊ6ÀÊCÀÊqÀÊDÀÊKÀÊPÀÊLÀÊSÀÊ[ÀÊcÀÊkÀÊsÀÊ«ÀÊzÀÊtÀÊ|ÀÊ¥ÀÊŸÀÊ§ÀË€ãÀË§  ÀË¯	ÀË·  ÀËº	ÀËÂ  ÀËÅ	ÀËÍ  ÀËĞ	ÀËØ  ÀËÛ	ÀËã  ÀËæ	ÀËî  ÀËÀËÀËÀËÀË!ÀËnÀË'ÀË"ÀË/ÀËmÀË0ÀË7ÀË<ÀË8ÀË?ÀËGÀËOÀËWÀË_ÀËgÀËoÀË•ÀËvÀËpÀËxÀËÀË‰ÀË‘ÀËõ€óÀÌ–  ÀÌ¦	ÀÌ®  ÀÌ±	ÀÌ¹  ÀÌ¼	ÀÌÄ  ÀÌÇ	ÀÌÏ  ÀÌÒ	ÀÌÚ  ÀÌİ	ÀÌå  ÀËõÀËöÀÌÀÌÀÌÀÌUÀÌÀÌ	ÀÌÀÌTÀÌÀÌÀÌ#ÀÌÀÌ&ÀÌ.ÀÌ6ÀÌ>ÀÌFÀÌNÀÌVÀÌ„ÀÌ]ÀÌWÀÌ_ÀÌ~ÀÌxÀÌ€ÀÌì€ÏÀÍ}  ÀÍ…	ÀÍ  ÀÍ	ÀÍ˜  ÀÍ›	ÀÍ£  ÀÍ¦	ÀÍ®  ÀÍ±ÀÍ¹  ÀÌìÀÌíÀÌøÀÌùÀÌÿÀÍDÀÍÀÍ ÀÍÀÍCÀÍÀÍÀÍÀÍÀÍÀÍ%ÀÍ-ÀÍ5ÀÍ=ÀÍEÀÍkÀÍLÀÍFÀÍNÀÍeÀÍ_ÀÍgÀÍ¿€ßÀÎX  ÀÎh	ÀÎp  ÀÎs	ÀÎ{  ÀÎ~	ÀÎ†  ÀÎ‰	ÀÎ‘  ÀÎ”ÀÎœ  ÀÍ¿ÀÍÀÀÍËÀÍÌÀÍÒÀÎÀÍØÀÍÓÀÍàÀÎÀÍáÀÍèÀÍíÀÍéÀÍğÀÍøÀÎ ÀÎÀÎÀÎÀÎFÀÎÀÎÀÎ!ÀÎ@ÀÎ:ÀÎBÀÎ¢€ŞÀÎ³  ÀÎ¹	ÀÎ¿  ÀÎÄÀÎÌ  ÀÎ×ÀÎß  ÀÎêÀÎğ  ÀÎ¢ÀÎ£ÀÏ„ÀĞ  ÀĞÀĞ$  ÀĞ)
ÀĞ1  ÀĞ5ÀĞ=  ÀĞCÀĞK  ÀĞRÀĞZ  ÀĞeÀĞm  ÀĞxÀĞ~  ÀÏ„ÀÏ…ÀÏ‹ÀÏŞÀÏ‘ÀÏŒÀÏ™ÀÏİÀÏšÀÏ¡ÀÏ¦ÀÏ¢ÀÏ©ÀÏ±ÀÏ¹ÀÏÁÀÏÉÀÏÑÀÏÙÀÏßÀĞÀÏæÀÏàÀÏèÀÏıÀÏ÷ÀÏÿÀĞKÀĞŸ  ÀĞªÀĞ²  ÀĞ¿ÀĞÇ  ÀĞàÀĞè  ÀĞûÀÑ  ÀÑÀÑ  ÀĞÀĞÀĞÏÀĞÕÀĞÖÀĞòÀÑÀÑ'ÀÑİÀÒq  ÀÒ}ÀÒ…  ÀÒÀÒ•  ÀÒÀÒ¥  ÀÒ­ÀÒµ  ÀÒ½ÀÒÅ  ÀÒÎÀÒÔ  ÀÒİÀÒã  ÀÑİÀÑŞÀÑäÀÒ5ÀÑêÀÑåÀÑòÀÒ4ÀÑóÀÑúÀÑÿÀÑûÀÒÀÒ
ÀÒÀÒÀÒ"ÀÒ*ÀÒ0ÀÒ6ÀÒ_ÀÒ=ÀÒ7ÀÒ?ÀÒYÀÒSÀÒ[ÀÒñtÀÓ  ÀÓÀÓ"  ÀÓ4ÀÓ<  ÀÓUÀÓ]  ÀÓpÀÓv  ÀÓ‹ÀÓ‘  ÀÒñÀÒòÀÓDÀÓJÀÓKÀÓgÀÓ€ÀÓœÀÔiKÀÕ  ÀÕ ÀÕ(  ÀÕ6ÀÕ>  ÀÕLÀÕT  ÀÕbÀÕj  ÀÕxÀÕ€  ÀÕÀÕ•  ÀÕ¤ÀÕª  ÀÔiÀÔjÀÔpÀÔÁÀÔvÀÔqÀÔ~ÀÔÀÀÔÀÔ†ÀÔ‹ÀÔ‡ÀÔÀÔ–ÀÔÀÔ¦ÀÔ®ÀÔ¶ÀÔ¼ÀÔÂÀÔóÀÔÉÀÔÃÀÔËÀÔíÀÔçÀÔïÀÕ¸€…ÀÕÉ  ÀÕÑ	ÀÕ×  ÀÕ¸ÀÕ¹ÀÖA€¼ÀÖ¾  ÀÖÇÀÖÏ  ÀÖÔ
ÀÖÜ  ÀÖàÀÖè  ÀÖîÀÖö  ÀÖAÀÖBÀÖHÀÖ…ÀÖNÀÖIÀÖVÀÖ„ÀÖWÀÖ^ÀÖcÀÖ_ÀÖfÀÖnÀÖvÀÖ~ÀÖ†ÀÖ¬ÀÖÀÖ‡ÀÖÀÖ¦ÀÖ ÀÖ¨À×€…À×  À×	À×   À×À×À×Š€¼ÀØ  ÀØÀØ  ÀØ
ÀØ%  ÀØ)ÀØ1  ÀØ7ÀØ?  À×ŠÀ×‹À×‘À×ÎÀ×—À×’À×ŸÀ×ÍÀ× À×§À×¬À×¨À×¯À×·À×¿À×ÇÀ×ÏÀ×õÀ×ÖÀ×ĞÀ×ØÀ×ïÀ×éÀ×ñÀØJ€ÁÀØ[  ÀØb	ÀØh  ÀØmÀØu  ÀØ€ÀØˆ  ÀØJÀØKÀÙ€ğÀÙ›  ÀÙ£ÀÙ«  ÀÙ°
ÀÙ¸  ÀÙ¼ÀÙÄ  ÀÙÊÀÙÒ  ÀÙÙÀÙá  ÀÙìÀÙô  ÀÙÀÙÀÙÀÙcÀÙÀÙÀÙ$ÀÙbÀÙ%ÀÙ,ÀÙ1ÀÙ-ÀÙ4ÀÙ<ÀÙDÀÙLÀÙTÀÙ\ÀÙdÀÙ‰ÀÙkÀÙeÀÙmÀÙƒÀÙ}ÀÙ…ÀÚtÀÚ  ÀÚÀÚ-  ÀÚ4
ÀÚ:  ÀÚÀÚÀÚ{€ŒÀÚÛ  ÀÚçÀÚô  ÀÚû
ÀÛ  ÀÚ{ÀÚ|ÀÚ‚ÀÚ­ÀÚˆÀÚƒÀÚÀÚ¬ÀÚ‘ÀÚ˜ÀÚÀÚ™ÀÚ ÀÚ¨ÀÚ®ÀÚÉÀÚµÀÚ¯ÀÚ·ÀÛrÀÛ  ÀÛ%ÀÛ,  ÀÛÀÛÀÛuÀÛÙ  ÀÛãÀÛğ  ÀÛÀÛ‚ÀÛˆÀÛ­ÀÛÀÛ‰ÀÛ–ÀÛ¬ÀÛ—ÀÛÀÛ£ÀÛŸÀÛ¦ÀÛ®ÀÛÇÀÛµÀÛ¯ÀÛ·ÀÛúSÀÜ  ÀÜ	ÀÜ  ÀÜÀÜ&  ÀÜ.ÀÜ<  ÀÛúÀÛûÀİQ€ŸÀİ¿  ÀİÈÀİÕ  ÀİÚ	Àİâ  Àİå	Àİí  ÀİQÀİRÀİXÀİ”Àİ^ÀİYÀİfÀİ“ÀİgÀİnÀİsÀİoÀİvÀİ}Àİ‚Àİ~Àİ…ÀİÀİ•Àİ­ÀİœÀİ–ÀİÀİô€ÏÀŞt  ÀŞ‡ÀŞ”  ÀŞ™	ÀŞ¡  ÀŞ¤	ÀŞ¬  ÀŞ¯ÀŞ¼  ÀİôÀİõÀİûÀŞ?ÀŞÀİüÀŞ	ÀŞ>ÀŞ
ÀŞÀŞÀŞÀŞÀŞ ÀŞ%ÀŞ!ÀŞ(ÀŞ0ÀŞ8ÀŞ@ÀŞbÀŞGÀŞAÀŞIÀŞÇgÀŞØ  ÀŞç	ÀŞí  ÀŞòÀŞú  ÀßÀß  ÀŞÇÀŞÈÀà2€­Àà§  Àà·ÀàÄ  ÀàÉ	ÀàÑ  ÀàÔ	ÀàÜ  Àà2Àà3Àà9ÀàuÀà?Àà:ÀàGÀàtÀàHÀàOÀàTÀàPÀàWÀà^ÀàcÀà_ÀàfÀànÀàvÀà•Àà}ÀàwÀàÀàã€ÛÀái  Àá‚Àá  Àá”	Àáœ  ÀáŸ	Àá§  ÀáªÀá·  ÀàãÀàäÀàêÀá.ÀàğÀàëÀàøÀá-ÀàùÀá ÀáÀáÀáÀáÀáÀáÀáÀáÀá'Àá/ÀáWÀá6Àá0Àá8ÀáÂoÀâ)   ÀáÂÀáÃÀáÎÀáÏÀáÕÀáòÀáÛÀáÖÀáãÀáñÀáäÀáëÀáğÀáìÀáóÀâÀáúÀáôÀáüÀâÀâÀâÀâ5oÀâœ   Àâ5Àâ6ÀâAÀâBÀâHÀâeÀâNÀâIÀâVÀâdÀâWÀâ^ÀâcÀâ_ÀâfÀâŠÀâmÀâgÀâoÀâ„Àâ~Àâ†Àâ¨zÀâ¹  ÀâÂÀâÊ  Àâ¨Àâ©Àã&€ŒÀã”  ÀãÀã¦  Àã¨Àã°  Àã&Àã'Àã-ÀãZÀã3Àã.Àã;ÀãYÀã<ÀãCÀãHÀãDÀãKÀãSÀã[Àã‚ÀãbÀã\ÀãdÀã|ÀãvÀã~Àã¶€¶ÀãÇ  ÀãÍÀãÕ  Àã¶Àã·Àäp€ÀäÕ  ÀäÜÀäâ  Àäê	Àäò  Àäõ	Àäı  ÀäpÀäqÀäwÀä¬Àä}ÀäxÀä…Àä«Àä†ÀäÀä’ÀäÀä•ÀäÀä¥Àä­ÀäÃÀä´Àä®Àä¶Àå€¹Àå  ÀåÀå,  ÀåÀåÀåÁ€Àæ"  Àæ-Àæ3  Àæ;ÀæH  ÀåÁÀåÂÀåÈÀåõÀåÎÀåÉÀåÖÀåôÀå×ÀåŞÀåãÀåßÀåæÀåîÀåöÀæÀåıÀå÷ÀåÿÀæT€‹Àæe   ÀæTÀæUÀæãgÀç=   ÀæãÀæäÀæêÀç	ÀæòÀæëÀæúÀçÀæûÀçÀçÀçÀç
Àç$ÀçÀçÀçÀçN€¨Àç½  ÀçÁÀçÎ  ÀçÔÀçá  ÀççÀçì  ÀçNÀçOÀçUÀç—Àç[ÀçVÀçcÀç–ÀçdÀçkÀçpÀçlÀçsÀçzÀçÀç{Àç‚Àç‰ÀçÀçŠÀç‘Àç˜Àç«ÀçŸÀç™Àç¡ÀçúuÀè  Àè"Àè(  ÀçúÀçûÀè5ÀÂöÀÂ÷ÀÂıÀÃÀÂşÀès‡DÀé+€±/// The geometric description of a tangent: the angle at a point.
///
/// See also:
///  * [PathMetric.getTangentForOffset], which returns the tangent of an offset along a path. Àé7€‡ ÀéšÀé¡V/// Creates a [Tangent] with the given values.
///
/// The arguments must not be null.Àé¢Àé¨  Àé±Àé·   ÀéÂRÀêÀêÀê§€Ã/// Creates a [Tangent] based on the angle rather than the vector.
///
/// The [vector] is computed to be the unit vector at the given angle, interpreted
/// as clockwise radians from the x axis.Àê¨Àê°  Àê¹ÀêÁ   Àë€ÑÀëá€³/// Position of the tangent.
///
/// When used with [PathMetric.getTangentForOffset], this represents the precise
/// position that the given offset along the path corresponds to. ÀëîÀìí€ç/// The vector of the curve at [position].
///
/// When used with [PathMetric.getTangentForOffset], this is the vector of the
/// curve that is at the given offset along the path (i.e. the direction of the
/// curve at [position]). Àìø‚½ÀïŠ‚+/// The direction of the curve at [position].
///
/// When used with [PathMetric.getTangentForOffset], this is the angle of the
/// curve that is the given offset along the path (i.e. the direction of the
/// curve at [position]).
///
/// This value is in radians, with 0.0 meaning pointing along the x axis in
/// the positive x-axis direction, positive numbers pointing downward toward
/// the negative y-axis, i.e. in a clockwise direction, and negative numbers
/// pointing upward toward the positive y-axis, i.e. in a counter-clockwise
/// direction.     Àï¹„#Àò´‚ô/// An iterable collection of [PathMetric] objects describing a [Path].
///
/// A [PathMetrics] object is created by using the [Path.computeMetrics] method,
/// and represents the path as it stood at the time of the call. Subsequent
/// modifications of the path do not affect the [PathMetrics] object.
///
/// Each path metric corresponds to a segment, or contour, of a path.
///
/// For example, a path consisting of a [Path.lineTo], a [Path.moveTo], and
/// another [Path.lineTo] will contain two contours and thus be represented by
/// two [PathMetric] objects.
///
/// This iterable does not memoize. Callers who need to traverse the list
/// multiple times, or who need to randomly access elements of the list, should
/// use [toList] on this object. Àòğ€‚ÀòûÀòüÀòı Àòş	Àó  Àó	Àó  Àó+Àó!Àó-Àó?Àó@ÀóAÀópÀóBÀóNÀóoÀóTÀóOÀóWÀódÀóv$Àó‘  ÀóŸ;ÀóÄ   ÀóŸÀó   ÀóŞƒÂÀôMh/// Used by [PathMetrics] to track iteration from one segment of a path to the
/// next for measurement. Àô„(Àô–Àô—Àô˜ Àô™ÀôŸ   Àô°Àô¼  ÀôËÀôŞ  ÀôïğÀõ
   ÀôïÀôğÀöã€»Àöô   ÀöãÀöä À÷¢kÀú‰‚à/// Utilities for measuring a [Path] and extracting sub-paths.
///
/// Iterate over the object returned by [Path.computeMetrics] to obtain
/// [PathMetric] objects. Callers that want to randomly access elements or
/// iterate multiple times should use `path.computeMetrics().toList()`, since
/// [PathMetrics] does not memoize.
///
/// Once created, the metrics are only valid for the path as it was specified
/// when [Path.computeMetrics] was called. If additional contours are added or
/// any contours are updated, the metrics need to be recomputed. Previously
/// created metrics will still refer to a snapshot of the path at the time they
/// were computed, rather than to the actual metrics for the new mutations to
/// the path. Àú˜€ÎÀú¢Àú£Àú¤ Àú¥Àú«  ÀúÁÀúºÀúÃÀúËÀúÌÀúÒÀúïÀúÓÀúÛÀúÜÀûÀúøÀûÀûÀûÀûÀû1ÀûÀûÀûÀûGÀû:ÀûIÀûQÀûRÀûj+Àü/// Return the total length of the current contour.
///
/// The length may be calculated from an approximation of the geometry
/// originally added. For this reason, it is not recommended to rely on
/// this property for mathematically correct lengths of common shapes. ÀüšAÀıÓ!/// Whether the contour is closed.
///
/// Returns true if the contour ends with a call to [Path.close] (which may
/// have been implied when using methods like [Path.addRect]) or if
/// `forceClosed` was specified as true in the call to [Path.computeMetrics].
/// Returns false otherwise. Àıà‚àÀ ´‚±/// The zero-based index of the contour.
///
/// [Path] objects are made up of zero or more contours. The first contour is
/// created once a drawing command (e.g. [Path.lineTo]) is issued. A
/// [Path.moveTo] command after a drawing command may create a new contour,
/// although it may not if optimizations are applied that determine the move
/// command did not actually result in moving the pen.
///
/// This property is only valid with reference to its original iterator and
/// the contours of the path at the time the path's metrics were computed. If
/// additional contours were added or existing contours updated, this metric
/// will be invalid for the current state of the path. À ÅÀ Ø   À å‚,À¦£/// Computes the position of the current contour at the given offset, and the
/// angle of the path at that point.
///
/// For example, calling this method with a distance of 1.41 for a line from
/// 0.0,0.0 to 2.0,2.0 would give a point 1.0,1.0 and the angle 45 degrees
/// (but in radians).
///
/// Returns null if the contour has zero [length].
///
/// The distance is clamped to the [length] of the current contour. ÀºÀÂ   ÀÀï€Ì/// Given a start and end distance, return the intervening segment(s).
///
/// `start` and `end` are clamped to legal values (0..[length])
/// Begin the segment with a moveTo if `startWithMoveTo` is true. ÀûÀ  À	
À  ÀÀ  À-ÀšqÀ­   ÀšÀ› À‹À  ÀL[ ÀLÀX ÀYÀf  ÀkÀq   Àt€¯À€Œ/// The index of the current contour in the list of contours in the path.
///
/// [nextContour] will increment this to the zero based index.À!À" À«€”À  ÀÀ(  À-À3  À«À¬À²ÀİÀ¸À³ÀÀÀÜÀÁÀÉÀĞÀÕÀÑÀØÀŞÀüÀåÀßÀçÀC€½ÀJ  ÀQÀV   À€‹Àu  À}À‚  ÀÀÀÀ1ÀÀÀÀ0ÀÀ#À(À$À+À2ÀaÀ9À3À;À[ÀUÀ]À“íÀœ  À°Àµ  ÀÂÀÊ   À	„€À	ô  À	ÿÀ
  À
À
  À	„À	…À	‹À	¹À	“À	ŒÀ	›À	¸À	œÀ	£À	¨À	¤À	«À	²À	ºÀ	ÛÀ	ÁÀ	»À	ÃÀ
&_À
+  À
7À
<  À
IÀ
Q  À
W
À
_  À
jÀ
p  À
À‰€ÛÀ  ÀÀ  À"À'  À4À<  ÀB
ÀJ  ÀNÀT  À‰ÀŠÀÀÒÀ–À‘ÀÀÑÀŸÀ¦À«À§À®À¶À½ÀÅÀÍÀÓÀõÀÚÀÔÀÜÀh€¿Àm  ÀvÀ{   À+€ˆÀ—  À¡À¦  À+À,À2ÀVÀ8À3À@ÀUÀAÀHÀMÀIÀPÀWÀ…À^ÀXÀ`ÀÀyÀÀf€‰Àk    Àó}À[   ÀóÀôÀúÀÀ ÀûÀÀÀ	ÀÀÀÀÀIÀÀÀ!ÀCÀ=ÀE À¥†|À¯/// A mask filter to apply to shapes as they are painted. A mask filter is a
/// function that takes a bitmap of color pixels, and returns another bitmap of
/// color pixels.
///
/// Instances of this class are used with [Paint.maskFilter] on [Paint] objects. À¾ƒÀ˜À™À‚¥/// Creates a mask filter that takes the shape being drawn and blurs it.
///
/// This is commonly used to approximate shadows.
///
/// The `style` argument controls the kind of effect to draw; see [BlurStyle].
///
/// The `sigma` argument controls the size of the effect. It is the standard
/// deviation of the Gaussian blur to apply. The value must be greater than
/// zero. The sigma corresponds to very roughly half the radius of the effect
/// in pixels.
///
/// A blur is an expensive operation and should therefore be used sparingly.
///
/// The arguments must not be null.
///
/// See also:
///
///  * [Canvas.drawShadow], which is a more efficient way to draw shadows.À£À©  À´Àº   ÀÉÀÙ  ÀãÀğ  ÀŒÀ À©À¶ÀÇ ÀÓÀ…<À™   À…À†Àí€”À  À
À  ÀíÀîÀÅZÀØ   ÀÅÀÆ À#˜ùÀîÄ/// A description of a color filter to apply when drawing a shape or compositing
/// a layer with a particular [Paint]. A color filter is a function that takes
/// two colors, and outputs one color. When applied during compositing, it is
/// independently applied to each pixel of the layer being drawn before the
/// entire layer is merged with the destination.
///
/// Instances of this class are used with [Paint.colorFilter] on [Paint]
/// objects. À‚XÀÚÀÛÀß¥/// Creates a color filter that applies the blend mode given as the second
/// argument. The source color is the one given as the first argument, and the
/// destination color is the one from the layer being composited.
///
/// The output of this filter is then composited into the background according
/// to the [Paint.blendMode], using the output of this filter as the source
/// and the background as the destination.ÀàÀç  ÀíÀø  ÀÀ
ÀÀ-À"À/ÀJÀBÀLÀ`ÀZÀbÀqˆ3À&À&À&%‡'/// Construct a color filter that transforms a color by a 5x5 matrix, where
/// the fifth row is implicitly added in an identity configuration.
///
/// Every pixel's color value, represented as an `[R, G, B, A]`, is matrix
/// multiplied to create a new color:
///
///     | R' |   | a00 a01 a02 a03 a04 |   | R |
///     | G' |   | a10 a11 a12 a13 a14 |   | G |
///     | B' | = | a20 a21 a22 a23 a24 | * | B |
///     | A' |   | a30 a31 a32 a33 a34 |   | A |
///     | 1  |   |  0   0   0   0   1  |   | 1 |
///
/// The matrix is in row-major order and the translation column is specified
/// in unnormalized, 0...255, space. For example, the identity matrix is:
///
/// ```dart
/// const ColorFilter identity = ColorFilter.matrix(<double>[
///   1, 0, 0, 0, 0,
///   0, 1, 0, 0, 0,
///   0, 0, 1, 0, 0,
///   0, 0, 0, 1, 0,
/// ]);
/// ```
///
/// ## Examples
///
/// An inversion color matrix:
///
/// ```dart
/// const ColorFilter invert = ColorFilter.matrix(<double>[
///   -1,  0,  0, 0, 255,
///    0, -1,  0, 0, 255,
///    0,  0, -1, 0, 255,
///    0,  0,  0, 1,   0,
/// ]);
/// ```
///
/// A sepia-toned color matrix (values based on the [Filter Effects Spec](https://www.w3.org/TR/filter-effects-1/#sepiaEquivalent)):
///
/// ```dart
/// const ColorFilter sepia = ColorFilter.matrix(<double>[
///   0.393, 0.769, 0.189, 0, 0,
///   0.349, 0.686, 0.168, 0, 0,
///   0.272, 0.534, 0.131, 0, 0,
///   0,     0,     0,     1, 0,
/// ]);
/// ```
///
/// A greyscale color filter (values based on the [Filter Effects Spec](https://www.w3.org/TR/filter-effects-1/#grayscaleEquivalent)):
///
/// ```dart
/// const ColorFilter greyscale = ColorFilter.matrix(<double>[
///   0.2126, 0.7152, 0.0722, 0, 0,
///   0.2126, 0.7152, 0.0722, 0, 0,
///   0.2126, 0.7152, 0.0722, 0, 0,
///   0,      0,      0,      1, 0,
/// ]);
/// ```À&&À&4  À&JÀ&CÀ&LÀ&eÀ&ZÀ&gÀ&}À&uÀ&À&•À&À&—À&¨€ôÀ'À'À''W/// Construct a color filter that applies the sRGB gamma curve to the RGB
/// channels. À'9À'2À';À'TÀ'IÀ'VÀ'lÀ'dÀ'nÀ'‚À'|À'„À' À(À(À(,d/// Creates a color filter that applies the inverse of the sRGB gamma curve
/// to the RGB channels. À(>À(7À(@À(YÀ(NÀ([À(qÀ(iÀ(sÀ(‡À(À(‰À(¥À(²  À(¼À(Í  À(ÛÀ(ï  À(úÀ)  À)>À)O À)\À)s!À)„ À)“À)·,À)È À)âÀ* ,À* À*+À.ªzÀ.¾   À.ªÀ.«À/(ÁÀ/?   À/(À/)À*bVÀ*{   À*bÀ*cÀ*¼‚¬À*Ê    À-l:À-†  À-‰À-‘  À-lÀ-mÀ0í‚-À1    À0íÀ0î À3‡jÀ4nD/// A [ColorFilter] that is backed by a native DlColorFilter.
///
/// This is a private class, rather than being the implementation of the public
/// ColorFilter, because we want ColorFilter to be const constructible and
/// efficiently comparable, so that widgets can check for ColorFilter equality to
/// avoid repainting. À4 €°À4¬À4­À4± À4²À4¸  
À4ÆÀ4ÌÀ4ôÀ4ÛÀ4ÍÀ4ÔÀ4ÕÀ4ŞÀ4éÀ4êÀ5T€¬À5`À5aÀ5g À5hÀ5n  
À5|À5‚À5¬À5‘À5ƒÀ5ŠÀ5‹À5”À5ŸÀ5 À6€§À6À6À6! À6"À6(  
À66À6<À6qÀ6KÀ6=À6DÀ6EÀ6NÀ6YÀ6ZÀ6®€§À6ºÀ6»À6Ì À6ÍÀ6Ó  
À6áÀ6çÀ7À6öÀ6èÀ6ïÀ6ğÀ6ùÀ7À7À7Y€À7ßo/// The original Dart object that created the native wrapper, which retains
/// the values used for the filter.  À7ë]À89   À7ëÀ7ìÀ7òÀ8À7øÀ7óÀ8 À8À8À8	À8'À8À8
À8À8L€—À8¿  À8É	À8Î  À8ÔÀ8Ù  À8LÀ8MÀ8SÀ8~À8YÀ8TÀ8aÀ8}À8bÀ8iÀ8nÀ8jÀ8qÀ8xÀ8À8­À8†À8€À8ˆÀ8§À8¡À8©À8ç€À9H  À9TÀ9a  À8çÀ8èÀ8îÀ9À8ôÀ8ïÀ8üÀ9À8ıÀ9À9	À9À9À9À96À9À9À9À9l€‹À9Ş   À9lÀ9mÀ9sÀ9À9yÀ9tÀ9À9À9‚À9‰À9À9ŠÀ9‘À9ÌÀ9˜À9’À9šÀ9ÆÀ9ÀÀ9ÈÀ9û€‹À:m   À9ûÀ9üÀ:À:À:À:À:À:À:À:À:À:À: À:[À:'À:!À:)À:UÀ:OÀ:W À:Š‹À<lÒ/// A filter operation to apply to a raster image.
///
/// See also:
///
///  * [BackdropFilter], a widget that applies [ImageFilter] to its rendering.
///  * [ImageFiltered], a widget that applies [ImageFilter] to its children.
///  * [SceneBuilder.pushBackdropFilter], which is the low-level API for using
///    this class as a backdrop filter.
///  * [SceneBuilder.pushImageFilter], which is the low-level API for using
///    this class as a child layer filter. À<ÎÀ<ÙÀ<ÚÀ<Û   À<üÀ=KÀ=LÀ=P9/// Creates an image filter that applies a Gaussian blur.À=SÀ=[  À=hÀ=p  À=}"À=‡  À=cÀ=xÀ=‘À=™À=šÀ>&À>«À>¬À>²€/// Creates an image filter that dilates each input pixel's channel values
/// to the max value within the given radii along the x and y axes.À>µÀ>½  À>ËÀ>Ó  À>ÆÀ>ÜÀ?/'À?ØÀ?ÙÀ?Ş€‘/// Create a filter that erodes each input pixel's channel values
/// to the minimum channel value within the given radii along the x and y axes.À?áÀ?é  À?÷À?ÿ  À?òÀ@À@Z‚'ÀAOÀAPÀAV€Ù/// Creates an image filter that applies a matrix transformation.
///
/// For example, applying a positive scale matrix (see [Matrix4.diagonal3])
/// when used with [BackdropFilter] would magnify the background image.ÀAWÀAd  ÀAƒ/ÀA’  ÀA¡ÀA®ÀA¯ÀB… ÀC“ÀC”ÀC›€ğ/// Composes the `inner` filter with `outer`, to combine their effects.
///
/// Creates a single [ImageFilter] that when applied, has the same effect as
/// subsequently applying `inner` and `outer`, i.e.,
/// result = outer(inner(source)).ÀCÀC´  ÀCºÀCĞ    ÀEpÀE{    ÀDÇ$ÀDÔ     ÀE‘ƒ`ÀE—  ÀEÅH ÀEÅÀE× ÀEÚÀEé  ÀEîÀEı   ÀFÀF#  ÀF+!ÀF?  ÀFr@ÀFŠ ÀF™ÀF¥ÀF¦ÀF¬ÀF±ÀF­ÀFúLÀG   ÀFúÀFûÀHQÀH²   ÀHÀHŸÀF¶@ÀFÏ   ÀF¶ÀF·ÀGJMÀG]   ÀGJÀGKÀG›€ÿÀGµ  ÀG¸ÀGÀ  ÀG›ÀGœ ÀHó„tÀHù  ÀI-a ÀI-ÀIE ÀIHÀIW  ÀI^ÀIm  ÀItÀIƒ   ÀI’ÀIŸ  ÀI©ÀI¶  ÀIÀÀIÏ  ÀIğ>ÀJ ÀJÀJ#ÀJ$ÀJ(ÀJ-ÀJ)ÀJv€îÀJ    ÀKhSÀK   ÀKhÀKiÀM)<ÀM=   ÀM)ÀM*ÀJ2@ÀJK   ÀJ2ÀJ3ÀK¿TÀKÒ   ÀK¿ÀKÀÀLÀL1  ÀL4ÀL<  ÀLÀL ÀMi‚ûÀMo  ÀME ÀMÀM¯ ÀM²ÀMÁ  ÀMÉÀMØ   ÀMæÀMó  ÀMşÀN  ÀN@ÀN/ ÀN>ÀNJÀNKÀNQÀNVÀNRÀNŸIÀN¶   ÀNŸÀN ÀP$>ÀP8   ÀP$ÀP%ÀN[@ÀNt   ÀN[ÀN\ÀNìJÀNÿ   ÀNìÀNíÀO:€æÀOT  ÀOWÀO_  ÀO:ÀO; ÀPf‚õÀPl  ÀP™D ÀP™ÀPª ÀP­ÀP¼  ÀPÄÀPÓ   ÀPáÀPî  ÀPùÀQ  ÀQ?ÀQ* ÀQ9ÀQEÀQFÀQKÀQPÀQLÀQ™HÀQ°   ÀQ™ÀQšÀS>ÀS/   ÀSÀSÀQU@ÀQn   ÀQUÀQVÀQåIÀQø   ÀQåÀQæÀR2€åÀRL  ÀROÀRW  ÀR2ÀR3 ÀS]ƒ‹ÀSc  ÀS’N ÀS’ÀS¥ ÀS¨ÀS·  ÀSÃÀSÒ   ÀSäÀSö  ÀTÀT  ÀTABÀTY ÀThÀTtÀTuÀT}ÀT‚ÀT~ÀTËsÀTâ   ÀTËÀTÌÀV FÀV´   ÀV ÀV¡ÀT‡@ÀT    ÀT‡ÀTˆÀUB_ÀUU   ÀUBÀUCÀU¥€÷ÀU¿  ÀUÂÀUÊ  ÀU¥ÀU¦ ÀVêöÀX)/// An [ImageFilter] that is backed by a native DlImageFilter.
///
/// This is a private class, rather than being the implementation of the public
/// ImageFilter, because we want ImageFilter to be efficiently comparable, so that
/// widgets can check for ImageFilter equality to avoid repainting. ÀXQ€ãÀX™ÀXšÀX9/// Creates an image filter that applies a Gaussian blur.ÀXŸÀX¹  ÀXÎÀXÆÀXĞÀY8#ÀY×ÀYØÀYŞ€/// Creates an image filter that dilates each input pixel's channel values
/// to the max value within the given radii along the x and y axes.ÀYßÀYó  ÀZÀZ ÀZ
ÀZ_#À[À[À[€‘/// Create a filter that erodes each input pixel's channel values
/// to the minimum channel value within the given radii along the x and y axes.À[À[  À[0À[(À[2À[†ãÀ\tÀ\uÀ\{€Ù/// Creates an image filter that applies a matrix transformation.
///
/// For example, applying a positive scale matrix (see [Matrix4.diagonal3])
/// when used with [BackdropFilter] would magnify the background image.À\|À\  À\¥À\À\§À]m€ıÀ]«À]¬À]»//// Converts a color filter to an image filter.À]¼À]É  À]ŞÀ]ÖÀ]àÀ^nzÀ^­À^®À^¶0/// Composes `_innerFilter` with `_outerFilter`.À^·À^Ì  À^áÀ^ÙÀ^ãÀdP€ÀdÖo/// The original Dart object that created the native wrapper, which retains
/// the values used for the filter.  À_ì]À`:   À_ìÀ_íÀ_óÀ`	À_ùÀ_ôÀ`À`À`À`
À`(À`À`À`À`M€²À`É  À`ÓÀ`Û  À`âÀ`ê  À`ñÀ`ö  À`MÀ`NÀ`TÀ`ˆÀ`ZÀ`UÀ`bÀ`‡À`cÀ`jÀ`oÀ`kÀ`rÀ`zÀ`‚À`‰À`·À`À`ŠÀ`’À`±À`«À`³Àa€£Àaz  Àa†Àa  Àa–Àa  ÀaÀaÀa
Àa7ÀaÀaÀaÀa6ÀaÀa Àa%Àa!Àa(Àa0Àa8ÀahÀa?Àa9ÀaAÀabÀa\ÀadÀaª€¡Àb   Àb+Àb3  Àb;ÀbC  ÀaªÀa«Àa±ÀaŞÀa·Àa²Àa¿ÀaİÀaÀÀaÇÀaÌÀaÈÀaÏÀa×ÀaßÀbÀaæÀaàÀaèÀbÀbÀb
ÀbO€œÀb·  ÀbÃÀbĞ  ÀbØÀbİ  ÀbOÀbPÀbVÀb‚Àb\ÀbWÀbdÀbÀbeÀblÀbqÀbmÀbtÀb|ÀbƒÀb¥ÀbŠÀb„ÀbŒÀbï€™Àc\  ÀcmÀc|  ÀbïÀbğÀböÀc"ÀbüÀb÷ÀcÀc!ÀcÀcÀcÀcÀcÀcÀc ÀcÀc#ÀcJÀc*Àc$Àc,ÀcŒ€ÀÀd
  ÀdÀd&  Àd2Àd@  ÀcŒÀcÀc“ÀcÎÀc™Àc”Àc¡ÀcÍÀc¢Àc©Àc®ÀcªÀc±Àc¸Àc½Àc¹ÀcÀÀcÇÀcÌÀcÈÀcÏÀcøÀcÖÀcĞÀcØ Àdâ„ëÀehz/// Base class for objects such as [Gradient] and [ImageShader] which
/// correspond to shaders as used by [Paint.shader]. Àe”€ÀfÀfÀfa/// This class is created by the engine, and should not be instantiated
/// or extended directly. ÀeúÀeûÀfÀfÀfÀf%Àf* Àf;ÀfEÀfÎy/// Whether [dispose] has been called.
///
/// This must only be used when asserts are enabled. Otherwise, it will throw.   Àg`‚kÀiSÛ/// Release the resources used by this object. The object is no longer usable
/// after this method is called.
///
/// The underlying memory allocated by this object will be retained beyond
/// this call if it is still needed by another object that has not been
/// disposed. For example, a [Picture] that has not been disposed that
/// refers to an [ImageShader] may keep its underlying resources alive.
///
/// Classes that override this method must call `super.dispose()`.    À€„¥}ÀĞ@/// A shader (as used by [Paint.shader]) that renders a color gradient.
///
/// There are several types of gradients, represented by the various constructors
/// on this class.
///
/// See also:
///
///  * [Gradient](https://api.flutter.dev/flutter/painting/Gradient-class.html), the class in the [painting] library.
/// Àì‡İÀ‡À‡À‡„æ/// Creates a linear gradient from `from` to `to`.
///
/// If `colorStops` is provided, `colorStops[i]` is a number from 0.0 to 1.0
/// that specifies where `color[i]` begins in the gradient. If `colorStops` is
/// not provided, then only two stops, at 0.0 and 1.0, are implied (and
/// `color` must therefore only have two entries).
///
/// The behavior before `from` and after `to` is described by the `tileMode`
/// argument. For details, see the [TileMode] enum.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_clamp_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_decal_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_mirror_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_repeated_linear.png)
///
/// If `from`, `to`, `colors`, or `tileMode` are null, or if `colors` or
/// `colorStops` contain null values, this constructor will throw a
/// [NoSuchMethodError].
///
/// If `matrix4` is provided, the gradient fill will be transformed by the
/// specified 4x4 matrix relative to the local coordinate system. `matrix4` must
/// be a column-major matrix packed into a list of 16 values.À‡À‡  À‡%	À‡-  À‡4À‡A  À‡NÀ‡]  À‡l"À‡v  À‡”À‡¢  !À‡€À‡ˆÀ‡‰À‡±À‡·À‡ÌÀ‡¸À‡ÆÀ‡ËÀ‡ÇÀ‡ÖÀ‡ÜÀ‡ïÀ‡İÀ‡ëÀ‡îÀ‡ìÀ‡ùÀ‡ÿÀˆ+ÀˆÀˆÀˆ ÀˆÀˆÀˆ"Àˆ*Àˆ#Àˆ5Àˆ:Àˆ;Àˆ<Àˆ=À‰Í‹ÊÀÏÀĞÀÖ†½/// Creates a radial gradient centered at `center` that ends at `radius`
/// distance from the center.
///
/// If `colorStops` is provided, `colorStops[i]` is a number from 0.0 to 1.0
/// that specifies where `color[i]` begins in the gradient. If `colorStops` is
/// not provided, then only two stops, at 0.0 and 1.0, are implied (and
/// `color` must therefore only have two entries).
///
/// The behavior before and after the radius is described by the `tileMode`
/// argument. For details, see the [TileMode] enum.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_clamp_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_decal_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_mirror_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_repeated_radial.png)
///
/// If `center`, `radius`, `colors`, or `tileMode` are null, or if `colors` or
/// `colorStops` contain null values, this constructor will throw a
/// [NoSuchMethodError].
///
/// If `matrix4` is provided, the gradient fill will be transformed by the
/// specified 4x4 matrix relative to the local coordinate system. `matrix4` must
/// be a column-major matrix packed into a list of 16 values.
///
/// If `focal` is provided and not equal to `center` and `focalRadius` is
/// provided and not equal to 0.0, the generated shader will be a two point
/// conical radial gradient, with `focal` being the center of the focal
/// circle and `focalRadius` being the radius of that circle. If `focal` is
/// provided and not equal to `center`, at least one of the two offsets must
/// not be equal to [Offset.zero].ÀÜÀä  ÀïÀ÷  À‘À‘  À‘À‘+  À‘:"À‘D  À‘bÀ‘p  À‘|À‘…  À‘À‘—  À‘NÀ‘VÀ‘WÀ‘¤À‘¯À‘µÀ‘ÌÀ‘¶À‘ÄÀ‘ËÀ‘ÅÀ‘ÖÀ‘ÜÀ’À‘íÀ‘åÀ‘İÀ‘èÀ‘ğÀ‘ÿÀ’À’ À’À’À’À’À’À•›‰À›çÀ›èÀ›í†/// Creates a sweep gradient centered at `center` that starts at `startAngle`
/// and ends at `endAngle`.
///
/// `startAngle` and `endAngle` should be provided in radians, with zero
/// radians being the horizontal line to the right of the `center` and with
/// positive angles going clockwise around the `center`.
///
/// If `colorStops` is provided, `colorStops[i]` is a number from 0.0 to 1.0
/// that specifies where `color[i]` begins in the gradient. If `colorStops` is
/// not provided, then only two stops, at 0.0 and 1.0, are implied (and
/// `color` must therefore only have two entries).
///
/// The behavior before `startAngle` and after `endAngle` is described by the
/// `tileMode` argument. For details, see the [TileMode] enum.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_clamp_sweep.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_decal_sweep.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_mirror_sweep.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_repeated_sweep.png)
///
/// If `center`, `colors`, `tileMode`, `startAngle`, or `endAngle` are null,
/// or if `colors` or `colorStops` contain null values, this constructor will
/// throw a [NoSuchMethodError].
///
/// If `matrix4` is provided, the gradient fill will be transformed by the
/// specified 4x4 matrix relative to the local coordinate system. `matrix4` must
/// be a column-major matrix packed into a list of 16 values.À›óÀ›û  ÀœÀœ  Àœ Àœ/  Àœ>"ÀœH  ÀœfÀœn  ÀœƒÀœ‹  Àœ¦Àœ´  &ÀœRÀœZÀœ[ÀœzÀœÀœ•Àœ™ÀœšÀœŸÀœÃÀœÉÀœàÀœÊÀœØÀœßÀœÙÀœêÀœğÀÀœüÀœñÀœşÀÀÀBÀ'ÀÀÀ"À*À9ÀAÀ:ÀLÀQÀRÀSÀT  ÀºZÀŸ   ÀºÀ»ÀÁÀ×ÀÇÀÂÀÏÀÖÀĞÀØÀóÀßÀÙÀáÀŸ€ïÀŸ•  ÀŸ¡ÀŸ®  ÀŸ¸ÀŸÃ  ÀŸÊÀŸØ  ÀŸãÀŸè  ÀŸñÀŸÿ  ÀŸÀŸÀŸÀŸcÀŸ%ÀŸ ÀŸ-ÀŸbÀŸ.ÀŸ5ÀŸ:ÀŸ6ÀŸ=ÀŸEÀŸMÀŸUÀŸ\ÀŸdÀŸƒÀŸkÀŸeÀŸmÀ BÀ ˜  À «À ³  À ÁÀ É  À ×À ß  À ìÀ ÷  À¡À¡  À¡#À¡(  À¡7À¡E  À À À À fÀ À À  À eÀ !À (À -À )À 0À 8À @À HÀ PÀ XÀ _À gÀ †À nÀ hÀ pÀ¡Q¥À¡ÿ  
À¢À¢  À¢(À¢0  À¢=À¢E  À¢WÀ¢_  À¢jÀ¢r  À¢}À¢…  À¢•À¢   À¢­À¢»  À¢ÌÀ¢Ñ  À¢àÀ¢î  À¡QÀ¡RÀ¡XÀ¡ÄÀ¡^À¡YÀ¡fÀ¡ÃÀ¡gÀ¡nÀ¡sÀ¡oÀ¡vÀ¡~À¡†À¡À¡–À¡À¡¦À¡®À¡¶À¡½À¡ÅÀ¡íÀ¡ÌÀ¡ÆÀ¡ÎÀ¢úbÀ£  À£ À£¨  À£¶À£¾  À£ÌÀ£×  À£äÀ£ò  À¤À¤  À¤À¤  À¤0À¤8  À¤GÀ¤U  À¢úÀ¢ûÀ£À£]À£À£À£À£\À£À£À£À£À£À£'À£/À£7À£?À£FÀ£NÀ£VÀ£^À£|À£eÀ£_À£gÀ¤`ŸÀ¤l  À¤‡À¤”  À¤›À¤ª    À¦ˆlÀ¦L=/// A shader (as used by [Paint.shader]) that tiles an image. À¦k…– Àª/Àª:ƒ/// Creates an image-tiling shader.
///
/// The first argument specifies the image to render. The
/// [decodeImageFromList] function can be used to decode an image from bytes
/// into the form expected here. (In production code, starting from
/// [instantiateImageCodec] may be preferable.)
///
/// The second and third arguments specify the [TileMode] for the x direction
/// and y direction respectively. [TileMode.repeated] can be used for tiling
/// images.
///
/// The fourth argument gives the matrix to apply to the effect. The
/// expression `Matrix4.identity().storage` creates a [Float64List]
/// prepopulated with the identity matrix.
///
/// All the arguments are required and must not be null, except for
/// [filterQuality]. If [filterQuality] is not specified at construction time
/// it will be deduced from the environment where it is used, such as from
/// [Paint.filterQuality].Àª;ÀªB  ÀªHÀªR  ÀªVÀª`  ÀªdÀªq  ÀªÀª  ÀªÀªÀªÀª+ÀªÀª¨Àª®ÀªÃÀª¯Àª°ÀªµÀª¶ÀªÊÀªÏÀªĞÀªÑÀªÒ  À¬EÀ¬   À¬À¬À¬N]À¬œ   À¬NÀ¬OÀ¬UÀ¬kÀ¬[À¬VÀ¬cÀ¬jÀ¬dÀ¬lÀ¬ŠÀ¬sÀ¬mÀ¬uÀ¬¯€éÀ­<  À­KÀ­S  À­YÀ­^  À­bÀ­g  À­kÀ­p  À­ƒÀ­  À¬¯À¬°À¬¶À­À¬¾À¬·À¬ÆÀ­ À¬ÇÀ¬ÎÀ¬ÓÀ¬ÏÀ¬ÖÀ¬İÀ¬âÀ¬ŞÀ¬åÀ¬ìÀ¬óÀ¬úÀ­À­'À­	À­À­À­œ€ÑÀ®bk/// This can't be a leaf call because the native function calls Dart API
/// (Dart_SetNativeInstanceField).  À®À®À®À®0À®À®À®!À®/À®"À®)À®.À®*À®1À®PÀ®8À®2À®: À®qŒÏÀ¯Y€Ü/// An instance of [FragmentProgram] creates [Shader] objects (as used by
/// [Paint.shader]).
///
/// For more information, see the website
/// [documentation]( https://docs.flutter.dev/development/ui/advanced/shaders). À¯!À¯¹À¯ºÀ¯Ä À¯ÅÀ¯Í  À¯À¯À¯•À¯¦À¯–À°³À°»  À¶U{À¶ 	À¶ÎÀ¶ÏÀ¶¦À¶ÍÀ¶§À¶¯À¶¼À¶ÌÀ¶½À¹Q7À¹v À¹QÀ¹RÀ¹XÀ¹iÀ¹YÀ¹2À¹² À¹À¹À¹”À¹¥À¹• À°Ê„SÀ²%//// Creates a fragment program from the asset with key [assetKey].
///
/// The asset must be a file produced as the output of the `impellerc`
/// compiler. The constructed object should then be reused via the
/// [fragmentShader] method to create [Shader] objects that can be used by
/// [Paint.shader]. À²/À²7   À¶Õ‚xÀ¶á  À¶õÀ¶ı   À¹ÄaÀº   À¹ÄÀ¹ÅÀ¹ËÀ¹áÀ¹ÑÀ¹ÌÀ¹ÙÀ¹àÀ¹ÚÀ¹âÀºÀ¹éÀ¹ãÀ¹ëÀº)€ŒÀº•  Àº¤Àº¬  Àº)Àº*Àº0ÀºWÀº8Àº1Àº@ÀºVÀºAÀºHÀºMÀºIÀºPÀºXÀºÀº_ÀºYÀºaÀº¹€…Àºü1/// Returns a fresh instance of [FragmentShader].    À»B‘şÀ¾3‚å/// A [Shader] generated from a [FragmentProgram].
///
/// Instances of this class can be obtained from the
/// [FragmentProgram.fragmentShader] method. The float uniforms list is
/// initialized to the size expected by the shader and is zero-filled. Uniforms
/// of float type can then be set by calling [setFloat]. Sampler uniforms are
/// set by calling [setImageSampler].
///
/// A [FragmentShader] can be re-used, and this is an efficient way to avoid
/// allocating and re-initializing the uniform buffer and samplers. However,
/// if two [FragmentShader] objects with different float uniforms or samplers
/// are required to exist simultaneously, they must be obtained from two
/// different calls to [FragmentProgram.fragmentShader]. À¾U€ÛÀ¾cÀ¾dÀ¾e À¾fÀ¾w  À¾À¾Š  À¾£À¾˜À¾¥À¾°À¾µÀ¾¶À¾·À¾¸À¿4À¿B  À¿Q<À¿j À¿À¿ŠÀ¿ŒÀ¿‹À¿‘(À¿ À¿§ À¿¾‡ÀÆ¶†œ/// Sets the float uniform at [index] to [value].
///
/// All uniforms defined in a fragment shader that are not samplers must be
/// set through this method. This includes floats and vec2, vec3, and vec4.
/// The correct index for each uniform is determined by the order of the
/// uniforms as defined in the fragment program, ignoring any samplers. For
/// data types that are composed of multiple floats such as a vec4, more than
/// one call to [setFloat] is required.
///
/// For example, given the following uniforms in a fragment program:
///
/// ```glsl
/// uniform float uScale;
/// uniform sampler2D uTexture;
/// uniform vec2 uMagnitude;
/// uniform vec4 uColor;
/// ```
///
/// Then the corresponding Dart code to correctly initialize these uniforms
/// is:
///
/// ```dart
/// void updateShader(ui.FragmentShader shader, Color color, ui.Image image) {
///   shader.setFloat(0, 23);  // uScale
///   shader.setFloat(1, 114); // uMagnitude x
///   shader.setFloat(2, 83);  // uMagnitude y
///
///   // Convert color to premultiplied opacity.
///   shader.setFloat(3, color.red / 255 * color.opacity);   // uColor r
///   shader.setFloat(4, color.green / 255 * color.opacity); // uColor g
///   shader.setFloat(5, color.blue / 255 * color.opacity);  // uColor b
///   shader.setFloat(6, color.opacity);                     // uColor a
///
///   // initialize sampler uniform.
///   shader.setImageSampler(0, image);
/// }
/// ```
///
/// Note how the indexes used does not count the `sampler2D` uniform. This
/// uniform will be set separately with [setImageSampler], with the index starting
/// over at 0.
///
/// Any float uniforms that are left uninitialized will default to `0`. ÀÆ¿	ÀÆÄ  ÀÆÊÀÆÒ   ÀÇRüÀÈ¢</// Sets the sampler uniform at [index] to [image].
///
/// The index provided to setImageSampler is the index of the sampler uniform defined
/// in the fragment program, excluding all non-sampler uniforms.
///
/// All the sampler uniforms that a shader expects must be provided or the
/// results will be undefined. ÀÈ²	ÀÈ·  ÀÈ½ÀÈÄ   ÀÉR…ÀÊ/// Releases the native resources held by the [FragmentShader].
///
/// After this method is called, calling methods on the shader, or attaching
/// it to a [Paint] object will fail with an exception. Calling [dispose]
/// twice will also result in an exception being thrown.  ÀÊpÀÊqÀÊÛ€ÈÀËU  ÀËbÀËs  ÀË{ÀË€  ÀËÀË“  ÀÊÛÀÊÜÀÊâÀËÀÊêÀÊãÀÊòÀËÀÊóÀÊûÀËÀËÀËÀË<ÀËÀËÀËÀË§€¥ÀÌ   ÀÌ1	ÀÌ6  ÀÌ<ÀÌD  ÀË§ÀË¨ÀË®ÀËÛÀË´ÀË¯ÀË¼ÀËÚÀË½ÀËÄÀËÉÀËÅÀËÌÀËÔÀËÜÀÌÀËãÀËİÀËåÀÌP~ÀÌº   ÀÌPÀÌQÀÌWÀÌtÀÌ]ÀÌXÀÌeÀÌsÀÌfÀÌmÀÌrÀÌnÀÌuÀÌ¨ÀÌ|ÀÌvÀÌ~ÀÌÒlÀÍ3   ÀÌÒÀÌÓÀÌÙÀÌöÀÌßÀÌÚÀÌçÀÌõÀÌèÀÌïÀÌôÀÌğÀÌ÷ÀÍ!ÀÌşÀÌøÀÍ  ÀĞ¬ÀØˆn/// A set of vertex data used by [Canvas.drawVertices].
///
/// Vertex data consists of a series of points in the canvas coordinate space.
/// Based on the [VertexMode], these points are interpreted either as
/// independent triangles ([VertexMode.triangles]), as a sliding window of
/// points forming a chain of triangles each sharing one side with the next
/// ([VertexMode.triangleStrip]), or as a fan of triangles with a single shared
/// point ([VertexMode.triangleFan]).
///
/// Each point can be associated with a color. Each triangle is painted as a
/// gradient that blends between the three colors at the three points of that
/// triangle. If no colors are specified, transparent black is assumed for all
/// the points.
///
/// These colors are then blended with the [Paint] specified in the call to
/// [Canvas.drawVertices]. This paint is either a solid color ([Paint.color]),
/// or a bitmap, specified using a shader ([Paint.shader]), typically either a
/// gradient ([Gradient]) or image ([ImageFilter]). The bitmap uses the same
/// coordinate space as the canvas (in the case of an [ImageFilter], this is
/// notably different than the coordinate space of the source image; the source
/// image is tiled according to the filter's configuration, and the image that
/// is sampled when painting the triangles is the infinite one after all the
/// repeating is applied.)
///
/// Each point in the [Vertices] is associated with a specific point on this
/// image. Each triangle is painted by sampling points from this image by
/// interpolating between the three points of the image corresponding to the
/// three points of the triangle.
///
/// The [Vertices.new] constructor configures all this using lists of [Offset]
/// and [Color] objects. The [Vertices.raw] constructor instead uses
/// [Float32List], [Int32List], and [Uint16List] objects, which more closely
/// corresponds to the data format used internally and therefore reduces some of
/// the conversion overhead. The raw constructor is useful if the data is coming
/// from another source (e.g. a file) and can therefore be parsed directly into
/// the underlying representation. ÀØ¯é Àá°Àá¸ˆ¬/// Creates a set of vertex data for use with [Canvas.drawVertices].
///
/// The `mode` parameter describes how the points should be interpreted: as
/// independent triangles ([VertexMode.triangles]), as a sliding window of
/// points forming a chain of triangles each sharing one side with the next
/// ([VertexMode.triangleStrip]), or as a fan of triangles with a single
/// shared point ([VertexMode.triangleFan]).
///
/// The `positions` parameter provides the points in the canvas space that
/// will be use to draw the triangles.
///
/// The `colors` parameter, if specified, provides the color for each point in
/// `positions`. Each triangle is painted as a gradient that blends between
/// the three colors at the three points of that triangle. (These colors are
/// then blended with the [Paint] specified in the call to
/// [Canvas.drawVertices].)
///
/// The `textureCoordinates` parameter, if specified, provides the points in
/// the [Paint] image to sample for the corresponding points in `positions`.
///
/// If the `colors` or `textureCoordinates` parameters are specified, they must
/// be the same length as `positions`.
///
/// The `indices` parameter specifies the order in which the points should be
/// painted. If it is omitted (or present but empty), the points are processed
/// in the order they are given in `positions`, as if the `indices` was a list
/// from 0 to n-1, where _n_ is the number of entries in `positions`. The
/// `indices` parameter, if present and non-empty, must have at least three
/// entries, but may be of any length beyond this. Indicies may refer to
/// offsets in the positions array multiple times, or may skip positions
/// entirely.
///
/// If the `indices` parameter is specified, all values in the list must be
/// valid index values for `positions`.
///
/// The `mode` and `positions` parameters must not be null.
///
/// This constructor converts its parameters into [dart:typed_data] lists
/// (e.g. using [Float32List]s for the coordinates) before sending them to the
/// Flutter engine. If the data provided to this constructor is not already in
/// [List] form, consider using the [Vertices.raw] constructor instead to
/// avoid converting the data twice.Àá¾ÀáÊ  ÀáÓÀáá  ÀáñÀáÿ  Àâ
 Àâ  Àâ0Àâ<   ÀçœWÀò%Àò&Àò)Š(/// Creates a set of vertex data for use with [Canvas.drawVertices], using the
/// encoding expected by the Flutter engine.
///
/// The `mode` parameter describes how the points should be interpreted: as
/// independent triangles ([VertexMode.triangles]), as a sliding window of
/// points forming a chain of triangles each sharing one side with the next
/// ([VertexMode.triangleStrip]), or as a fan of triangles with a single
/// shared point ([VertexMode.triangleFan]).
///
/// The `positions` parameter provides the points in the canvas space that
/// will be use to draw the triangles. Each point is represented as two
/// numbers in the list, the first giving the x coordinate and the second
/// giving the y coordinate. (As a result, the list must have an even number
/// of entries.)
///
/// The `colors` parameter, if specified, provides the color for each point in
/// `positions`. Each color is represented as ARGB with 8 bit color channels
/// (like [Color.value]'s internal representation), and the list, if
/// specified, must therefore be half the length of `positions`. Each triangle
/// is painted as a gradient that blends between the three colors at the three
/// points of that triangle. (These colors are then blended with the [Paint]
/// specified in the call to [Canvas.drawVertices].)
///
/// The `textureCoordinates` parameter, if specified, provides the points in
/// the [Paint] image to sample for the corresponding points in `positions`.
/// Each point is represented as two numbers in the list, the first giving the
/// x coordinate and the second giving the y coordinate. This list, if
/// specified, must be the same length as `positions`.
///
/// The `indices` parameter specifies the order in which the points should be
/// painted. If it is omitted (or present but empty), the points are processed
/// in the order they are given in `positions`, as if the `indices` was a list
/// from 0 to n-2, where _n_ is the number of pairs in `positions` (i.e. half
/// the length of `positions`). The `indices` parameter, if present and
/// non-empty, must have at least three entries, but may be of any length
/// beyond this. Indicies may refer to offsets in the positions array multiple
/// times, or may skip positions entirely.
///
/// If the `indices` parameter is specified, all values in the list must be
/// valid index values for pairs in `positions`. For example, if there are 12
/// numbers in `positions` (representing 6 coordinates), the `indicies` must
/// be numbers in the range 0..5 inclusive.
///
/// The `mode` and `positions` parameters must not be null.Àò/Àò;  ÀòDÀòQ  ÀòaÀòm  ÀòxÀò†  ÀòÀòª   ÀúSÀúX ÀúdÀúmÀû*€«/// Whether this reference to the underlying vertex data is [dispose]d.
///
/// This only returns a valid value if asserts are enabled, and must not be
/// used otherwise.   Àö÷À÷n  À÷tÀ÷~  À÷§À÷¬  À÷ÎÀ÷Û  ÀøÀø  Àø@ÀøL  ÀøpÀø}  Àö÷ÀöøÀöşÀ÷;À÷ÀöÿÀ÷À÷:À÷À÷À÷À÷$À÷,À÷4À÷<À÷UÀ÷CÀ÷=À÷EÀø‰€ôÀùn/// Release the resources used by this object. The object is no longer usable
/// after this method is called.   Àù€ÎÀúDk/// This can't be a leaf call because the native function calls Dart API
/// (Dart_SetNativeInstanceField).  ÀùñÀùòÀùøÀúÀùşÀùùÀúÀúÀúÀúÀúÀúÀúÀú2ÀúÀúÀú ÀUÀ –:ÀÎƒi/// An interface for recording graphical operations.
///
/// [Canvas] objects are used in creating [Picture] objects, which can
/// themselves be used with a [SceneBuilder] to build a [Scene]. In
/// normal usage, however, this is all handled by the framework.
///
/// A canvas has a current transformation matrix which is applied to all
/// operations. Initially, the transformation matrix is the identity transform.
/// It can be modified using the [translate], [scale], [rotate], [skew],
/// and [transform] methods.
///
/// A canvas also has a current clip region which is applied to all operations.
/// Initially, the clip region is infinite. It can be modified using the
/// [clipRect], [clipRRect], and [clipPath] methods.
///
/// The current transform and clip can be saved and restored using the stack
/// managed by the [save], [saveLayer], and [restore] methods. ÀÙ‚× ÀkÀq‚q/// Creates a canvas for recording graphical operations into the
/// given picture recorder.
///
/// Graphical operations that affect pixels entirely outside the given
/// `cullRect` might be discarded by the implementation. However, the
/// implementation might draw outside these bounds if, for example, a command
/// draws partially inside and outside the `cullRect`. To ensure that pixels
/// outside a given region are discarded, consider using a [clipRect]. The
/// `cullRect` is optional; by default, all operations are kept.
///
/// To end the recording, call [PictureRecorder.endRecording] on the
/// given recorder.ÀrÀƒ  ÀÀ•     %À´(ÀÕ/// Saves a copy of the current transform and clip on the save stack.
///
/// Call [restore] to pop the save stack.
///
/// See also:
///
///  * [saveLayer], which does the same thing but additionally also groups the
///    commands done until the matching [restore].   Àà”šÀU“•/// Saves a copy of the current transform and clip on the save stack, and then
/// creates a new group which subsequent calls will become a part of. When the
/// save stack is later popped, the group will be flattened into a layer and
/// have the given `paint`'s [Paint.colorFilter] and [Paint.blendMode]
/// applied.
///
/// This lets you create composite effects, for example making a group of
/// drawing commands semi-transparent. Without using [saveLayer], each part of
/// the group would be painted individually, so where they overlap would be
/// darker than where they do not. By using [saveLayer] to group them
/// together, they can be drawn with an opaque color at first, and then the
/// entire group can be made transparent using the [saveLayer]'s paint.
///
/// Call [restore] to pop the save stack and apply the paint to the group.
///
/// ## Using saveLayer with clips
///
/// When a rectangular clip operation (from [clipRect]) is not axis-aligned
/// with the raster buffer, or when the clip operation is not rectilinear
/// (e.g. because it is a rounded rectangle clip created by [clipRRect] or an
/// arbitrarily complicated path clip created by [clipPath]), the edge of the
/// clip needs to be anti-aliased.
///
/// If two draw calls overlap at the edge of such a clipped region, without
/// using [saveLayer], the first drawing will be anti-aliased with the
/// background first, and then the second will be anti-aliased with the result
/// of blending the first drawing and the background. On the other hand, if
/// [saveLayer] is used immediately after establishing the clip, the second
/// drawing will cover the first in the layer, and thus the second alone will
/// be anti-aliased with the background when the layer is clipped and
/// composited (when [restore] is called).
///
/// For example, this [CustomPainter.paint] method paints a clean white
/// rounded rectangle:
///
/// ```dart
/// void paint(Canvas canvas, Size size) {
///   Rect rect = Offset.zero & size;
///   canvas.save();
///   canvas.clipRRect(RRect.fromRectXY(rect, 100.0, 100.0));
///   canvas.saveLayer(rect, Paint());
///   canvas.drawPaint(Paint()..color = Colors.red);
///   canvas.drawPaint(Paint()..color = Colors.white);
///   canvas.restore();
///   canvas.restore();
/// }
/// ```
///
/// On the other hand, this one renders a red outline, the result of the red
/// paint being anti-aliased with the background at the clip edge, then the
/// white paint being similarly anti-aliased with the background _including
/// the clipped red paint_:
///
/// ```dart
/// void paint(Canvas canvas, Size size) {
///   // (this example renders poorly, prefer the example above)
///   Rect rect = Offset.zero & size;
///   canvas.save();
///   canvas.clipRRect(RRect.fromRectXY(rect, 100.0, 100.0));
///   canvas.drawPaint(Paint()..color = Colors.red);
///   canvas.drawPaint(Paint()..color = Colors.white);
///   canvas.restore();
/// }
/// ```
///
/// This point is moot if the clip only clips one draw operation. For example,
/// the following paint method paints a pair of clean white rounded
/// rectangles, even though the clips are not done on a separate layer:
///
/// ```dart
/// void paint(Canvas canvas, Size size) {
///   canvas.save();
///   canvas.clipRRect(RRect.fromRectXY(Offset.zero & (size / 2.0), 50.0, 50.0));
///   canvas.drawPaint(Paint()..color = Colors.white);
///   canvas.restore();
///   canvas.save();
///   canvas.clipRRect(RRect.fromRectXY(size.center(Offset.zero) & (size / 2.0), 50.0, 50.0));
///   canvas.drawPaint(Paint()..color = Colors.white);
///   canvas.restore();
/// }
/// ```
///
/// (Incidentally, rather than using [clipRRect] and [drawPaint] to draw
/// rounded rectangles like this, prefer the [drawRRect] method. These
/// examples are using [drawPaint] as a proxy for "complicated draw operations
/// that will get clipped", to illustrate the point.)
///
/// ## Performance considerations
///
/// Generally speaking, [saveLayer] is relatively expensive.
///
/// There are a several different hardware architectures for GPUs (graphics
/// processing units, the hardware that handles graphics), but most of them
/// involve batching commands and reordering them for performance. When layers
/// are used, they cause the rendering pipeline to have to switch render
/// target (from one layer to another). Render target switches can flush the
/// GPU's command buffer, which typically means that optimizations that one
/// could get with larger batching are lost. Render target switches also
/// generate a lot of memory churn because the GPU needs to copy out the
/// current frame buffer contents from the part of memory that's optimized for
/// writing, and then needs to copy it back in once the previous render target
/// (layer) is restored.
///
/// See also:
///
///  * [save], which saves the current state, but does not create a new layer
///    for subsequent commands.
///  * [BlendMode], which discusses the use of [Paint.blendMode] with
///    [saveLayer]. À_Àf  ÀmÀt   À~FÀº(/// Pops the current save stack, if there is anything to pop.
/// Otherwise, does nothing.
///
/// Use [save] and [saveLayer] to push state onto the stack.
///
/// If the state was pushed with [saveLayer], then this call will also
/// cause the new layer to be composited into the previous layer.   ÀÈ‚%À Óó/// Restores the save stack to a previous level as might be obtained from [getSaveCount].
/// If [count] is less than 1, the stack is restored to its initial state.
/// If [count] is greater than the current [getSaveCount] then nothing happens.
///
/// Use [save] and [saveLayer] to push state onto the stack.
///
/// If any of the state stack levels restored by this call were pushed with
/// [saveLayer], then this call will also cause those layers to be composited
/// into their previous layers. À â	À ç   À ñBÀ"$"/// Returns the number of items on the save stack, including the
/// initial state. This means it returns 1 for a clean canvas, and
/// that each call to [save] and [saveLayer] increments it, and that
/// each matching call to [restore] decrements it.
///
/// This number cannot go below 1.   À"7€ÅÀ"Ü€›/// Add a translation to the current transform, shifting the coordinate space
/// horizontally by the first argument and vertically by the second argument. À"æ	À"î  À"ñ	À"ù   À# ,À$€û/// Add an axis-aligned scale to the current transform, scaling by the first
/// argument in the horizontal direction and the second in the vertical
/// direction.
///
/// If [sy] is unspecified, [sx] will be used for the scale in both
/// directions. À$	À$  À$
À$(   À$0qÀ$ŠR/// Add a rotation to the current transform. The argument is in radians clockwise. À$‘À$™   À$¥5À%¿/// Add an axis-aligned skew to the current transform, with the first argument
/// being the horizontal skew in rise over run units clockwise around the
/// origin, and the second argument being the vertical skew in rise over run
/// units clockwise around the origin. À%Ä	À%Ì  À%Ï	À%×   À%Ş€¯À&n€ˆ/// Multiply the current transform by the specified 4â¨‰4 transformation matrix
/// specified as a list of values in column-major order. À&xÀ&…   À&‘‚À(…×/// Returns the current transform including the combined result of all transform
/// methods executed since the creation of this [Canvas] object, and respecting the
/// save/restore history.
///
/// Methods that can change the current transform include [translate], [scale],
/// [rotate], [skew], and [transform]. The [restore] method can also modify
/// the current transform by restoring it to the same value it had before its
/// associated [save] or [saveLayer] call.   À(˜‚À*Õ‚/// Reduces the clip region to the intersection of the current clip and the
/// given rectangle.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/clip_rect.png)
///
/// If [doAntiAlias] is true, then the clip will be anti-aliased.
///
/// If multiple draw commands intersect with the clip boundary, this can result
/// in incorrect blending at the clip boundary. See [saveLayer] for a
/// discussion of how to address that.
///
/// Use [ClipOp.difference] to subtract the provided rectangle from the
/// current clip. À*Ş	À*ä  À*ë À*ó  À+À+  À*ûÀ+À+À+ À+,‚;À-5ï/// Reduces the clip region to the intersection of the current clip and the
/// given rounded rectangle.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/clip_rrect.png)
///
/// If [doAntiAlias] is true, then the clip will be anti-aliased.
///
/// If multiple draw commands intersect with the clip boundary, this can result
/// in incorrect blending at the clip boundary. See [saveLayer] for a
/// discussion of how to address that and some examples of using [clipRRect]. À-?À-F  À-MÀ-S  À-`À-k‚À/A¼/// Reduces the clip region to the intersection of the current clip and the
/// given [Path].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/clip_path.png)
///
/// If [doAntiAlias] is true, then the clip will be anti-aliased.
///
/// If multiple draw commands intersect with the clip boundary, this can result
/// in incorrect blending at the clip boundary. See [saveLayer] for a
/// discussion of how to address that. À/J	À/P  À/VÀ/\  À/iÀ/tŠİÀ:<ŠZ/// Returns the conservative bounds of the combined result of all clip methods
/// executed within the current save stack of this [Canvas] object, as measured
/// in the local coordinate space under which rendering operations are curretnly
/// performed.
///
/// The combined clip results are rounded out to an integer pixel boundary before
/// they are transformed back into the local coordinate space which accounts for
/// the pixel roundoff in rendering operations, particularly when antialiasing.
/// Because the [Picture] may eventually be rendered into a scene within the
/// context of transforming widgets or layers, the result may thus be overly
/// conservative due to premature rounding. Using the [getDestinationClipBounds]
/// method combined with the external transforms and rounding in the true device
/// coordinate system will produce more accurate results, but this value may
/// provide a more convenient approximation to compare rendering operations to
/// the established clip.
///
/// {@template dart.ui.canvas.conservativeClipBounds}
/// The conservative estimate of the bounds is based on intersecting the bounds
/// of each clip method that was executed with [ClipOp.intersect] and potentially
/// ignoring any clip method that was executed with [ClipOp.difference]. The
/// [ClipOp] argument is only present on the [clipRect] method.
///
/// To understand how the bounds estimate can be conservative, consider the
/// following two clip method calls:
///
/// ```dart
/// void draw(Canvas canvas) {
///   canvas.clipPath(Path()
///     ..addRect(const Rect.fromLTRB(10, 10, 20, 20))
///     ..addRect(const Rect.fromLTRB(80, 80, 100, 100)));
///   canvas.clipPath(Path()
///     ..addRect(const Rect.fromLTRB(80, 10, 100, 20))
///     ..addRect(const Rect.fromLTRB(10, 80, 20, 100)));
///   // ...
/// }
/// ```
///
/// After executing both of those calls there is no area left in which to draw
/// because the two paths have no overlapping regions. But, in this case,
/// [getLocalClipBounds] would return a rectangle from `10, 10` to `100, 100` because it
/// only intersects the bounds of the two path objects to obtain its conservative
/// estimate.
///
/// The clip bounds are not affected by the bounds of any enclosing
/// [saveLayer] call as the engine does not currently guarantee the strict
/// enforcement of those bounds during rendering.
///
/// Methods that can change the current clip include [clipRect], [clipRRect],
/// and [clipPath]. The [restore] method can also modify the current clip by
/// restoring it to the same value it had before its associated [save] or
/// [saveLayer] call.
/// {@endtemplate}   À:UƒŸÀ=Ùƒb/// Returns the conservative bounds of the combined result of all clip methods
/// executed within the current save stack of this [Canvas] object, as measured
/// in the destination coordinate space in which the [Picture] will be rendered.
///
/// Unlike [getLocalClipBounds], the bounds are not rounded out to an integer
/// pixel boundary as the Destination coordinate space may not represent pixels
/// if the [Picture] being constructed will be further transformed when it is
/// rendered or added to a scene. In order to determine the true pixels being
/// affected, those external transforms should be applied first before rounding
/// out the result to integer pixel boundaries. Most typically, [Picture] objects
/// are rendered in a scene with a scale transform representing the Device Pixel
/// Ratio.
///
/// {@macro dart.ui.canvas.conservativeClipBounds}   À=ø€İÀ>©€¥/// Paints the given [Color] onto the canvas, applying the given
/// [BlendMode], with the given color being the source and the background
/// being the destination. À>³À>º  À>ÀÀ>Ë   À>ÙüÀ@©¼/// Draws a line between the given points using the given paint. The line is
/// stroked, the value of the [Paint.style] is ignored for this call.
///
/// The `p1` and `p2` arguments are interpreted as offsets from the origin.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_line.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_line_dark.png#gh-dark-mode-only) À@²	À@º  À@½	À@Å  À@ÈÀ@Ï   À@Ù€±ÀAs€Œ/// Fills the canvas with the given [Paint].
///
/// To fill the canvas with a solid color and blend mode, consider
/// [drawColor] instead. ÀA}ÀA„   ÀA‘ÀBş`/// Draws a rectangle with the given [Paint]. Whether the rectangle is filled
/// or stroked (or both) is controlled by [Paint.style].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_rect.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_rect_dark.png#gh-dark-mode-only) ÀC	ÀC  ÀCÀC   ÀC#ÀDj/// Draws a rounded rectangle with the given [Paint]. Whether the rectangle is
/// filled or stroked (or both) is controlled by [Paint.style].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_rrect.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_rrect_dark.png#gh-dark-mode-only) ÀD§ÀD®  ÀD´ÀD»   ÀDÅHÀEÛ/// Draws a shape consisting of the difference between two rounded rectangles
/// with the given [Paint]. Whether this shape is filled or stroked (or both)
/// is controlled by [Paint.style].
///
/// This shape is almost but not quite entirely unlike an annulus. ÀEæÀEí  ÀEóÀEú  ÀF ÀF   ÀFÇÀG·”/// Draws an axis-aligned oval that fills the given axis-aligned rectangle
/// with the given [Paint]. Whether the oval is filled or stroked (or both) is
/// controlled by [Paint.style].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_oval.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_oval_dark.png#gh-dark-mode-only) ÀGÀ	ÀGÆ  ÀGËÀGÒ   ÀGÜ‚)ÀIÔä/// Draws a circle centered at the point given by the first argument and
/// that has the radius given by the second argument, with the [Paint] given in
/// the third argument. Whether the circle is filled or stroked (or both) is
/// controlled by [Paint.style].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_circle.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_circle_dark.png#gh-dark-mode-only) ÀIßÀIç  ÀIéÀIñ  ÀIøÀIÿ   ÀJ	ƒÛÀMƒc/// Draw an arc scaled to fit inside the given rectangle.
///
/// It starts from `startAngle` radians around the oval up to
/// `startAngle` + `sweepAngle` radians around the oval, with zero radians
/// being the point on the right hand side of the oval that crosses the
/// horizontal line that intersects the center of the rectangle and with positive
/// angles going clockwise around the oval. If `useCenter` is true, the arc is
/// closed back to the center, forming a circle sector. Otherwise, the arc is
/// not closed, forming a circle segment.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_draw_arc.png#gh-light-mode-only)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/canvas_draw_arc_dark.png#gh-dark-mode-only)
///
/// This method is optimized for drawing arcs and should be faster than [Path.arcTo]. ÀM–	ÀMœ  ÀM¡ÀM©  ÀM´ÀM¼  ÀMÇÀMÍ  ÀM×ÀMŞ   ÀMèÀNæ€î/// Draws the given [Path] with the given [Paint].
///
/// Whether this shape is filled or stroked (or both) is controlled by
/// [Paint.style]. If the path is filled, then sub-paths within it are
/// implicitly closed (see [Path.close]). ÀNï	ÀNõ  ÀNúÀO   ÀO€İÀOµ€ /// Draws the given [Image] into the canvas with its top-left corner at the
/// given [Offset]. The image is composited into the canvas using the given [Paint]. ÀO¿ÀOÆ  ÀOÌÀOÔ  ÀOÛÀOâ   ÀOìøÀQ¨¤/// Draws the subset of the given image described by the `src` argument into
/// the canvas in the axis-aligned rectangle given by the `dst` argument.
///
/// This might sample from outside the `src` rect by up to half the width of
/// an applied filter.
///
/// Multiple calls to this method with different arguments (from the same
/// image) can be batched into a single call to [drawAtlas] to improve
/// performance. ÀQ¶ÀQ½  ÀQÃÀQÉ  ÀQÍÀQÓ  ÀQ×ÀQŞ   ÀQèƒQÀTú‚ò/// Draws the given [Image] into the canvas using the given [Paint].
///
/// The image is drawn in nine portions described by splitting the image by
/// drawing two horizontal lines and two vertical lines, where the `center`
/// argument describes the rectangle formed by the four points where these
/// four lines intersect each other. (This forms a 3-by-3 grid of regions,
/// the center region being described by the `center` argument.)
///
/// The four regions in the corners are drawn, without scaling, in the four
/// corners of the destination rectangle described by `dst`. The remaining
/// five regions are drawn by stretching them to fit such that they exactly
/// cover the destination rectangle while maintaining their relative
/// positions. ÀUÀU  ÀUÀU  ÀU"ÀU(  ÀU,ÀU3   ÀU=€‚ÀU¢[/// Draw the given picture onto the canvas. To create a picture, see
/// [PictureRecorder]. ÀU®ÀU·   ÀUÃ„IÀYÚƒé/// Draws the text in the given [Paragraph] into this canvas at the given
/// [Offset].
///
/// The [Paragraph] object must have had [Paragraph.layout] called on it
/// first.
///
/// To align the text, set the `textAlign` on the [ParagraphStyle] object
/// passed to the [ParagraphBuilder.new] constructor. For more details see
/// [TextAlign] and the discussion at [ParagraphStyle.new].
///
/// If the text is left aligned or justified, the left margin will be at the
/// position specified by the `offset` argument's [Offset.dx] coordinate.
///
/// If the text is right aligned or justified, the right margin will be at the
/// position described by adding the [ParagraphConstraints.width] given to
/// [Paragraph.layout], to the `offset` argument's [Offset.dx] coordinate.
///
/// If the text is centered, the centering axis will be at the position
/// described by adding half of the [ParagraphConstraints.width] given to
/// [Paragraph.layout], to the `offset` argument's [Offset.dx] coordinate. ÀYèÀYó  ÀYıÀZ   ÀZôÀ[Â–/// Draws a sequence of points according to the given [PointMode].
///
/// The `points` argument is interpreted as offsets from the origin.
///
/// The `paint` is used for each point ([PointMode.points]) or line
/// ([PointMode.lines] or [PointMode.polygon]), ignoring [Paint.style].
///
/// See also:
///
///  * [drawRawPoints], which takes `points` as a [Float32List] rather than a
///    [List<Offset>]. À[ÍÀ[Ø  À[âÀ[ğ  À[÷À[ş   À\‚OÀ^í/// Draws a sequence of points according to the given [PointMode].
///
/// The `points` argument is interpreted as a list of pairs of floating point
/// numbers, where each pair represents an x and y offset from the origin.
///
/// The `paint` is used for each point ([PointMode.points]) or line
/// ([PointMode.lines] or [PointMode.polygon]), ignoring [Paint.style].
///
/// See also:
///
///  * [drawPoints], which takes `points` as a [List<Offset>] rather than a
///    [List<Float32List>]. À^!À^,  À^6À^C  À^JÀ^Q   À^[†CÀd\…Ã/// Draws a set of [Vertices] onto the canvas as one or more triangles.
///
/// The [Paint.color] property specifies the default color to use for the
/// triangles.
///
/// The [Paint.shader] property, if set, overrides the color entirely,
/// replacing it with the colors from the specified [ImageShader], [Gradient],
/// or other shader.
///
/// The `blendMode` parameter is used to control how the colors in the
/// `vertices` are combined with the colors in the `paint`. If there are no
/// colors specified in `vertices` then the `blendMode` has no effect. If
/// there are colors in the `vertices`, then the color taken from the
/// [Paint.shader] or [Paint.color] in the `paint` is blended with the colors
/// specified in the `vertices` using the `blendMode` parameter. For the
/// purposes of this blending, the colors from the `paint` parameter are
/// considered the source, and the colors from the `vertices` are considered
/// the destination. [BlendMode.dstOver] ignores the `paint` and uses only the
/// colors of the `vertices`; [BlendMode.srcOver] ignores the colors of the
/// `vertices` and uses only the colors in the `paint`.
///
/// All parameters must not be null.
///
/// See also:
///   * [Vertices.new], which creates a set of vertices to draw on the canvas.
///   * [Vertices.raw], which creates the vertices using typed data lists
///     rather than unencoded lists.
///   * [paint], Image shaders can be used to draw images on a triangular mesh. ÀdiÀds  Àd|Àd‡  Àd‘Àd˜   Àd¢–•ÀzB””/// Draws many parts of an image - the [atlas] - onto the canvas.
///
/// This method allows for optimization when you want to draw many parts of an
/// image onto the canvas, such as when using sprites or zooming. It is more efficient
/// than using multiple calls to [drawImageRect] and provides more functionality
/// to individually transform each image part by a separate rotation or scale and
/// blend or modulate those parts with a solid color.
///
/// The method takes a list of [Rect] objects that each define a piece of the
/// [atlas] image to be drawn independently. Each [Rect] is associated with an
/// [RSTransform] entry in the [transforms] list which defines the location,
/// rotation, and (uniform) scale with which to draw that portion of the image.
/// Each [Rect] can also be associated with an optional [Color] which will be
/// composed with the associated image part using the [blendMode] before blending
/// the result onto the canvas. The full operation can be broken down as:
///
/// - Blend each rectangular portion of the image specified by an entry in the
/// [rects] argument with its associated entry in the [colors] list using the
/// [blendMode] argument (if a color is specified). In this part of the operation,
/// the image part will be considered the source of the operation and the associated
/// color will be considered the destination.
/// - Blend the result from the first step onto the canvas using the translation,
/// rotation, and scale properties expressed in the associated entry in the
/// [transforms] list using the properties of the [Paint] object.
///
/// If the first stage of the operation which blends each part of the image with
/// a color is needed, then both the [colors] and [blendMode] arguments must
/// not be null and there must be an entry in the [colors] list for each
/// image part. If that stage is not needed, then the [colors] argument can
/// be either null or an empty list and the [blendMode] argument may also be null.
///
/// The optional [cullRect] argument can provide an estimate of the bounds of the
/// coordinates rendered by all components of the atlas to be compared against
/// the clip to quickly reject the operation if it does not intersect.
///
/// An example usage to render many sprites from a single sprite atlas with no
/// rotations or scales:
///
/// ```dart
/// class Sprite {
///   Sprite(this.index, this.center);
///   int index;
///   Offset center;
/// }
///
/// class MyPainter extends CustomPainter {
///   MyPainter(this.spriteAtlas, this.allSprites);
///
///   // assume spriteAtlas contains N 10x10 sprites side by side in a (N*10)x10 image
///   ui.Image spriteAtlas;
///   List<Sprite> allSprites;
///
///   @override
///   void paint(Canvas canvas, Size size) {
///     Paint paint = Paint();
///     canvas.drawAtlas(spriteAtlas, <RSTransform>[
///       for (final Sprite sprite in allSprites)
///         RSTransform.fromComponents(
///           rotation: 0.0,
///           scale: 1.0,
///           // Center of the sprite relative to its rect
///           anchorX: 5.0,
///           anchorY: 5.0,
///           // Location at which to draw the center of the sprite
///           translateX: sprite.center.dx,
///           translateY: sprite.center.dy,
///         ),
///     ], <Rect>[
///       for (final Sprite sprite in allSprites)
///         Rect.fromLTWH(sprite.index * 10.0, 0.0, 10.0, 10.0),
///     ], null, null, null, paint);
///   }
///
///   // ...
/// }
/// ```
///
/// Another example usage which renders sprites with an optional opacity and rotation:
///
/// ```dart
/// class Sprite {
///   Sprite(this.index, this.center, this.alpha, this.rotation);
///   int index;
///   Offset center;
///   int alpha;
///   double rotation;
/// }
///
/// class MyPainter extends CustomPainter {
///   MyPainter(this.spriteAtlas, this.allSprites);
///
///   // assume spriteAtlas contains N 10x10 sprites side by side in a (N*10)x10 image
///   ui.Image spriteAtlas;
///   List<Sprite> allSprites;
///
///   @override
///   void paint(Canvas canvas, Size size) {
///     Paint paint = Paint();
///     canvas.drawAtlas(spriteAtlas, <RSTransform>[
///       for (final Sprite sprite in allSprites)
///         RSTransform.fromComponents(
///           rotation: sprite.rotation,
///           scale: 1.0,
///           // Center of the sprite relative to its rect
///           anchorX: 5.0,
///           anchorY: 5.0,
///           // Location at which to draw the center of the sprite
///           translateX: sprite.center.dx,
///           translateY: sprite.center.dy,
///         ),
///     ], <Rect>[
///       for (final Sprite sprite in allSprites)
///         Rect.fromLTWH(sprite.index * 10.0, 0.0, 10.0, 10.0),
///     ], <Color>[
///       for (final Sprite sprite in allSprites)
///         Colors.white.withAlpha(sprite.alpha),
///     ], BlendMode.srcIn, null, paint);
///   }
///
///   // ...
/// }
/// ```
///
/// The length of the [transforms] and [rects] lists must be equal and
/// if the [colors] argument is not null then it must either be empty or
/// have the same length as the other two lists.
///
/// See also:
///
///  * [drawRawAtlas], which takes its arguments as typed data lists rather
///    than objects. ÀzLÀzS  ÀzjÀz}  Àz™Àz¥  Àz¼ÀzÊ  ÀzâÀzî  À{	À{  À{*À{1   À{;›À•K˜ä/// Draws many parts of an image - the [atlas] - onto the canvas.
///
/// This method allows for optimization when you want to draw many parts of an
/// image onto the canvas, such as when using sprites or zooming. It is more efficient
/// than using multiple calls to [drawImageRect] and provides more functionality
/// to individually transform each image part by a separate rotation or scale and
/// blend or modulate those parts with a solid color. It is also more efficient
/// than [drawAtlas] as the data in the arguments is already packed in a format
/// that can be directly used by the rendering code.
///
/// A full description of how this method uses its arguments to draw onto the
/// canvas can be found in the description of the [drawAtlas] method.
///
/// The [rstTransforms] argument is interpreted as a list of four-tuples, with
/// each tuple being ([RSTransform.scos], [RSTransform.ssin],
/// [RSTransform.tx], [RSTransform.ty]).
///
/// The [rects] argument is interpreted as a list of four-tuples, with each
/// tuple being ([Rect.left], [Rect.top], [Rect.right], [Rect.bottom]).
///
/// The [colors] argument, which can be null, is interpreted as a list of
/// 32-bit colors, with the same packing as [Color.value]. If the [colors]
/// argument is not null then the [blendMode] argument must also not be null.
///
/// An example usage to render many sprites from a single sprite atlas with no rotations
/// or scales:
///
/// ```dart
/// class Sprite {
///   Sprite(this.index, this.center);
///   int index;
///   Offset center;
/// }
///
/// class MyPainter extends CustomPainter {
///   MyPainter(this.spriteAtlas, this.allSprites);
///
///   // assume spriteAtlas contains N 10x10 sprites side by side in a (N*10)x10 image
///   ui.Image spriteAtlas;
///   List<Sprite> allSprites;
///
///   @override
///   void paint(Canvas canvas, Size size) {
///     // For best advantage, these lists should be cached and only specific
///     // entries updated when the sprite information changes. This code is
///     // illustrative of how to set up the data and not a recommendation for
///     // optimal usage.
///     Float32List rectList = Float32List(allSprites.length * 4);
///     Float32List transformList = Float32List(allSprites.length * 4);
///     for (int i = 0; i < allSprites.length; i++) {
///       Sprite sprite = allSprites[i];
///       final double rectX = sprite.index * 10.0;
///       rectList[i * 4 + 0] = rectX;
///       rectList[i * 4 + 1] = 0.0;
///       rectList[i * 4 + 2] = rectX + 10.0;
///       rectList[i * 4 + 3] = 10.0;
///
///       // This example sets the RSTransform values directly for a common case of no
///       // rotations or scales and just a translation to position the atlas entry. For
///       // more complicated transforms one could use the RSTransform class to compute
///       // the necessary values or do the same math directly.
///       transformList[i * 4 + 0] = 1.0;
///       transformList[i * 4 + 1] = 0.0;
///       transformList[i * 4 + 2] = sprite.center.dx - 5.0;
///       transformList[i * 4 + 3] = sprite.center.dy - 5.0;
///     }
///     Paint paint = Paint();
///     canvas.drawRawAtlas(spriteAtlas, transformList, rectList, null, null, null, paint);
///   }
///
///   // ...
/// }
/// ```
///
/// Another example usage which renders sprites with an optional opacity and rotation:
///
/// ```dart
/// class Sprite {
///   Sprite(this.index, this.center, this.alpha, this.rotation);
///   int index;
///   Offset center;
///   int alpha;
///   double rotation;
/// }
///
/// class MyPainter extends CustomPainter {
///   MyPainter(this.spriteAtlas, this.allSprites);
///
///   // assume spriteAtlas contains N 10x10 sprites side by side in a (N*10)x10 image
///   ui.Image spriteAtlas;
///   List<Sprite> allSprites;
///
///   @override
///   void paint(Canvas canvas, Size size) {
///     // For best advantage, these lists should be cached and only specific
///     // entries updated when the sprite information changes. This code is
///     // illustrative of how to set up the data and not a recommendation for
///     // optimal usage.
///     Float32List rectList = Float32List(allSprites.length * 4);
///     Float32List transformList = Float32List(allSprites.length * 4);
///     Int32List colorList = Int32List(allSprites.length);
///     for (int i = 0; i < allSprites.length; i++) {
///       Sprite sprite = allSprites[i];
///       final double rectX = sprite.index * 10.0;
///       rectList[i * 4 + 0] = rectX;
///       rectList[i * 4 + 1] = 0.0;
///       rectList[i * 4 + 2] = rectX + 10.0;
///       rectList[i * 4 + 3] = 10.0;
///
///       // This example uses an RSTransform object to compute the necessary values for
///       // the transform using a factory helper method because the sprites contain
///       // rotation values which are not trivial to work with. But if the math for the
///       // values falls out from other calculations on the sprites then the values could
///       // possibly be generated directly from the sprite update code.
///       final RSTransform transform = RSTransform.fromComponents(
///         rotation: sprite.rotation,
///         scale: 1.0,
///         // Center of the sprite relative to its rect
///         anchorX: 5.0,
///         anchorY: 5.0,
///         // Location at which to draw the center of the sprite
///         translateX: sprite.center.dx,
///         translateY: sprite.center.dy,
///       );
///       transformList[i * 4 + 0] = transform.scos;
///       transformList[i * 4 + 1] = transform.ssin;
///       transformList[i * 4 + 2] = transform.tx;
///       transformList[i * 4 + 3] = transform.ty;
///
///       // This example computes the color value directly, but one could also compute
///       // an actual Color object and use its Color.value getter for the same result.
///       // Since we are using BlendMode.srcIn, only the alpha component matters for
///       // these colors which makes this a simple shift operation.
///       colorList[i] = sprite.alpha << 24;
///     }
///     Paint paint = Paint();
///     canvas.drawRawAtlas(spriteAtlas, transformList, rectList, colorList, BlendMode.srcIn, null, paint);
///   }
///
///   // ...
/// }
/// ```
///
/// See also:
///
///  * [drawAtlas], which takes its arguments as objects rather than typed
///    data lists. À•XÀ•_  À•yÀ•†  À•¨À•µ  À•ÏÀ•Û  À•öÀ–  À– À–'  À–DÀ–K   À–U8À—>€×/// Draws a shadow for a [Path] representing the given material elevation.
///
/// The `transparentOccluder` argument should be true if the occluding object
/// is not opaque.
///
/// The arguments must not be null. À—I	À—O  À—TÀ—[  À—aÀ—i  À—sÀ—y    À—‘À HòÀ—œ  À—á¯ À—ıÀ˜
 À˜À˜  À˜'À˜.  À—áÀ—âÀ—èÀ—ùÀ—éÀ›q!À›‰   BÀ™”€ÜÀš  ÀšÀš1  Àš:ÀšB  ÀšG
ÀšO  ÀšSÀš[  ÀšaÀši  À™”À™•À™›À™àÀ™¡À™œÀ™©À™ßÀ™ªÀ™²À™¹À™¾À™ºÀ™ÁÀ™ÉÀ™ÑÀ™ÙÀ™áÀ™úÀ™èÀ™âÀ™êÀ›—oÀ›ÿ   À›—À›˜À›£À›¤À›ªÀ›ÇÀ›°À›«À›¸À›ÆÀ›¹À›ÀÀ›ÅÀ›ÁÀ›ÈÀ›íÀ›ÏÀ›ÉÀ›ÑÀ›çÀ›áÀ›éÀœ
-Àœ  Àœ%Àœ,  Àœ3Àœ:  Àœ
ÀœÀ;€¹À«  ÀÃÀÓ  ÀàÀê  À;À<ÀBÀoÀHÀCÀPÀnÀQÀXÀ]ÀYÀ`ÀhÀpÀ™ÀwÀqÀyÀø€õÀ{  À†À  À“
À›  ÀŸÀ§  À­Àµ  À¼ÀÌ  ÀÙÀã  ÀøÀùÀÿÀLÀÀ ÀÀKÀÀÀÀÀÀ%À-À5À=ÀEÀMÀiÀTÀNÀVÀñuÀŸ\   ÀñÀòÀıÀşÀŸÀŸ!ÀŸ
ÀŸÀŸÀŸ ÀŸÀŸÀŸÀŸÀŸ"ÀŸJÀŸ)ÀŸ#ÀŸ+ÀŸDÀŸ>ÀŸFÀŸj€“ÀŸã  ÀŸò	ÀŸ÷  ÀŸjÀŸkÀŸvÀŸwÀŸ}ÀŸ¡ÀŸƒÀŸ~ÀŸ‹ÀŸ ÀŸŒÀŸ“ÀŸ˜ÀŸ”ÀŸ›ÀŸ¢ÀŸÑÀŸ©ÀŸ£ÀŸ«ÀŸËÀŸÅÀŸÍÀ À q   À À À À À À 2À À À #À 1À $À +À 0À ,À 3À `À :À 4À <À ZÀ TÀ \À „€À¡  À¡	À¡  À¡	À¡  À „À …À À ‘À —À ÄÀ À ˜À ¥À ÃÀ ¦À ­À ²À ®À µÀ ½À ÅÀ ïÀ ÌÀ ÆÀ ÎÀ éÀ ãÀ ëÀ¡%HÀ¡6  À¡<	À¡D  À¡H
À¡Q  À¡%À¡&À¡q€ŠÀ¡Ş  À¡å	À¡í  À¡ğ	À¡ø  À¡qÀ¡rÀ¡xÀ¡¥À¡~À¡yÀ¡†À¡¤À¡‡À¡À¡“À¡À¡–À¡À¡¦À¡ÌÀ¡­À¡§À¡¯À¡ÆÀ¡ÀÀ¡ÈÀ¡ÿ€‰À¢q  À¢xÀ¢€  À¡ÿÀ¢ À¢À¢À¢À¢7À¢À¢À¢ À¢6À¢!À¢(À¢-À¢)À¢0À¢8À¢_À¢?À¢9À¢AÀ¢YÀ¢SÀ¢[À¢Œ€“À£  À£		À£  À£	À£  À¢ŒÀ¢À¢˜À¢™À¢ŸÀ¢ÌÀ¢¥À¢ À¢­À¢ËÀ¢®À¢µÀ¢ºÀ¢¶À¢½À¢ÅÀ¢ÍÀ¢òÀ¢ÔÀ¢ÎÀ¢ÖÀ¢ìÀ¢æÀ¢îÀ£#€²À£4  À£>À£K  À£#À£$À£Ù{À¤4  À¤?À¤L  À£ÙÀ£ÚÀ£àÀ¤À£æÀ£áÀ£îÀ¤À£ïÀ£öÀ£ûÀ£÷À£şÀ¤À¤"À¤À¤À¤À¤X€À¤p   À¤XÀ¤YÀ¤é€À¥G  À¥UÀ¥b  À¤éÀ¤êÀ¤ğÀ¥À¤öÀ¤ñÀ¤şÀ¥À¤ÿÀ¥À¥À¥À¥À¥À¥5À¥À¥À¥À¥n€áÀ¥  À¥ˆ	À¥  À¥• À¥  À¥·À¥½  À¥nÀ¥oÀ¥¥À¥«À¥¬À¥ÊÀ¦S€ëÀ¦à  À¦êÀ¦ò  À¦÷
À¦ÿ  À§À§  À§À§  À§ 
À§%  À§,À§2  À¦SÀ¦TÀ¦ZÀ¦¤À¦`À¦[À¦hÀ¦£À¦iÀ¦pÀ¦uÀ¦qÀ¦xÀ¦€À¦ˆÀ¦À¦˜À¦ŸÀ¦¥À¦ÎÀ¦¬À¦¦À¦®À¦ÈÀ¦ÂÀ¦ÊÀ§B€œÀ§S  À§]À§d  À§kÀ§q  À§BÀ§CÀ§~À§â€‘À¨C  À¨NÀ¨[  À¨aÀ¨g  À§âÀ§ãÀ§éÀ¨À§ïÀ§êÀ§÷À¨À§øÀ§ÿÀ¨À¨ À¨À¨À¨À¨1À¨À¨À¨À¨wvÀ¨ˆ  À¨‘	À¨—  À¨À¨£  À¨wÀ¨xÀ¨°À¨ñ€•À©X  À©bÀ©o  À©tÀ©z  À¨ñÀ¨òÀ¨øÀ©*À¨şÀ¨ùÀ©À©)À©À©À©À©À©À©À©"À©À©%À©+À©FÀ©2À©,À©4À©Š€ÁÀ©›   À©ŠÀ©‹ÀªO€ŒÀª³  ÀªÇÀªÔ  ÀªOÀªPÀªVÀª{Àª\ÀªWÀªdÀªzÀªeÀªlÀªqÀªmÀªtÀª|Àª¡ÀªƒÀª}Àª…Àªß€ÍÀªğ   ÀªßÀªàÀ«°€˜À¬  À¬4À¬A  À«°À«±À«·À«ÜÀ«½À«¸À«ÅÀ«ÛÀ«ÆÀ«ÍÀ«ÒÀ«ÎÀ«ÕÀ«İÀ¬À«äÀ«ŞÀ«æÀ¬LpÀ¬]  À¬gÀ¬n  À¬tÀ¬  À¬LÀ¬MÀ¬À€•À­0  À­;	À­@  À­FÀ­K  À¬ÀÀ¬ÁÀ¬ÇÀ¬óÀ¬ÍÀ¬ÈÀ¬ÕÀ¬òÀ¬ÖÀ¬İÀ¬âÀ¬ŞÀ¬åÀ¬íÀ¬ôÀ­À¬ûÀ¬õÀ¬ıÀ­À­À­À­Y€ÊÀ­j  À­s	À­{  À­~	À­†  À­‰À­  À­YÀ­ZÀ®'€éÀ®©  À®³	À®»  À®¾	À®Æ  À®É	À®Ñ  À®Ô	À®Ü  À®ßÀ®ï  À®üÀ¯  À®'À®(À®.À®{À®4À®/À®<À®zÀ®=À®DÀ®IÀ®EÀ®LÀ®TÀ®\À®dÀ®lÀ®tÀ®|À®—À®ƒÀ®}À®…À¯ZÀ¯%  À¯/À¯6  À¯À¯À¯r€ŸÀ¯Õ  À¯àÀ¯ğ  À¯ıÀ°  À¯rÀ¯sÀ¯yÀ¯¦À¯À¯zÀ¯‡À¯¥À¯ˆÀ¯À¯”À¯À¯—À¯ŸÀ¯§À¯ÃÀ¯®À¯¨À¯°À°€±À°&  À°/	À°5  À°:À°A  À°À°À°Ê€óÀ±L  À±VÀ±^  À±c
À±k  À±oÀ±w  À±}À±…  À±ŒÀ±œ  À±©À±³  À°ÊÀ°ËÀ°ÑÀ±À°×À°ÒÀ°ßÀ±À°àÀ°çÀ°ìÀ°èÀ°ïÀ°÷À°ÿÀ±À±À±À±À±:À±&À± À±(À±Á€À±Ò  À±ÜÀ±ã  À±éÀ±ğ  À±ÁÀ±ÂÀ²c€ºÀ²Î  À²ÙÀ²æ  À²ìÀ²ü  À³	À³  À²cÀ²dÀ²jÀ²ŸÀ²pÀ²kÀ²xÀ²À²yÀ²€À²…À²À²ˆÀ²À²˜À² À²¼À²§À²¡À²©À³!€äÀ³2  À³=À³D  À³JÀ³Q  À³WÀ³^  À³!À³"À´	€×À´}  À´‰À´–  À´œÀ´©  À´¯À´¿  À´ÌÀ´Ö  À´	À´
À´À´MÀ´À´À´À´LÀ´À´&À´+À´'À´.À´6À´>À´FÀ´NÀ´kÀ´UÀ´OÀ´WÀ´ä€±À´õ  À´ş	Àµ  Àµ	Àµ  À´äÀ´åÀµ™€óÀ¶  À¶%À¶-  À¶2
À¶:  À¶>À¶F  À¶LÀ¶T  À¶[À¶k  À¶xÀ¶‚  Àµ™ÀµšÀµ ÀµíÀµ¦Àµ¡Àµ®ÀµìÀµ¯Àµ¶Àµ»Àµ·Àµ¾ÀµÆÀµÎÀµÖÀµŞÀµæÀµîÀ¶	ÀµõÀµïÀµ÷À¶€¨À¶¡  À¶¬À¶´  À¶¶À¶¾  À¶ÅÀ¶Ì  À¶À¶‘À·<€ÜÀ·¸  À·ÄÀ·Ì  À·ÎÀ·Ö  À·ØÀ·à  À·çÀ·÷  À¸À¸  À·<À·=À·CÀ·ˆÀ·IÀ·DÀ·QÀ·‡À·RÀ·YÀ·^À·ZÀ·aÀ·iÀ·qÀ·yÀ·À·‰À·¦À·À·ŠÀ·’À¸À¸-  À¸5	À¸;  À¸@À¸H  À¸SÀ¸[  À¸fÀ¸l  À¸vÀ¸}  À¸À¸À¹(tÀ¹¿  	À¹ÏÀ¹×  À¹â
À¹ê  À¹ôÀ¹ü  ÀºÀº  ÀºÀº%  Àº6Àº>  ÀºOÀºU  ÀºeÀºu  ÀºˆÀº’  À¹(À¹)À¹/À¹’À¹5À¹0À¹=À¹‘À¹>À¹EÀ¹JÀ¹FÀ¹MÀ¹UÀ¹]À¹eÀ¹mÀ¹uÀ¹}À¹ƒÀ¹‹À¹“À¹­À¹šÀ¹”À¹œÀº xÀº±  Àºº	ÀºÀ  ÀºÅÀºÌ  Àº Àº¡À»€¾À»  À»—À»¤  À»©À»¹  À»ÆÀ»Ğ  À»À»À»#À»_À»)À»$À»1À»^À»2À»9À»>À»:À»AÀ»HÀ»MÀ»IÀ»PÀ»XÀ»`À»{À»gÀ»aÀ»iÀ»Ş~À»ï  À»ùÀ¼   À¼À¼  À¼À¼  À»ŞÀ»ßÀ½`À½î  À½ùÀ¾  À¾À¾  À¾À¾  À¾À¾+  À¾8À¾B  À¾LÀ¾Q  À½`À½aÀ½gÀ½¼À½oÀ½hÀ½wÀ½»À½xÀ½À½„À½€À½‡À½À½“À½À½–À½À½¦À½®À½¶À½½À½ÙÀ½ÄÀ½¾À½ÆÀ¾hƒ¦À¾y  À¾‡À¾  À¾”À¾š  À¾À¾¤  À¾¨À¾¯  À¾hÀ¾iÀÂõÀÂÔ  ÀÂêÀÂò  ÀÂşÀÃ  ÀÃÀÃ  ÀÃ)ÀÃ1  ÀÃ@ÀÃH  ÀÃXÀÃ`  ÀÃnÀÃv  ÀÃƒÀÃ‹  ÀÃšÀÃ¢  ÀÃ²ÀÃÂ  ÀÃÕÀÃß  ÀÃïÀÃô   ÀÂÀÂÀÂÀÂÀÂ!ÀÂÀÂ)ÀÂÀÂ*ÀÂ1ÀÂ6ÀÂ2ÀÂ9ÀÂ@ÀÂEÀÂAÀÂHÀÂPÀÂXÀÂ`ÀÂhÀÂpÀÂxÀÂ€ÀÂˆÀÂÀÂ˜ÀÂŸÀÂ¿ÀÂ¦ÀÂ ÀÂ¨ÀÄƒ¸ÀÄ  ÀÄ*ÀÄ1  ÀÄ7ÀÄ=  ÀÄDÀÄJ  ÀÄNÀÄU  ÀÄÀÄÀÇÇ‚ÀÈ‰  ÀÈŸÀÈ§  ÀÈ³ÀÈ»  ÀÈÌÀÈÔ  ÀÈäÀÈì  ÀÈşÀÉ  ÀÉÀÉ!  ÀÉ/ÀÉ7  ÀÉDÀÉL  ÀÉ[ÀÉc  ÀÉsÀÉƒ  ÀÉ–ÀÉ   ÀÉ°ÀÉµ   ÀÇÇÀÇÈÀÇÎÀÈSÀÇÖÀÇÏÀÇŞÀÈRÀÇßÀÇæÀÇëÀÇçÀÇîÀÇõÀÇúÀÇöÀÇıÀÈÀÈÀÈÀÈÀÈ%ÀÈ-ÀÈ5ÀÈ=ÀÈEÀÈMÀÈTÀÈtÀÈ[ÀÈUÀÈ]ÀÉÌ€„ÀÉİ  ÀÉéÀÉò  ÀÉÌÀÉÍÀÊT€‰ÀÊ¸  ÀÊÅÀÊÕ  ÀÊTÀÊUÀÊ[ÀÊ‡ÀÊaÀÊ\ÀÊiÀÊ†ÀÊjÀÊqÀÊvÀÊrÀÊyÀÊ€ÀÊ…ÀÊÀÊˆÀÊ¦ÀÊÀÊ‰ÀÊ‘ÀÊáGÀÊò  ÀË ÀË  ÀËÀË  ÀÊáÀÊâÀÌ,€±ÀÌ=  ÀÌHÀÌS  ÀÌ]ÀÌk  ÀÌrÀÌy  ÀÌ,ÀÌ-ÀÌáÀÌò  ÀÍ ÀÍ  ÀÍÀÍ"  ÀÍ)ÀÍ0  ÀÌáÀÌâÀÍù€ÓÀÎl  ÀÎxÀÎˆ  ÀÎ•ÀÎŸ  ÀÎ©ÀÎ®  ÀÎ¸ÀÎÅ  ÀÍùÀÍúÀÎ ÀÎ<ÀÎÀÎÀÎÀÎ;ÀÎÀÎÀÎÀÎÀÎÀÎ&ÀÎ.ÀÎ5ÀÎ=ÀÎZÀÎDÀÎ>ÀÎFÀÎĞ€ÈÀÎá  ÀÎîÀÎø  ÀÏÀÏ  ÀÏÀÏ  ÀÎĞÀÎÑÀÏœ€İÀĞ  ÀĞ&ÀĞ0  ÀĞ9ÀĞ>  ÀĞHÀĞX  ÀĞeÀĞo  ÀÏœÀÏÀÏ£ÀÏæÀÏ©ÀÏ¤ÀÏ±ÀÏåÀÏ²ÀÏ¹ÀÏ¾ÀÏºÀÏÁÀÏÈÀÏÍÀÏÉÀÏĞÀÏ×ÀÏßÀÏçÀĞÀÏîÀÏèÀÏğÀĞ}ˆ"ÀĞ  ÀĞ˜ÀĞŸ  ÀĞ¶ÀĞÉ  ÀĞåÀĞñ  ÀÑÀÑ  ÀÑ.ÀÑ:  ÀÑUÀÑ\  ÀÑvÀÑ}  ÀĞ}ÀĞ~ÀØ£„§ÀØ´  ÀØÁÀØÈ  ÀØâÀØï  ÀÙÀÙ  ÀÙ8ÀÙD  ÀÙ_ÀÙk  ÀÙ‰ÀÙ  ÀÙ­ÀÙ´  ÀØ£ÀØ¤ÀİN¥Àİó  	ÀŞÀŞ  ÀŞ(ÀŞ2  ÀŞBÀŞG  ÀŞ`ÀŞh  ÀŞtÀŞ  ÀŞ•ÀŞ¢  ÀŞ®ÀŞº  ÀŞÇÀŞÌ  ÀŞÜÀŞê  ÀİNÀİOÀİUÀİÁÀİ]ÀİVÀİeÀİÀÀİfÀİmÀİrÀİnÀİuÀİ}Àİ…ÀİŒÀİ“Àİ˜Àİ”Àİ›Àİ£Àİ«Àİ³ÀİºÀİÂÀİŞÀİÉÀİÃÀİËÀŞ÷€¸Àß  Àß	Àß  ÀßÀß%  Àß+Àß3  Àß=ÀßC  ÀŞ÷ÀŞøÀß³€ÎÀà,  Àà8ÀàE  ÀàJ	ÀàO  ÀàUÀà]  ÀàgÀàm  Àß³Àß´ÀßºÀßüÀßÀÀß»ÀßÈÀßûÀßÉÀßĞÀßÕÀßÑÀßØÀßßÀßäÀßàÀßçÀßïÀß÷ÀßıÀàÀàÀßşÀà ÀàóŠ¸ÀâQN/// An object representing a sequence of recorded graphical operations.
///
/// To create a [Picture], use a [PictureRecorder].
///
/// A [Picture] can be placed in a [Scene] using a [SceneBuilder], via
/// the [SceneBuilder.addPicture] method. A [Picture] can also be
/// drawn into a [Canvas], using the [Canvas.drawPicture] method.  Àâ]Àãm€è/// A callback that is invoked to report a picture creation.
///
/// It's preferred to use [MemoryAllocations] in flutter/foundation.dart
/// than to use [onCreate] directly because [MemoryAllocations]
/// allows multiple callbacks. ÀãzÀä€ë/// A callback that is invoked to report the picture disposal.
///
/// It's preferred to use [MemoryAllocations] in flutter/foundation.dart
/// than to use [onDispose] directly because [MemoryAllocations]
/// allows multiple callbacks. Àéï€ÇÀê¨€§/// Whether this reference to the underlying picture is [dispose]d.
///
/// This only returns a valid value if asserts are enabled, and must not be
/// used otherwise.   Àêº€ïÀë”€É/// Returns the approximate number of bytes allocated for this object.
///
/// The actual size of this picture may be larger, particularly if it contains
/// references to image or other large objects.   Àä›DÀåÀ/// Creates an image from this picture.
///
/// The returned image will be `width` pixels wide and `height` pixels high.
/// The picture is rasterized within the 0 (left), 0 (top), `width` (right),
/// `height` (bottom) bounds. Content outside these bounds is clipped. ÀåÈ	ÀåÍ  ÀåÓ
ÀåØ   Àåãƒ‚ÀéBƒ6/// Synchronously creates a handle to an image of this picture.
///
/// {@template dart.ui.painting.Picture.toImageSync}
/// The returned image will be `width` pixels wide and `height` pixels high.
/// The picture is rasterized within the 0 (left), 0 (top), `width` (right),
/// `height` (bottom) bounds. Content outside these bounds is clipped.
///
/// The image object is created and returned synchronously, but is rasterized
/// asynchronously. If the rasterization fails, an exception will be thrown
/// when the image is drawn to a [Canvas].
///
/// If a GPU context is available, this image will be created as GPU resident
/// and not copied back to the host. This means the image will be more
/// efficient to draw.
///
/// If no GPU context is available, the image will be rasterized on the CPU.
/// {@endtemplate} ÀéN	ÀéS  ÀéY
Àé^   Àéi€‚Àéán/// Release the resources used by this object. The object is no longer usable
/// after this method is called.    Àë­ˆÁÀëÒ  Àì€ÑÀìåÀìæÀìç€™/// This class is created by the engine, and should not be instantiated
/// or extended directly.
///
/// To create a [Picture], use a [PictureRecorder]. Àì»Àì¼ÀìÂÀìÓÀìÃÀòÈÀòÍ ÀòÙÀòã€õÀòø   ÀòãÀòäÀóÜ€ÀôW   ÀóÜÀóİÀóèÀóéÀóïÀôÀó÷ÀóğÀóÿÀôÀô ÀôÀôÀôÀôÀôBÀôÀôÀôÀô<Àô6Àô>Àìî½Àí  Àí	Àí  Àí
Àí   ÀìîÀìïÀî¯€°Àï  Àï'	Àï,  Àï2
Àï7  Àï>ÀïV  Àî¯Àî°Àî¶ÀîíÀî¾Àî·ÀîÆÀîìÀîÇÀîÎÀîÓÀîÏÀîÖÀîŞÀîæÀîîÀï	ÀîõÀîïÀî÷Àïc5Àïu  Àï	Àï†  ÀïŒ
Àï‘  ÀïcÀïdÀğœ€£Àñ
  Àñ	Àñ  Àñ"
Àñ'  Àñ.Àñ6  ÀğœÀğÀğ£ÀğØÀğ©Àğ¤Àğ±Àğ×Àğ²Àğ¹Àğ¾ÀğºÀğÁÀğÉÀğÑÀğÙÀğøÀğàÀğÚÀğâÀñC€°ÀñT   ÀñCÀñDÀñ÷€ÍÀò¹k/// This can't be a leaf call because the native function calls Dart API
/// (Dart_SetNativeInstanceField).  ÀògÀòhÀònÀò‹ÀòtÀòoÀò|ÀòŠÀò}Àò„Àò‰Àò…ÀòŒÀò§Àò“ÀòÀò•Àë­Àë®Àë´ÀëÅÀëµÀôp„ÀõT€Ô/// Records a [Picture] containing a sequence of graphical operations.
///
/// To begin recording, construct a [Canvas] to record the commands.
/// To end recording, use the [PictureRecorder.endRecording] method. Àõh€× ÀöÀö#€/// Creates a new idle PictureRecorder. To associate it with a
/// [Canvas] and begin recording, pass this [PictureRecorder] to the
/// [Canvas] constructor.   ÀöC™À÷Ğu/// Whether this object is currently recording commands.
///
/// Specifically, this returns true if a [Canvas] object has been
/// created to record commands and recording has not yet ended via a
/// call to [endRecording], and false if either this
/// [PictureRecorder] has not yet been associated with a [Canvas],
/// or the [endRecording] method has already been called.   À÷à,Àøı
/// Finishes recording graphical operations.
///
/// Returns a picture containing the graphical operations that have been
/// recorded thus far. After calling this function, both the picture recorder
/// and the canvas objects are invalid and cannot be used further.    ÀùƒâÀù  ÀùrH ÀùÀù¤  ÀùrÀùsÀùyÀùŠÀùzÀüÙÀüè  Àú#4Àú8   Àú#Àú$Àù¾aÀú   Àù¾Àù¿ÀùÅÀùÛÀùËÀùÆÀùÓÀùÚÀùÔÀùÜÀùşÀùãÀùİÀùåÀú[æÀúo   Àú[Àú\ÀüE€Àü¬  ÀüºÀüÊ  ÀüEÀüFÀüLÀüqÀüRÀüMÀüZÀüpÀü[ÀübÀügÀücÀüjÀürÀüšÀüyÀüsÀü{ Àüô›ÀıOT/// A single shadow.
///
/// Multiple shadows are stacked together in a [TextStyle]. ÀıZ‚P ÀşåÀşëp/// Construct a shadow.
///
/// The default shadow is a black shadow with zero offset and zero blur.
/// Default shadows should be completely covered by the casting element,
/// and not be visible.
///
/// Transparency should be adjusted through the [color] alpha.
///
/// Shadow order matters due to compositing multiple translucent objects not
/// being commutative.Àşò(Àşø  Àÿ Àÿ&  Àÿ?ÀÿE  ÀşÿÀÿÀÿ
ÀÿÀÿÀÿ.Àÿ4Àÿ5ÀÿQÀÿ]ÀÿcÀÿuÀÿ¨ÀÿoÀÿdÀÿrÀÿw	Àÿ®,Àÿ¿ ÀÿĞÀ &À  À &À ,'À = À OÀ MÀ RÀ W#À h À vÀ tÀ yÀ ~#À  À À ›À  À ¥&À ¶ À ÇÀ ÅÀ ÊÀ Ğ€¼À‡€¢/// Color that the shadow will be drawn with.
///
/// The shadows are shapes composited directly over the base canvas, and do not
/// represent optical occlusion. À‘4À¿/// The displacement of the shadow from the casting element.
///
/// Positive x/y offsets will shift the shadow to the right and down, while
/// negative offsets shift the shadow to the left and up. The offsets are
/// relative to the position of the element that is casting it. ÀÊiÀ)O/// The standard deviation of the Gaussian to convolve with the shadow's shape. À¸€®À8n/// The [blurRadius] in sigmas instead of logical pixels.
///
/// See the sigma argument to [MaskFilter.blur].   ÀÏGÀã   ÀÏÀĞÀ8|ÀWh/// Converts a blur radius in pixels to sigmas.
///
/// See the sigma argument to [MaskFilter.blur].
/// ÀlÀt   Àj‚‹Àzõ/// Create the [Paint] object that corresponds to this shadow description.
///
/// The [offset] is not represented in the [Paint] object.
/// To honor this as well, the shape should be translated by [offset] before
/// being filled using this [Paint].
///
/// This class does not provide a way to disable shadows to avoid
/// inconsistencies in shadow blur rendering, primarily as a method of
/// reducing test flakiness. [toPaint] should be overridden in subclasses to
/// provide this functionality.   Àù€õÀ`[/// Returns a new shadow with its [offset] and [blurRadius] scaled by the given
/// factor. ÀfÀn   Àò…×ÀüƒÔ/// Linearly interpolate between two shadows.
///
/// If either shadow is null, this function linearly interpolates from
/// a shadow that matches the other shadow in color but has a zero
/// offset and a zero blurRadius.
///
/// {@template dart.ui.shadow.lerp}
/// The `t` argument represents position on the timeline, with 0.0 meaning
/// that the interpolation has not started, returning `a` (or something
/// equivalent to `a`), 1.0 meaning that the interpolation has finished,
/// returning `b` (or something equivalent to `b`), and values in between
/// meaning that the interpolation is at the relevant point on the timeline
/// between `a` and `b`. The interpolation can be extrapolated beyond 0.0 and
/// 1.0, so negative values and values greater than 1.0 are valid (and can
/// easily be generated by curves such as [Curves.elasticInOut]).
///
/// Values for `t` are usually obtained from an [Animation<double>], such as
/// an [AnimationController].
/// {@endtemplate} À	À
  À	À  ÀÀ   ÀÍƒÀ’€¥/// Linearly interpolate between two lists of shadows.
///
/// If the lists differ in length, excess items are lerped with null.
///
/// {@macro dart.ui.shadow.lerp} À›Àª  À¬À»  À½ÀÅ   ÀØ€óÀò  ÀõÀı  ÀØÀÙÀÔƒÓÀä  ÀóÀ   À«LÀ¾   À«À¬ ÀûÌÀ¶€¯/// A handle to a read-only byte buffer that is managed by the engine.
///
/// The creator of this object is responsible for calling [dispose] when it is
/// no longer needed. Àë ÀúÀûÀü ÀıÀ   À!şÀ"  À"À" À"$À!­NÀ!é1/// The length, in bytes, of the underlying data.   À".À"·y/// Whether [dispose] has been called.
///
/// This must only be used when asserts are enabled. Otherwise, it will throw.   ÀgÀ‘^/// Creates a copy of the data from a [Uint8List] suitable for internal use
/// in the engine. ÀŸÀª   ÀzƒGÀr/// Create a buffer from the asset with key [assetKey].
///
/// Throws an [Exception] if the asset does not exist. ÀÀ$   ÀÅ÷ÀTi/// Create a buffer from the file with [path].
///
/// Throws an [Exception] if the asset does not exist. ÀaÀi   ÀÀ€•À %  À +À 6  À ;À L  ÀÀÀÁÀÇÀïÀÏÀÈÀ×ÀîÀØÀàÀèÀğÀ À÷ÀñÀùÀ Y€§À Ç  À ÖÀ Ş  À çÀ ÷  À YÀ ZÀ `À ˆÀ hÀ aÀ pÀ ‡À qÀ yÀ À ‰À ²À À ŠÀ ’À!€¥À!q  À!À!‡  À!À!   À!À!À!À!3À!À!À!À!2À!À!$À!,À!4À!\À!;À!5À!=À#I‚£À%d‚/// Release the resources used by this object. The object is no longer usable
/// after this method is called.
///
/// The underlying memory allocated by this object will be retained beyond
/// this call if it is still needed by another object that has not been
/// disposed. For example, an [ImageDescriptor] that has not been disposed
/// may still retain a reference to the memory from this buffer even if it
/// has been disposed. Freeing that memory requires disposing all resources
/// that may still hold it.   À%ğ€ÕÀ&ºk/// This can't be a leaf call because the native function calls Dart API
/// (Dart_SetNativeInstanceField).  À&`À&aÀ&gÀ&„À&mÀ&hÀ&uÀ&ƒÀ&vÀ&}À&‚À&~À&…À&¨À&ŒÀ&†À& À&É‰‰À'€µ/// A descriptor of data that can be turned into an [Image] via a [Codec].
///
/// Use this class to determine the height, width, and byte size of image data
/// before decoding it. À'¢‚çÀ)ÙÀ)ÚÀ)İĞ/// Creates an image descriptor from raw image pixels.
///
/// The `pixels` parameter is the pixel data. They are packed in bytes in the
/// order described by `pixelFormat`, then grouped in rows, from left to right,
/// then top to bottom.
///
/// The `rowBytes` parameter is the number of bytes consumed by each row of
/// pixels in the data buffer. If unspecified, it defaults to `width` multiplied
/// by the number of bytes per pixel in the provided `format`.À)ãÀ)ô  À*À*  À*À*'  À*2À*8  À*E À*[    À+ôyÀ,gd/// The width, in pixels, of the image.
///
/// On the Web, this is only supported for [raw] images.   À,q{À,åe/// The height, in pixels, of the image.
///
/// On the Web, this is only supported for [raw] images.   À,ğ€…À-gh/// The number of bytes per pixel in the image.
///
/// On web, this is only supported for [raw] images.   À*cÀ*÷H/// Creates an image descriptor from encoded data in a supported format. À*ÿÀ+   À-y€øÀ.g€Ş/// Release the resources used by this object. The object is no longer usable
/// after this method is called.
///
/// This can't be a leaf call because the native function calls Dart API
/// (Dart_SetNativeInstanceField).   À.uÛÀ0‚/// Creates a [Codec] object which is suitable for decoding the data in the
/// buffer to an [Image].
///
/// If only one of targetWidth or  targetHeight are specified, the other
/// dimension will be scaled according to the aspect ratio of the supplied
/// dimension.
///
/// If either targetWidth or targetHeight is less than or equal to zero, it
/// will be treated as if it is null. À0*À00  À0<À0B    À0TŒêÀ0_  À0¶À0ÌÀ0ÍÀ0Î   À0Õƒ£À3À3À3Ğ/// Creates an image descriptor from raw image pixels.
///
/// The `pixels` parameter is the pixel data. They are packed in bytes in the
/// order described by `pixelFormat`, then grouped in rows, from left to right,
/// then top to bottom.
///
/// The `rowBytes` parameter is the number of bytes consumed by each row of
/// pixels in the data buffer. If unspecified, it defaults to `width` multiplied
/// by the number of bytes per pixel in the provided `format`.À3À3&  À33À3A  À3KÀ3Y  À3dÀ3j  À3w À3   À6*À6/  À6èÀ6í  À7¬À7±  À6°4À6Ä   À6°À6±À7q7À7…   À7qÀ7rÀ8JLÀ8^   À8JÀ8KÀ4|€²À4ï  À4üÀ5  À5À5%  À4|À4}À4ƒÀ4²À4‹À4„À4“À4±À4”À4œÀ4£À4¨À4¤À4«À4³À4ÚÀ4ºÀ4´À4¼À52€ôÀ5°  À5¹À5Ê  À5ØÀ5é  À5ğ	À5õ  À5û
À6   À6À6  À6À6  À52À53À59À5sÀ5?À5:À5GÀ5rÀ5HÀ5PÀ5XÀ5_À5fÀ5mÀ5tÀ5—À5{À5uÀ5}À6:rÀ6    À6:À6;À6AÀ6_À6HÀ6BÀ6PÀ6^À6QÀ6XÀ6]À6YÀ6`À6À6gÀ6aÀ6iÀ6‰À6ƒÀ6‹À6ùtÀ7`   À6ùÀ6úÀ7 À7À7À7À7À7À7À7À7À7À7À7OÀ7&À7 À7(À7IÀ7CÀ7KÀ7Ä€‚À82   À7ÄÀ7ÅÀ7ËÀ7éÀ7ÒÀ7ÌÀ7ÚÀ7èÀ7ÛÀ7âÀ7çÀ7ãÀ7êÀ8!À7ñÀ7ëÀ7óÀ8À8À8À8špÀ9    À8šÀ8›À8¦À8§À8­À8ÊÀ8³À8®À8»À8ÉÀ8¼À8ÃÀ8ÈÀ8ÄÀ8ËÀ8îÀ8ÒÀ8ÌÀ8ÔÀ9ƒlÀ9(  À9:À9@  À9LÀ9R  À9À9À<~€¾À<÷  À=	À=  À=À=  À=*À=/  À<~À<À<…À<¸À<‹À<†À<“À<·À<”À<›À< À<œÀ<£À<«À<²À<¹À<åÀ<ÀÀ<ºÀ<Â ÀD½ƒùÀF9u/// An exception thrown by [Canvas.drawImage] and related methods when drawing
/// an [Image] created via [Picture.toImageSync] that is in an invalid state.
///
/// This exception may be thrown if the requested image dimensions exceeded the
/// maximum 2D texture size allowed by the GPU, or if no GPU surface or context
/// was available for rasterization at request time. ÀFpBÀF“ÀF”ÀF• ÀF–ÀFœ  ÀF¥
ÀF«   ÀF¶IÀFø2/// A string containing details about the failure. ÀGiÀGhO/// If available, the stack trace at the time [Picture.toImageSync] was called.  ÀGrBÀG…   ÀGrÀGs  ²À Nc½‹/// Algorithms to use when painting on the canvas.
///
/// When drawing a shape or image onto a canvas, different algorithms can be
/// used to blend the pixels. The different values of [BlendMode] specify
/// different such algorithms.
///
/// Each algorithm has two inputs, the _source_, which is the image being drawn,
/// and the _destination_, which is the image into which the source image is
/// being composited. The destination is often thought of as the _background_.
/// The source and destination both have four color channels, the red, green,
/// blue, and alpha channels. These are typically represented as numbers in the
/// range 0.0 to 1.0. The output of the algorithm also has these same four
/// channels, with values computed from the source and destination.
///
/// The documentation of each value below describes how the algorithm works. In
/// each case, an image shows the output of blending a source image with a
/// destination image. In the images below, the destination is represented by an
/// image with horizontal lines and an opaque landscape photograph, and the
/// source is represented by an image with vertical lines (the same lines but
/// rotated) and a bird clip-art image. The [src] mode shows only the source
/// image, and the [dst] mode shows only the destination image. In the
/// documentation below, the transparency is illustrated by a checkerboard
/// pattern. The [clear] mode drops both the source and destination, resulting
/// in an output that is entirely transparent (illustrated by a solid
/// checkerboard pattern).
///
/// The horizontal and vertical bars in these images show the red, green, and
/// blue channels with varying opacity levels, then all three color channels
/// together with those same varying opacity levels, then all three color
/// channels set to zero with those varying opacity levels, then two bars showing
/// a red/green/blue repeating gradient, the first with full opacity and the
/// second with partial opacity, and finally a bar with the three color channels
/// set to zero but the opacity varying in a repeating gradient.
///
/// ## Application to the [Canvas] API
///
/// When using [Canvas.saveLayer] and [Canvas.restore], the blend mode of the
/// [Paint] given to the [Canvas.saveLayer] will be applied when
/// [Canvas.restore] is called. Each call to [Canvas.saveLayer] introduces a new
/// layer onto which shapes and images are painted; when [Canvas.restore] is
/// called, that layer is then composited onto the parent layer, with the source
/// being the most-recently-drawn shapes and images, and the destination being
/// the parent layer. (For the first [Canvas.saveLayer] call, the parent layer
/// is the canvas itself.)
///
/// See also:
///
///  * [Paint.blendMode], which uses [BlendMode] to define the compositing
///    strategy.  ½Õ€î¾¾€Ş/// Drop both the source and destination images, leaving nothing.
///
/// This corresponds to the "clear" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_clear.png) ¾ÈHÀ @4/// Drop the destination image, only paint the source image.
///
/// Conceptually, the destination is first cleared, then the source image is
/// painted.
///
/// This corresponds to the "Copy" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_src.png) À @MÀ A_9/// Drop the source image, only paint the destination image.
///
/// Conceptually, the source image is discarded, leaving the destination
/// untouched.
///
/// This corresponds to the "Destination" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_dst.png) À AgìÀ CLĞ/// Composite the source image over the destination image.
///
/// This is the default value. It represents the most intuitive case, where
/// shapes are painted on top of what is below, with transparent areas showing
/// the destination layer.
///
/// This corresponds to the "Source over Destination" Porter-Duff operator,
/// also known as the Painter's Algorithm.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_srcOver.png) À CX­À Dş‘/// Composite the source image under the destination image.
///
/// This is the opposite of [srcOver].
///
/// This corresponds to the "Destination over Source" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_dstOver.png)
///
/// This is useful when the source image should have been painted before the
/// destination image, but could not be. À E
‚šÀ GŸ‚x/// Show the source image, but only where the two images overlap. The
/// destination image is not rendered, it is treated merely as a mask. The
/// color channels of the destination are ignored, only the opacity has an
/// effect.
///
/// To show the destination image instead, consider [dstIn].
///
/// To reverse the semantic of the mask (only showing the source where the
/// destination is absent, rather than where it is present), consider
/// [srcOut].
///
/// This corresponds to the "Source in Destination" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_srcIn.png) À G©‚„À J(‚f/// Show the destination image, but only where the two images overlap. The
/// source image is not rendered, it is treated merely as a mask. The color
/// channels of the source are ignored, only the opacity has an effect.
///
/// To show the source image instead, consider [srcIn].
///
/// To reverse the semantic of the mask (only showing the source where the
/// destination is present, rather than where it is absent), consider [dstOut].
///
/// This corresponds to the "Destination in Source" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_dstIn.png) À J2‚˜À LÄ‚y/// Show the source image, but only where the two images do not overlap. The
/// destination image is not rendered, it is treated merely as a mask. The color
/// channels of the destination are ignored, only the opacity has an effect.
///
/// To show the destination image instead, consider [dstOut].
///
/// To reverse the semantic of the mask (only showing the source where the
/// destination is present, rather than where it is absent), consider [srcIn].
///
/// This corresponds to the "Source out Destination" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_srcOut.png) À LÏ‚À OW‚o/// Show the destination image, but only where the two images do not overlap. The
/// source image is not rendered, it is treated merely as a mask. The color
/// channels of the source are ignored, only the opacity has an effect.
///
/// To show the source image instead, consider [srcOut].
///
/// To reverse the semantic of the mask (only showing the destination where the
/// source is present, rather than where it is absent), consider [dstIn].
///
/// This corresponds to the "Destination out Source" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_dstOut.png) À Ob‚gÀ QÂ‚E/// Composite the source image over the destination image, but only where it
/// overlaps the destination.
///
/// This corresponds to the "Source atop Destination" Porter-Duff operator.
///
/// This is essentially the [srcOver] operator, but with the output's opacity
/// channel being set to that of the destination image instead of being a
/// combination of both image's opacity channels.
///
/// For a variant with the destination on top instead of the source, see
/// [dstATop].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_srcATop.png) À QÎ‚]À T$‚;/// Composite the destination image over the source image, but only where it
/// overlaps the source.
///
/// This corresponds to the "Destination atop Source" Porter-Duff operator.
///
/// This is essentially the [dstOver] operator, but with the output's opacity
/// channel being set to that of the source image instead of being a
/// combination of both image's opacity channels.
///
/// For a variant with the source on top instead of the destination, see
/// [srcATop].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_dstATop.png) À T0;À Uh+/// Apply a bitwise `xor` operator to the source and destination images. This
/// leaves transparency where they would overlap.
///
/// This corresponds to the "Source xor Destination" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_xor.png) À UpÀÀ W,©/// Sum the components of the source and destination images.
///
/// Transparency in a pixel of one of the images reduces the contribution of
/// that image to the corresponding output pixel, as if the color of that
/// pixel in that image was darker.
///
/// This corresponds to the "Source plus Destination" Porter-Duff operator.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_plus.png) À W5ƒVÀ Zƒƒ'/// Multiply the color components of the source and destination images.
///
/// This can only result in the same or darker colors (multiplying by white,
/// 1.0, results in no change; multiplying by black, 0.0, results in black).
///
/// When compositing two opaque images, this has similar effect to overlapping
/// two transparencies on a projector.
///
/// For a variant that also multiplies the alpha channel, consider [multiply].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_modulate.png)
///
/// See also:
///
///  * [screen], which does a similar computation but inverted.
///  * [overlay], which combines [modulate] and [screen] to favor the
///    destination image.
///  * [hardLight], which combines [modulate] and [screen] to favor the
///    source image. À ZÙ…!À _ô„â/// Multiply the inverse of the components of the source and destination
/// images, and inverse the result.
///
/// Inverting the components means that a fully saturated channel (opaque
/// white) is treated as the value 0.0, and values normally treated as 0.0
/// (black, transparent) are treated as 1.0.
///
/// This is essentially the same as [modulate] blend mode, but with the values
/// of the colors inverted before the multiplication and the result being
/// inverted back before rendering.
///
/// This can only result in the same or lighter colors (multiplying by black,
/// 1.0, results in no change; multiplying by white, 0.0, results in white).
/// Similarly, in the alpha channel, it can only result in more opaque colors.
///
/// This has similar effect to two projectors displaying their images on the
/// same screen simultaneously.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_screen.png)
///
/// See also:
///
///  * [modulate], which does a similar computation but without inverting the
///    values.
///  * [overlay], which combines [modulate] and [screen] to favor the
///    destination image.
///  * [hardLight], which combines [modulate] and [screen] to favor the
///    source image. À `ƒŞÀ cïƒ®/// Multiply the components of the source and destination images after
/// adjusting them to favor the destination.
///
/// Specifically, if the destination value is smaller, this multiplies it with
/// the source value, whereas is the source value is smaller, it multiplies
/// the inverse of the source value with the inverse of the destination value,
/// then inverts the result.
///
/// Inverting the components means that a fully saturated channel (opaque
/// white) is treated as the value 0.0, and values normally treated as 0.0
/// (black, transparent) are treated as 1.0.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_overlay.png)
///
/// See also:
///
///  * [modulate], which always multiplies the values.
///  * [screen], which always multiplies the inverses of the values.
///  * [hardLight], which is similar to [overlay] but favors the source image
///    instead of the destination image. À cû7À e,"/// Composite the source and destination image by choosing the lowest value
/// from each color channel.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_darken.png) À e7:À fj$/// Composite the source and destination image by choosing the highest value
/// from each color channel.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_lighten.png) À fv{À gçb/// Divide the destination by the inverse of the source.
///
/// Inverting the components means that a fully saturated channel (opaque
/// white) is treated as the value 0.0, and values normally treated as 0.0
/// (black, transparent) are treated as 1.0.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_colorDodge.png) À gö‘À i~y/// Divide the inverse of the destination by the source, and inverse the result.
///
/// Inverting the components means that a fully saturated channel (opaque
/// white) is treated as the value 0.0, and values normally treated as 0.0
/// (black, transparent) are treated as 1.0.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_colorBurn.png) À iŒƒâÀ meƒ°/// Multiply the components of the source and destination images after
/// adjusting them to favor the source.
///
/// Specifically, if the source value is smaller, this multiplies it with the
/// destination value, whereas is the destination value is smaller, it
/// multiplies the inverse of the destination value with the inverse of the
/// source value, then inverts the result.
///
/// Inverting the components means that a fully saturated channel (opaque
/// white) is treated as the value 0.0, and values normally treated as 0.0
/// (black, transparent) are treated as 1.0.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_hardLight.png)
///
/// See also:
///
///  * [modulate], which always multiplies the values.
///  * [screen], which always multiplies the inverses of the values.
///  * [overlay], which is similar to [hardLight] but favors the destination
///    image instead of the source image. À mssÀ nİU/// Use [colorDodge] for source values below 0.5 and [colorBurn] for source
/// values above 0.5.
///
/// This results in a similar but softer effect than [overlay].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_softLight.png)
///
/// See also:
///
///  * [color], which is a more subtle tinting effect. À nëÅÀ p¦¤/// Subtract the smaller value from the bigger value for each channel.
///
/// Compositing black has no effect; compositing white inverts the colors of
/// the other image.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver].
///
/// The effect is similar to [exclusion] but harsher.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_difference.png) À pµÔÀ r€²/// Subtract double the product of the two images from the sum of the two
/// images.
///
/// Compositing black has no effect; compositing white inverts the colors of
/// the other image.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver].
///
/// The effect is similar to [difference] but softer.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_exclusion.png) À r‚ÙÀ u_‚´/// Multiply the components of the source and destination images, including
/// the alpha channel.
///
/// This can only result in the same or darker colors (multiplying by white,
/// 1.0, results in no change; multiplying by black, 0.0, results in black).
///
/// Since the alpha channel is also multiplied, a fully-transparent pixel
/// (opacity 0.0) in one image results in a fully transparent pixel in the
/// output. This is similar to [dstIn], but with the colors combined.
///
/// For a variant that multiplies the colors but does not multiply the alpha
/// channel, consider [modulate].
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_multiply.png) À u‰‚÷À x}‚Ñ/// Take the hue of the source image, and the saturation and luminosity of the
/// destination image.
///
/// The effect is to tint the destination image with the source image.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver]. Regions that are entirely transparent in the source image take
/// their hue from the destination.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_hue.png)
///
/// See also:
///
///  * [color], which is a similar but stronger effect as it also applies the
///    saturation of the source image.
///  * [HSVColor], which allows colors to be expressed using Hue rather than
///    the red/green/blue channels of [Color]. À x…‚dÀ zß‚=/// Take the saturation of the source image, and the hue and luminosity of the
/// destination image.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver]. Regions that are entirely transparent in the source image take
/// their saturation from the destination.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_hue.png)
///
/// See also:
///
///  * [color], which also applies the hue of the source image.
///  * [luminosity], which applies the luminosity of the source image to the
///    destination. À zî‚ãÀ }Ì‚½/// Take the hue and saturation of the source image, and the luminosity of the
/// destination image.
///
/// The effect is to tint the destination image with the source image.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver]. Regions that are entirely transparent in the source image take
/// their hue and saturation from the destination.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_color.png)
///
/// See also:
///
///  * [hue], which is a similar but weaker effect.
///  * [softLight], which is a similar tinting effect but also tints white.
///  * [saturation], which only applies the saturation of the source image. À }Ö‚À €Y‚d/// Take the luminosity of the source image, and the hue and saturation of the
/// destination image.
///
/// The opacity of the output image is computed in the same way as for
/// [srcOver]. Regions that are entirely transparent in the source image take
/// their luminosity from the destination.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/blend_mode_luminosity.png)
///
/// See also:
///
///  * [saturation], which applies the saturation of the source image to the
///    destination.
///  * [ImageFilter.blur], which can be used with [BackdropFilter] for a
///    related effect.    À €hŒ{À …â…t/// Quality levels for image sampling in [ImageFilter] and [Shader] objects that sample
/// images and for [Canvas] operations that render images.
///
/// When scaling up typically the quality is lowest at [none], higher at [low] and [medium],
/// and for very large scale factors (over 10x) the highest at [high].
///
/// When scaling down, [medium] provides the best quality especially when scaling an
/// image to less than half its size or for animating the scale factor between such
/// reductions. Otherwise, [low] and [high] provide similar effects for reductions of
/// between 50% and 100% but the image may lose detail and have dropouts below 50%.
///
/// To get high quality when scaling images up and down, or when the scale is
/// unknown, [medium] is typically a good balanced choice.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/filter_quality.png)
///
/// When building for the web using the `--web-renderer=html` option, filter
/// quality has no effect. All images are rendered using the respective
/// browser's default setting.
///
/// See also:
///
///  * [Paint.filterQuality], which is used to pass [FilterQuality] to the
///    engine while using drawImage calls on a [Canvas].
///  * [ImageShader].
///  * [ImageFilter.matrix].
///  * [Canvas.drawImage].
///  * [Canvas.drawImageRect].
///  * [Canvas.drawImageNine].
///  * [Canvas.drawAtlas].  À †s€ÙÀ ‡H€Ì/// The fastest filtering method, albeit also the lowest quality.
///
/// This value results in a "Nearest Neighbor" algorithm which just
/// repeats or eliminates pixels as an image is scaled up or down. À ‡Q€²À ˆ €¦/// Better quality than [none], faster than [medium].
///
/// This value results in a "Bilinear" algorithm which smoothly
/// interpolates between pixels in an image. À ˆ‚À Š‚k/// The best all around filtering method that is only worse than [high]
/// at extremely large scale factors.
///
/// This value improves upon the "Bilinear" algorithm specified by [low]
/// by utilizing a Mipmap that pre-computes high quality lower resolutions
/// of the image at half (and quarter and eighth, etc.) sizes and then
/// blends between those to prevent loss of detail at small scale sizes.
///
/// {@template dart.ui.filterQuality.seeAlso}
/// See also:
///
///  * [FilterQuality] class-level documentation that goes into detail about
///    relative qualities of the constant values.
/// {@endtemplate} À Š›‚EÀ ŒÜ‚&/// Best possible quality when scaling up images by scale factors larger than
/// 5-10x.
///
/// When images are scaled down, this can be worse than [medium] for scales
/// smaller than 0.5x, or when animating the scale factor.
///
/// This option is also the slowest.
///
/// This value results in a standard "Bicubic" algorithm which uses a 3rd order
/// equation to smooth the abrupt transitions between pixels while preserving
/// some of the sense of an edge and avoiding sharp peaks in the result.
///
/// {@macro dart.ui.filterQuality.seeAlso}    À Œå†ÆÀ Ø€±/// Styles to use for line endings.
///
/// See also:
///
///  * [Paint.strokeCap] for how this value is used.
///  * [StrokeJoin] for the different kinds of line segment joins.  À æ…À gr/// Begin and end contours with a flat edge and no extension.
///
/// ![A butt cap ends line segments with a square end that stops at the end of
/// the line segment.](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/butt_cap.png)
///
/// Compare to the [square] cap, which has the same shape, but extends past
/// the end of the line by half a stroke width. À pËÀ ‘6µ/// Begin and end contours with a semi-circle extension.
///
/// ![A round cap adds a rounded end to the line segment that protrudes
/// by one half of the thickness of the line (which is the radius of the cap)
/// past the end of the segment.](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/round_cap.png)
///
/// The cap is colored in the diagram above to highlight it: in normal use it
/// is the same color as the line. À ‘@‚hÀ “¢‚I/// Begin and end contours with a half square extension. This is
/// similar to extending each contour by half the stroke width (as
/// given by [Paint.strokeWidth]).
///
/// ![A square cap has a square end that effectively extends the line length
/// by half of the stroke width.](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/square_cap.png)
///
/// The cap is colored in the diagram above to highlight it: in normal use it
/// is the same color as the line.
///
/// Compare to the [butt] cap, which has the same shape, but doesn't extend
/// past the end of the line.    À “­ˆÀ •Wg/// Styles to use for line segment joins.
///
/// This only affects line joins for polygons drawn by [Canvas.drawPath] and
/// rectangles, not points drawn as lines with [Canvas.drawPoints].
///
/// See also:
///
/// * [Paint.strokeJoin] and [Paint.strokeMiterLimit] for how this value is
///   used.
/// * [StrokeCap] for the different kinds of line endings.  À •f‚YÀ —º‚7/// Joins between line segments form sharp corners.
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/miter_4_join.mp4}
///
/// The center of the line segment is colored in the diagram above to
/// highlight the join, but in normal usage the join is the same color as the
/// line.
///
/// See also:
///
///   * [Paint.strokeJoin], used to set the line segment join style to this
///     value.
///   * [Paint.strokeMiterLimit], used to define when a miter is drawn instead
///     of a bevel when the join is set to this value. À —ÄÌÀ ™‹®/// Joins between line segments are semi-circular.
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/round_join.mp4}
///
/// The center of the line segment is colored in the diagram above to
/// highlight the join, but in normal usage the join is the same color as the
/// line.
///
/// See also:
///
///   * [Paint.strokeJoin], used to set the line segment join style to this
///     value. À ™•‚À ›§÷/// Joins between line segments connect the corners of the butt ends of the
/// line segments to give a beveled appearance.
///
/// {@animation 300 300 https://flutter.github.io/assets-for-api-docs/assets/dart-ui/bevel_join.mp4}
///
/// The center of the line segment is colored in the diagram above to
/// highlight the join, but in normal usage the join is the same color as the
/// line.
///
/// See also:
///
///   * [Paint.strokeJoin], used to set the line segment join style to this
///     value.    À ›±‚ÖÀ œGT/// Strategies for painting shapes and paths on a canvas.
///
/// See [Paint.style].  À œ³€·À f€¬/// Apply the [Paint] to the inside of the shape. For example, when
/// applied to the [Canvas.drawCircle] call, this results in a disc
/// of the given size being painted. À oÀ ~/// Apply the [Paint] to the edge of the shape. For example, when
/// applied to the [Canvas.drawCircle] call, this results is a hoop
/// of the given size being painted. The line drawn on the edge will
/// be the width given by the [Paint.strokeWidth] property.    À ‰Œ‡À ½./// Different ways to clip a widget's content.  À Æ‚8À  ú‚/// No clip at all.
///
/// This is the default option for most widgets: if the content does not
/// overflow the widget boundary, don't pay any performance cost for clipping.
///
/// If the content does overflow, please explicitly specify the following
/// [Clip] options:
///  * [hardEdge], which is the fastest clipping, but with lower fidelity.
///  * [antiAlias], which is a little slower than [hardEdge], but with smoothed edges.
///  * [antiAliasWithSaveLayer], which is much slower than [antiAlias], and should
///    rarely be used. À ¡‚_À £Z‚:/// Clip, but do not apply anti-aliasing.
///
/// This mode enables clipping, but curves and non-axis-aligned straight lines will be
/// jagged as no effort is made to anti-alias.
///
/// Faster than other clipping modes, but slower than [none].
///
/// This is a reasonable choice when clipping is needed, if the container is an axis-
/// aligned rectangle or an axis-aligned rounded rectangle with very small corner radii.
///
/// See also:
///
///  * [antiAlias], which is more reasonable when clipping is needed and the shape is not
///    an axis-aligned rectangle. À £gƒ.À ¦Œƒ /// Clip with anti-aliasing.
///
/// This mode has anti-aliased clipping edges to achieve a smoother look.
///
/// It' s much faster than [antiAliasWithSaveLayer], but slower than [hardEdge].
///
/// This will be the common case when dealing with circles and arcs.
///
/// Different from [hardEdge] and [antiAliasWithSaveLayer], this clipping may have
/// bleeding edge artifacts.
/// (See https://fiddle.skia.org/c/21cb4c2b2515996b537f36e7819288ae for an example.)
///
/// See also:
///
///  * [hardEdge], which is a little faster, but with lower fidelity.
///  * [antiAliasWithSaveLayer], which is much slower, but can avoid the
///    bleeding edges if there's no other way.
///  * [Paint.isAntiAlias], which is the anti-aliasing switch for general draw operations. À ¦š„sÀ ª÷„4/// Clip with anti-aliasing and saveLayer immediately following the clip.
///
/// This mode not only clips with anti-aliasing, but also allocates an offscreen
/// buffer. All subsequent paints are carried out on that buffer before finally
/// being clipped and composited back.
///
/// This is very slow. It has no bleeding edge artifacts (that [antiAlias] has)
/// but it changes the semantics as an offscreen buffer is now introduced.
/// (See https://github.com/flutter/flutter/issues/18057#issuecomment-394197336
/// for a difference between paint without saveLayer and paint with saveLayer.)
///
/// This will be only rarely needed. One case where you might need this is if
/// you have an image overlaid on a very different background color. In these
/// cases, consider whether you can avoid overlaying multiple colors in one
/// spot (e.g. by having the background color only present where the image is
/// absent). If you can, [antiAlias] would be fine and much faster.
///
/// See also:
///
///  * [antiAlias], which is much faster, and has similar clipping results.    À ò€ƒ×À ôQË/// The color space describes the colors that are available to an [Image].
///
/// This value can help decide which [ImageByteFormat] to use with
/// [Image.toByteData]. Images that are in the [extendedSRGB] color space
/// should use something like [ImageByteFormat.rawExtendedRgba128] so that
/// colors outside of the sRGB gamut aren't lost.
///
/// This is also the result of [Image.colorSpace].
///
/// See also: https://en.wikipedia.org/wiki/Color_space  À ô`€ØÀ õ4€Ç/// The sRGB color space.
///
/// You may know this as the standard color space for the web or the color
/// space of non-wide-gamut Flutter apps.
///
/// See also: https://en.wikipedia.org/wiki/SRGB À õ<À öH/// A color space that is backwards compatible with sRGB but can represent
/// colors outside of that gamut with values outside of [0..1]. In order to
/// see the extended values an [ImageByteFormat] like
/// [ImageByteFormat.rawExtendedRgba128] must be used.    À öY‰À ÷åY/// The format in which image bytes should be returned when using
/// [Image.toByteData].  À ÷ù€‚À øtt/// Raw RGBA format.
///
/// Unencoded bytes, in RGBA row-primary form with premultiplied alpha, 8 bits per channel. À ø€€À øÿx/// Raw straight RGBA format.
///
/// Unencoded bytes, in RGBA row-primary form with straight alpha, 8 bits per channel. À ù€»À ùÁ€¥/// Raw unmodified format.
///
/// Unencoded bytes, in the image's existing format. For example, a grayscale
/// image may use a single 8-bit channel for each pixel. À ùÓ‚ÎÀ ü‚/// Raw extended range RGBA format.
///
/// Unencoded bytes, in RGBA row-primary form with straight alpha, 32 bit
/// float (IEEE 754 binary32) per channel.
///
/// Example usage:
///
/// ```dart
/// import 'dart:ui' as ui;
/// import 'dart:typed_data';
///
/// Future<Map<String, double>> getFirstPixel(ui.Image image) async {
///   final ByteData data =
///       (await image.toByteData(format: ui.ImageByteFormat.rawExtendedRgba128))!;
///   final Float32List floats = Float32List.view(data.buffer);
///   return <String, double>{
///     'r': floats[0],
///     'g': floats[1],
///     'b': floats[2],
///     'a': floats[3],
///   };
/// }
/// ``` À ü¦‚¾À ÿa‚œ/// PNG format.
///
/// A loss-less compression format for images. This format is well suited for
/// images with hard edges, such as screenshots or sprites, and images with
/// text. Transparency is supported. The PNG format supports images up to
/// 2,147,483,647 pixels in either dimension, though in practice available
/// memory provides a more immediate limitation on maximum image size.
///
/// PNG images normally use the `.png` file extension and the `image/png` MIME
/// type.
///
/// See also:
///
///  * <https://en.wikipedia.org/wiki/Portable_Network_Graphics>, the Wikipedia page on PNG.
///  * <https://tools.ietf.org/rfc/rfc2083.txt>, the PNG standard.    À ÿiƒ?À ÿ­>/// The format of pixel data given to [decodeImageFromPixels].  À ÿ½€ÙÀ €Ê/// Each pixel is 32 bits, with the highest 8 bits encoding red, the next 8
/// bits encoding green, the next 8 bits encoding blue, and the lowest 8 bits
/// encoding alpha. Premultiplied alpha is used. À ›€ÙÀl€Ê/// Each pixel is 32 bits, with the highest 8 bits encoding blue, the next 8
/// bits encoding green, the next 8 bits encoding red, and the lowest 8 bits
/// encoding alpha. Premultiplied alpha is used. Ày,Àš/// Each pixel is 128 bits, where each color component is a 32 bit float that
/// is normalized across the sRGB gamut.  The first float is the red
/// component, followed by: green, blue and alpha. Premultiplied alpha isn't
/// used, matching [ImageByteFormat.rawExtendedRgba128].    Àyœƒ•Àz9€—/// Determines the winding rule that decides how the interior of a [Path] is
/// calculated.
///
/// This enum is used by the [Path.fillType] property.  ÀzJ¯À{ò—/// The interior is defined by a non-zero sum of signed edge crossings.
///
/// For a given point, the point is considered to be on the inside of the path
/// if a line drawn from the point to infinity crosses lines going clockwise
/// around the point a different number of times than it crosses lines going
/// counter-clockwise around that point.
///
/// See: <https://en.wikipedia.org/wiki/Nonzero-rule> À{ş0À}'/// The interior is defined by an odd number of edge crossings.
///
/// For a given point, the point is considered to be on the inside of the path
/// if a line drawn from the point to infinity crosses an odd number of lines.
///
/// See: <https://en.wikipedia.org/wiki/Even-odd_rule>    À}3ˆLÀ}ç€ˆ/// Strategies for combining paths.
///
/// See also:
///
/// * [Path.combine], which uses this enum to decide how to combine two paths.  À}ù£À’„/// Subtract the second path from the first path.
///
/// For example, if the two paths are overlapping circles of equal diameter
/// but differing centers, the result would be a crescent portion of the
/// first circle that was not overlapped by the second circle.
///
/// See also:
///
///  * [reverseDifference], which is the same but subtracting the first path
///    from the second. À ‡Àk/// Create a new path that is the intersection of the two paths, leaving the
/// overlapping pieces of the path.
///
/// For example, if the two paths are overlapping circles of equal diameter
/// but differing centers, the result would be only the overlapping portion
/// of the two circles.
///
/// See also:
///  * [xor], which is the inverse of this operation À+$À‚J/// Create a new path that is the union (inclusive-or) of the two paths.
///
/// For example, if the two paths are overlapping circles of equal diameter
/// but differing centers, the result would be a figure-eight like shape
/// matching the outer boundaries of both circles. À‚S‚ÀƒÒn/// Create a new path that is the exclusive-or of the two paths, leaving
/// everything but the overlapping pieces of the path.
///
/// For example, if the two paths are overlapping circles of equal diameter
/// but differing centers, the figure-eight like shape less the overlapping parts
///
/// See also:
///  * [intersect], which is the inverse of this operation ÀƒÙ£À…k}/// Subtract the first path from the second path.
///
/// For example, if the two paths are overlapping circles of equal diameter
/// but differing centers, the result would be a crescent portion of the
/// second circle that was not overlapped by the first circle.
///
/// See also:
///
///  * [difference], which is the same but subtracting the second path
///    from the first.    À(ƒ{À4/// Styles to use for blurs in [MaskFilter] objects.  Àå€–Àu€‹/// Fuzzy inside and outside. This is useful for painting shadows that are
/// offset from the shape that ostensibly is casting the shadow. À€€ÍÀH€Á/// Solid inside, fuzzy outside. This corresponds to drawing the shape, and
/// additionally drawing the blur. This can make objects appear brighter,
/// maybe even as if they were fluorescent. ÀR€æÀ3€Ú/// Nothing inside, fuzzy outside. This is useful for painting shadows for
/// partially transparent shapes, when they are painted separately but without
/// an offset, so that the shadow doesn't paint below the shape. À=cÀ›Y/// Fuzzy inside, nothing outside. This can make shapes appear to be lit from
/// within.    ÀiÏ“Àp¢†’/// Defines what happens at the edge of a gradient or the sampling of a source image
/// in an [ImageFilter].
///
/// A gradient is defined along a finite inner area. In the case of a linear
/// gradient, it's between the parallel lines that are orthogonal to the line
/// drawn between two points. In the case of radial gradients, it's the disc
/// that covers the circle centered on a particular point up to a given radius.
///
/// An image filter reads source samples from a source image and performs operations
/// on those samples to produce a result image. An image defines color samples only
/// for pixels within the bounds of the image but some filter operations, such as a blur
/// filter, read samples over a wide area to compute the output for a given pixel. Such
/// a filter would need to combine samples from inside the image with hypothetical
/// color values from outside the image.
///
/// This enum is used to define how the gradient or image filter should treat the regions
/// outside that defined inner area.
///
/// See also:
///
///  * [painting.Gradient], the superclass for [LinearGradient] and
///    [RadialGradient], as used by [BoxDecoration] et al, which works in
///    relative coordinates and can create a [Shader] representing the gradient
///    for a particular [Rect] on demand.
///  * [dart:ui.Gradient], the low-level class used when dealing with the
///    [Paint.shader] property directly, with its [Gradient.linear] and
///    [Gradient.radial] constructors.
///  * [dart:ui.ImageFilter.blur], an ImageFilter that may sometimes need to
///    read samples from outside an image to combine with the pixels near the
///    edge of the image.  Àp¯‚£ÀsM‚‡/// Samples beyond the edge are clamped to the nearest color in the defined inner area.
///
/// A gradient will paint all the regions outside the inner area with the
/// color at the end of the color stop list closest to that region.
///
/// An image filter will substitute the nearest edge pixel for any samples taken from
/// outside its source image.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_clamp_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_clamp_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_clamp_sweep.png) ÀsWƒ5Àv„ƒ/// Samples beyond the edge are repeated from the far end of the defined area.
///
/// For a gradient, this technique is as if the stop points from 0.0 to 1.0 were then
/// repeated from 1.0 to 2.0, 2.0 to 3.0, and so forth (and for linear gradients, similarly
/// from -1.0 to 0.0, -2.0 to -1.0, etc).
///
/// An image filter will treat its source image as if it were tiled across the enlarged
/// sample space from which it reads, each tile in the same orientation as the base image.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_repeated_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_repeated_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_repeated_sweep.png) Àv‘ƒ|ÀzƒY/// Samples beyond the edge are mirrored back and forth across the defined area.
///
/// For a gradient, this technique is as if the stop points from 0.0 to 1.0 were then
/// repeated backwards from 2.0 to 1.0, then forwards from 2.0 to 3.0, then backwards
/// again from 4.0 to 3.0, and so forth (and for linear gradients, similarly in the
/// negative direction).
///
/// An image filter will treat its source image as tiled in an alternating forwards and
/// backwards or upwards and downwards direction across the sample space from which
/// it is reading.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_mirror_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_mirror_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_mirror_sweep.png) Àz‚½À|Ê‚Ÿ/// Samples beyond the edge are treated as transparent black.
///
/// A gradient will render transparency over any region that is outside the circle of a
/// radial gradient or outside the parallel lines that define the inner area of a linear
/// gradient.
///
/// An image filter will substitute transparent black for any sample it must read from
/// outside its source image.
///
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_decal_linear.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_decal_radial.png)
/// ![](https://flutter.github.io/assets-for-api-docs/assets/dart-ui/tile_mode_decal_sweep.png)    ÀÍB‚ÃÀÍüw/// Defines how a list of points is interpreted when drawing a set of triangles.
///
/// Used by [Canvas.drawVertices].  ÀÎQÀÎSE/// Draw each sequence of three points as the vertices of a triangle. ÀÎa[ÀÎ¯K/// Draw each sliding window of three points as the vertices of a triangle. ÀÎÁAÀÏ÷)/// Draw the first point and each sliding window of two points as the vertices
/// of a triangle.
///
/// This mode is not natively supported by most backends, and is instead
/// implemented by unrolling the points into the equivalent
/// [VertexMode.triangles], which is generally more efficient.    Àü„-Àüæ€/// Defines how a list of points is interpreted when drawing a set of points.
///
/// Used by [Canvas.drawPoints] and [Canvas.drawRawPoints].  Àüô·Àş¥/// Draw each point separately.
///
/// If the [Paint.strokeCap] is [StrokeCap.round], then each point is drawn
/// as a circle with the diameter of the [Paint.strokeWidth], filled as
/// described by the [Paint] (ignoring [Paint.style]).
///
/// Otherwise, each point is drawn as an axis-aligned square with sides of
/// length [Paint.strokeWidth], filled as described by the [Paint] (ignoring
/// [Paint.style]). Àş°€éÀÿ”€×/// Draw each sequence of two points as a line segment.
///
/// If the number of points is odd, then the last point is ignored.
///
/// The lines are stroked as described by the [Paint] (ignoring
/// [Paint.style]). Àÿ€›À 2€‹/// Draw the entire sequence of points as one line.
///
/// The lines are stroked as described by the [Paint] (ignoring
/// [Paint.style]).    À >À ¼x/// Defines how a new clip region should be merged with the existing clip
/// region.
///
/// Used by [Canvas.clipRect].  À ÇBÀ ÿ5/// Subtract the new region from the existing region. ÀBÀG6/// Intersect the new region from the existing region.      „‹o„  „	„£   „üt…  ……   …r€…w  …†…   †€Û†  ††%   †à€†å  †ô†ü   ‡om‡u  ‡‡ˆ  ‡Š‡’   ÀF/‰?ÀN‡‰/// Instantiates an image [Codec].
///
/// This method is a convenience wrapper around the [ImageDescriptor] API, and
/// using [ImageDescriptor] directly is preferred since it allows the caller to
/// make better determinations about how and whether to use the `targetWidth`
/// and `targetHeight` parameters.
///
/// The `list` parameter is the binary image data (e.g a PNG or GIF binary data).
/// The data can be for either static or animated images. The following image
/// formats are supported:
/// {@template dart.ui.imageFormats}
/// JPEG, PNG, GIF, Animated GIF, WebP, Animated WebP, BMP, and WBMP. Additional
/// formats may be supported by the underlying platform. Flutter will
/// attempt to call platform API to decode unrecognized formats, and if the
/// platform API supports decoding the image Flutter will be able to render it.
/// {@endtemplate}
///
/// The `targetWidth` and `targetHeight` arguments specify the size of the
/// output image, in image pixels. If they are not equal to the intrinsic
/// dimensions of the image, then the image will be scaled after being decoded.
/// If the `allowUpscaling` parameter is not set to true, both dimensions will
/// be capped at the intrinsic dimensions of the image, even if only one of
/// them would have exceeded those intrinsic dimensions. If exactly one of these
/// two arguments is specified, then the aspect ratio will be maintained while
/// forcing the image to match the other given dimension. If neither is
/// specified, then the image maintains its intrinsic size.
///
/// Scaling the image to larger than its intrinsic size should usually be
/// avoided, since it causes the image to use more memory than necessary.
/// Instead, prefer scaling the [Canvas] transform. If the image must be scaled
/// up, the `allowUpscaling` parameter must be set to true.
///
/// The returned future can complete with an error if the image decoding has
/// failed. ÀN ÀN+  ÀN4ÀN:  ÀNHÀNN  ÀN]ÀNc  ÀNsÀOpŠ¡ÀWªˆ+/// Instantiates an image [Codec].
///
/// This method is a convenience wrapper around the [ImageDescriptor] API, and
/// using [ImageDescriptor] directly is preferred since it allows the caller to
/// make better determinations about how and whether to use the `targetWidth`
/// and `targetHeight` parameters.
///
/// The [buffer] parameter is the binary image data (e.g a PNG or GIF binary data).
/// The data can be for either static or animated images. The following image
/// formats are supported: {@macro dart.ui.imageFormats}
///
/// The [buffer] will be disposed by this method once the codec has been created,
/// so the caller must relinquish ownership of the [buffer] when they call this
/// method.
///
/// The [targetWidth] and [targetHeight] arguments specify the size of the
/// output image, in image pixels. If they are not equal to the intrinsic
/// dimensions of the image, then the image will be scaled after being decoded.
/// If the `allowUpscaling` parameter is not set to true, both dimensions will
/// be capped at the intrinsic dimensions of the image, even if only one of
/// them would have exceeded those intrinsic dimensions. If exactly one of these
/// two arguments is specified, then the aspect ratio will be maintained while
/// forcing the image to match the other given dimension. If neither is
/// specified, then the image maintains its intrinsic size.
///
/// Scaling the image to larger than its intrinsic size should usually be
/// avoided, since it causes the image to use more memory than necessary.
/// Instead, prefer scaling the [Canvas] transform. If the image must be scaled
/// up, the `allowUpscaling` parameter must be set to true.
///
/// The returned future can complete with an error if the image decoding has
/// failed.
///
/// ## Compatibility note on the web
///
/// When running Flutter on the web, only the CanvasKit renderer supports image
/// resizing capabilities (not the HTML renderer). So if image resizing is
/// critical to your use case, and you're deploying to the web, you should
/// build using the CanvasKit renderer. ÀWÍÀWŞ  ÀWéÀWï  ÀWıÀX  ÀXÀX  ÀX(ÀZ‰„Àa*‡/// Instantiates an image [Codec].
///
/// This method is a convenience wrapper around the [ImageDescriptor] API.
///
/// The [buffer] parameter is the binary image data (e.g a PNG or GIF binary
/// data). The data can be for either static or animated images. The following
/// image formats are supported: {@macro dart.ui.imageFormats}
///
/// The [buffer] will be disposed by this method once the codec has been
/// created, so the caller must relinquish ownership of the [buffer] when they
/// call this method.
///
/// The [getTargetSize] parameter, when specified, will be invoked and passed
/// the image's intrinsic size to determine the size to decode the image to.
/// The width and the height of the size it returns must be positive values
/// greater than or equal to 1, or null. It is valid to return a
/// [TargetImageSize] that specifies only one of `width` and `height` with the
/// other remaining null, in which case the omitted dimension will be scaled to
/// maintain the aspect ratio of the original dimensions. When both are null or
/// omitted, the image will be decoded at its native resolution (as will be the
/// case if the [getTargetSize] parameter is omitted).
///
/// Scaling the image to larger than its intrinsic size should usually be
/// avoided, since it causes the image to use more memory than necessary.
/// Instead, prefer scaling the [Canvas] transform.
///
/// The returned future can complete with an error if the image decoding has
/// failed.
///
/// ## Compatibility note on the web
///
/// When running Flutter on the web, only the CanvasKit renderer supports image
/// resizing capabilities (not the HTML renderer). So if image resizing is
/// critical to your use case, and you're deploying to the web, you should
/// build using the CanvasKit renderer. ÀaKÀa\  Àag&Àa   Àc™sÀc©  Àc¾ÀcÃ  ÀcÒÀc×   Àkà©Àm0/// Loads a single image frame from a byte array into an [Image] object.
///
/// This is a convenience wrapper around [instantiateImageCodec]. Prefer using
/// [instantiateImageCodec] which also supports multi frame images and offers
/// better error handling. This function swallows asynchronous errors. Àm*Àm5  Àm:ÀmP   Àm‹€ïÀm˜  Àm²Àm½  ÀmÂÀmØ   Àn|‹Àt…/// Convert an array of pixel values into an [Image] object.
///
/// The `pixels` parameter is the pixel data. They are packed in bytes in the
/// order described by `format`, then grouped in rows, from left to right,
/// then top to bottom.
///
/// The `rowBytes` parameter is the number of bytes consumed by each row of
/// pixels in the data buffer. If unspecified, it defaults to `width` multiplied
/// by the number of bytes per pixel in the provided `format`.
///
/// The `targetWidth` and `targetHeight` arguments specify the size of the
/// output image, in image pixels. If they are not equal to the intrinsic
/// dimensions of the image, then the image will be scaled after being decoded.
/// If the `allowUpscaling` parameter is not set to true, both dimensions will
/// be capped at the intrinsic dimensions of the image, even if only one of
/// them would have exceeded those intrinsic dimensions. If exactly one of these
/// two arguments is specified, then the aspect ratio will be maintained while
/// forcing the image to match the other given dimension. If neither is
/// specified, then the image maintains its intrinsic size.
///
/// Scaling the image to larger than its intrinsic size should usually be
/// avoided, since it causes the image to use more memory than necessary.
/// Instead, prefer scaling the [Canvas] transform. If the image must be scaled
/// up, the `allowUpscaling` parameter must be set to true. 	Àt8ÀtC  ÀtL	ÀtQ  ÀtY
Àt^  ÀtgÀtt  Àt}Àt“  Àt Àt¦  Àt±Àt·  ÀtÅÀtË  ÀtÚÀtà  ÀtğÀ|Ô€ëÀ|Ş  À|ïÀ|ü   À}Á›À}Í  À}ŞÀ}ì   À^$Àj  À{Àƒ  ÀŠÀ’   ÀB‚¶ÀB ÀBÀBÀBÀB,    ÀªdÀŞ+/// Signature for [Image] lifecycle events.  ÀÀ   À0²mÀ0ì1/// Callback signature for [decodeImageFromList].  À1À1   ÀddÀe€ø/// Signature for a callback that determines the size to which an image should
/// be decoded given its intrinsic size.
///
/// See also:
///
///  * [instantiateImageCodecWithSize], which used this signature for its
///    `getTargetSize` argument.  ÀeEÀeJ  Àe[Àe`   Àà…lÀà»-/// Signature for [Picture] lifecycle events.  ÀààÀàé   À=@dÀ=}4/// Generic callback signature, used by [_futurize].À=‡À=‡ À=šÀ=   À=¦€ÕÀ>A€’/// Signature for a method that receives a [_Callback].
///
/// Return value should be null on success, and a string error message on
/// failure.À>MÀ>M À>cÀ>r       ›E <€†€¤€µ€¶€Î€ï-Fz­®û‚E‚•‚æƒ6ƒ„ƒÕ„„„d„Š„‹„ª„ê„ù„û„ü……`…o…q…r…—…ñ† †††/†p†Î†İ†ß†à‡‡]‡l‡n‡o‡›‡Û‡İ‡Şˆˆˆfˆ¶‰‰-‰1‰a‰e‰q‰™‰ÖŠŠFŠNŠRŠ£Šò‹B‹n‹r‹~‹ËŒŒŒŒ-Œ1Œ„ŒÊŒØEKs™Àåë;‰·½Pu‘ÈÉ	\l‘¸Şä‘'‘-‘x‘…‘º‘Ü‘ş’ ’N’O’¤’ª’Ï’ö““i“™“Ÿ“â“è”0”n”¤”Ú••R•S••‡•¯•µ•İ––*–O–b–c–œ–¢–ñ——B—C—v—|—Í—ï˜˜˜M˜z˜{˜´˜â˜ã™™H™I™’™È™Îšš!šQšUšVšŸšçší›%›K›y›ª›®›¯›ÿœ,œ2œjœƒœµœ¹œº9?w’ÂÆÇEKƒÎÒÓŸŸNŸnŸŸ”ŸÕŸÙŸÚ % +   £ á ÿ¡?¡z¡·¡ó¢$¢(¢)¢X¢^¢¦¢é¢ï£9£†£Å¤¤¤^¤¨¤ó¥?¥¥İ¦*¦{¦¨¦®¦ı§§R§g§~§“§¢§Ê§Ò§ß§ö¨¨'¨F¨Š¨Ê©©P©[©c©i©m©n©±©÷©ıªIªªÛ«*«u«µ«İ¬¬5¬;¬b¬ˆ¬¿¬Ü¬ê­0­z­Â­Ë­è®®H®h®…®—®â¯1¯~¯‡¯¯‘¯’¯ß¯å°°C°~°‚°ƒ°°²°Ô°ç°í±±-±3±M±n±r±s±±¥±¦±²² ²²²6²:²‡²Ñ²ğ²ô³E³’³á´/´´Êµµµbµ­µş¶J¶˜¶å·,·w·Æ¸¸'¸+¸y¸Æ¹¹b¹¯º ºAºEºlºpº¾ºÿ»P»»î¼=¼Œ¼§¼«¼¹¼½½½½*½y½Œ½Ò½Ó¾¾¾Y¾_¾¼¾Å¾Æ¿¿¿Z¿i¿o¿ª¿°À @À @À @À @RÀ @XÀ @£À @´À @ºÀ @üÀ AÀ A]À AdÀ AeÀ A¢À A¨À AöÀ BGÀ BdÀ BjÀ B¸À BåÀ BëÀ CJÀ CUÀ CVÀ C”À CšÀ CÃÀ CÉÀ DÀ DÀ D|À D‚À DÑÀ DüÀ EÀ EÀ EPÀ EÀ EêÀ EøÀ EşÀ F=À FCÀ FÀ FØÀ FèÀ FîÀ G:À G@À GÀ G¦À G§À GôÀ HBÀ HŒÀ H’À HÌÀ HÒÀ IÀ IqÀ IwÀ IÃÀ IÉÀ J&À J/À J0À JÀ JÒÀ K!À K'À KgÀ KmÀ KºÀ LÀ LÀ L^À LdÀ LÂÀ LÌÀ LÍÀ M!À MoÀ M¹À M¿À MúÀ N À NRÀ NÀ N¤À NñÀ N÷À OUÀ O_À O`À O¯À OÏÀ OÕÀ P#À P)À PyÀ PÅÀ PùÀ PÿÀ QJÀ Q[À QaÀ QÀÀ QËÀ QÌÀ RÀ R6À R<À RŠÀ RÀ RàÀ S'À S[À SaÀ S¬À S½À SÃÀ T"À T-À T.À T~À T²À T¸À UÀ UÀ UfÀ UmÀ UnÀ U­À U³À VÀ VNÀ VtÀ VzÀ VÈÀ VÎÀ W*À W2À W3À W}À WƒÀ WÒÀ X!À X'À XxÀ X¡À X§À XøÀ XşÀ Y^À YdÀ YtÀ YzÀ Y¼À ZÀ Z À ZjÀ ZÀ ZÀ ZÀ ZÖÀ Z×À ["À [HÀ [NÀ [šÀ [çÀ \À \À \mÀ \¹À \ßÀ \åÀ ]5À ]„À ]ÕÀ ]ÛÀ ^*À ^LÀ ^RÀ ^°À ^¶À ^ÆÀ ^ÌÀ _À _-À _uÀ _‘À _ÛÀ _òÀ `À `À `_À `À `”À `åÀ a3À a„À a£À a©À aõÀ bBÀ bqÀ bwÀ bÖÀ bÜÀ bìÀ bòÀ c+À crÀ cÂÀ cíÀ cøÀ cùÀ dGÀ dfÀ dlÀ dµÀ dÆÀ dÌÀ e*À e4À e5À e„À e£À e©À eòÀ fÀ f	À fhÀ fsÀ ftÀ f¯À fµÀ gÀ gNÀ g}À gƒÀ gåÀ góÀ gôÀ hGÀ hMÀ h™À hæÀ iÀ iÀ i|À i‰À iŠÀ iÓÀ iıÀ jÀ jSÀ jœÀ jêÀ kÀ kÀ kiÀ k¶À kåÀ këÀ lLÀ lRÀ lbÀ lhÀ l¡À lèÀ m7À mcÀ mpÀ mqÀ m¿À m×À mİÀ nÀ n%À n†À nŒÀ nœÀ n¢À nÛÀ nèÀ néÀ o2À o8À o‡À oÀ o¤À oíÀ oşÀ pÀ p<À pBÀ p¤À p²À p³À pÿÀ qÀ qÀ qbÀ qyÀ qÀ qÈÀ qÙÀ qßÀ rÀ rÀ r~À r‹À rŒÀ rÚÀ róÀ rùÀ sHÀ s—À sÀ séÀ t6À t~À t„À tÓÀ t÷À tıÀ u]À u†À u‡À uØÀ uñÀ u÷À v@À vFÀ vÀ vßÀ wÀ wÀ wfÀ wlÀ w|À w‚À wÒÀ wûÀ xJÀ x{À x‚À xƒÀ xÔÀ xíÀ xóÀ y<À yŒÀ y¹À y¿À zÀ z À z0À z6À zxÀ zÇÀ zİÀ zëÀ zìÀ {=À {VÀ {\À {¥À {«À {ôÀ |DÀ |yÀ |À |ÜÀ |âÀ |òÀ |øÀ }.À }|À }ÊÀ }ÓÀ }ÔÀ ~%À ~>À ~DÀ ~À ~İÀ 
À À rÀ xÀ ˆÀ À İÀ óÀ €>À €WÀ €eÀ €gÀ €hÀ €ÀÀ €ûÀ €ÿÀ \À £À §À üÀ ‚PÀ ‚¦À ‚úÀ ‚şÀ ƒLÀ ƒ‡À ƒ‹À ƒäÀ ƒèÀ „5À „}À „œÀ „ À „®À „²À „ıÀ …6À …LÀ …iÀ …„À …£À …ÂÀ …İÀ …òÀ †HÀ †pÀ †qÀ †µÀ †»À ‡À ‡FÀ ‡NÀ ‡OÀ ‡‡À ‡À ‡ÏÀ ‡şÀ ˆÀ ˆÀ ˆPÀ ˆxÀ ˆ~À ˆÉÀ ‰À ‰_À ‰ªÀ ‰°À ‰àÀ ‰ğÀ ‰öÀ ŠEÀ ŠyÀ ŠÀ Š˜À Š™À ŠéÀ ŠöÀ ŠüÀ ‹JÀ ‹‡À ‹À ‹´À ‹ºÀ ŒÀ Œ\À Œ§À Œ­À ŒÚÀ ŒâÀ ŒäÀ ŒåÀ 	À À À À TÀ —À ÓÀ äÀ $À *À {À ßÀ åÀ 3À eÀ mÀ nÀ ©À ¯À ùÀ IÀ ¹À ¿À ‘À ‘4À ‘=À ‘>À ‘À ‘ÆÀ ‘ëÀ ‘ñÀ ’@À ’±À ’·À “À “,À “2À “€À “ À “ªÀ “¬À “­À “×À “ÛÀ ”(À ”lÀ ”pÀ ”~À ”‚À ”ÎÀ ”ÚÀ •À •RÀ •dÀ •šÀ • À –	À –À –WÀ –§À –³À –¹À –ÉÀ –ÏÀ —À —.À —À —¸À —ÁÀ —ÂÀ —÷À —ıÀ ˜dÀ ˜jÀ ˜²À ™À ™À ™À ™$À ™*À ™xÀ ™‰À ™’À ™“À ™áÀ šÀ šÀ š€À š†À šÎÀ ›À ›*À ›0À ›@À ›FÀ ›”À ›¥À ›®À ›°À ›±À ›ëÀ ›ïÀ œÀ œBÀ œWÀ œ¢À œ°À œ±À œ÷À =À dÀ lÀ mÀ ±À ÷À >À |À †À ˆÀ ‰À ¸À ÄÀ ÚÀ àÀ Ÿ+À Ÿ|À Ÿ‚À ŸÎÀ ŸäÀ  1À  ŠÀ  ßÀ  øÀ ¡ À ¡À ¡-À ¡3À ¡ŒÀ ¡½À ¡ÃÀ ¢À ¢	À ¢aÀ ¢¼À ¢ÂÀ ¢ÒÀ ¢ØÀ £4À £XÀ £dÀ £eÀ £„À £ŠÀ £ÖÀ £ÜÀ ¤/À ¤5À ¤|À ¤‚À ¤×À ¤öÀ ¥MÀ ¥SÀ ¥cÀ ¥iÀ ¥±À ¥üÀ ¦-À ¦ŠÀ ¦—À ¦˜À ¦äÀ ¦êÀ §=À §À §¸À §¾À ¨À ¨]À ¨¯À ©À ©À ©WÀ ©§À ©õÀ ªEÀ ª‹À ª‘À ª¡À ª§À ªõÀ «À «À «À «TÀ «XÀ «À «½À «ËÀ ¬À ¬)À ¬5À ¬PÀ ¬fÀ ¬lÀ ¬pÀ ¬qÀ ¬ À ¬¥À ¬ğÀ ­;À ­ŠÀ ­ØÀ ®'À ®,À ®|À ®ÍÀ ®ŞÀ ®ãÀ ¯+À ¯,À ¯MÀ ¯iÀ ¯À ¯À ¯ÉÀ ¯îÀ °À °<À °gÀ °À °ºÀ °êÀ ±À ±AÀ ±uÀ ±¥À ±ÑÀ ±øÀ ±ùÀ ²;À ²qÀ ²¯À ²åÀ ³'À ³eÀ ³¥À ³ñÀ ´7À ´wÀ ´ÉÀ µÀ µUÀ µÀ µÎÀ µ÷À µøÀ ¶<À ¶]À ¶yÀ ¶”À ¶•À ¶ÃÀ ·À ·
À ·À ·1À ·\À ·‡À ·ÛÀ ·ÜÀ ¸"À ¸0À ¸6À ¸NÀ ¸gÀ ¸®À ¸²À ¸ÒÀ ¹"À ¹LÀ ¹sÀ ¹·À ¹»À ¹¼À ¹ôÀ º$À º%À º^À ºdÀ º„À ºŠÀ ºšÀ º À ºæÀ »À »_À »eÀ »­À »ÂÀ »ÖÀ ¼À ¼KÀ ¼OÀ ¼jÀ ¼ À ¼ŞÀ ¼âÀ ¼ãÀ ½À ½\À ½]À ½©À ½¯À ½ñÀ ¾BÀ ¾“À ¾´À ¾ºÀ ¿À ¿(À ¿.À ¿UÀ ¿[À ¿kÀ ¿qÀ ¿ÀÀ ¿ôÀ À>À ÀTÀ ÀpÀ À½À ÀøÀ ÀüÀ ÁÀ ÁYÀ Á›À ÁŸÀ Á À ÁäÀ ÁêÀ ÂÀ Â.À Â€À Â„À Â§À ÂÌÀ Ã
À ÃÀ ÃÀ ÃIÀ Ã˜À ÃÕÀ ÃÛÀ ÄÀ Ä3À ÄwÀ Ä{À ÄÀ Ä¿À ÅÀ Å	À Å
À ÅKÀ Å{À ÅÀ Å³À ÅÏÀ Æ!À Æ%À ÆHÀ ÆmÀ Æ¯À Æ³À Æ´À ÆõÀ ÆûÀ ÇLÀ Ç—À ÇÀ Ç×À ÇİÀ ÇûÀ ÈÀ ÈjÀ ÈpÀ È×À ÈİÀ ÉDÀ ÉJÀ É–À ÉçÀ ÉóÀ ÉùÀ Ê	À ÊÀ Ê^À ÊŠÀ ÊÓÀ ËÀ Ë0À Ë„À ËˆÀ Ë­À ËÒÀ ÌÀ ÌÀ ÌÀ ÌRÀ Ì‰À ÌŠÀ ÌÕÀ Í#À ÍnÀ Í»À Î	À ÎÀ ÎTÀ ÎZÀ Î¨À ÎÌÀ ÎÒÀ Ï;À ÏAÀ ÏªÀ Ï°À ĞÀ ĞÀ ĞkÀ Ğ¼À ĞÈÀ ĞÎÀ ĞŞÀ ĞäÀ Ñ.À ÑIÀ Ñ’À Ñ²À ÑûÀ ÑÿÀ Ò&À ÒdÀ Ò¯À Ò³À Ò´À ÓÀ ÓBÀ ÓHÀ ÓlÀ Ó‹À ÓÏÀ ÓğÀ ÔÀ Ô&À ÔFÀ Ô¡À ÔèÀ ÔóÀ ÔùÀ Õ
À ÕÀ Õ4À ÕMÀ ÕŸÀ ÕçÀ Ö/À Ö<À Ö‰À Ö»À ×À ×fÀ ×·À ×½À ×ÁÀ ×ÂÀ ØÀ ØhÀ Ø´À ØºÀ ØâÀ Ù/À ÙSÀ Ù­À Ù±À ÙÜÀ ÚÀ ÚGÀ ÚKÀ ÚLÀ Ú†À ÚŒÀ ÚÂÀ ÚÈÀ ÚØÀ ÚŞÀ ÛÀ ÛRÀ Û„À ÛÌÀ ÛãÀ ÜÀ ÜÀ Ü5À ÜEÀ ÜSÀ Ü‚À Ü¹À ÜÂÀ ÜÕÀ ÜßÀ ÜïÀ İÀ İ>À İÀ İ¨À İ°À İÃÀ İÍÀ ŞÀ Ş	À Ş
À ŞQÀ ŞcÀ ŞiÀ ŞÀ Ş”À ŞåÀ ßÀ ß]À ßÀ ßƒÀ ß«À ßñÀ àÀ à/À à]À àeÀ àrÀ à¸À à¾À àÂÀ àÃÀ àşÀ áÀ áKÀ áeÀ ákÀ áyÀ á¦À áÀÀ áÒÀ áìÀ â<À âGÀ âOÀ âYÀ â_À âoÀ âuÀ â°À âÑÀ ã(À ãJÀ ãNÀ ãvÀ ãÀ ã­À ãÛÀ ããÀ ãğÀ ä1À ä‡À ä²À äöÀ äşÀ åÀ åÀ å	À åHÀ åNÀ åšÀ åäÀ æÀ æ/À ævÀ æzÀ æ›À æåÀ æéÀ æêÀ æÿÀ çAÀ çEÀ çaÀ ç¦À çªÀ ç«À çãÀ çéÀ è5À è{À è®À è´À èúÀ éÀ é!À énÀ éºÀ éİÀ éãÀ ê*À êxÀ êŸÀ ê À ê¬À êÂÀ êûÀ ëÀ ë À ëPÀ ëkÀ ë‡À ë°À ëÎÀ ëîÀ ì*À ì9À ì\À ìdÀ ìÀ ì²À ìºÀ ìæÀ í#À íxÀ í‚À í‘À í·À í¿À í×À íİÀ íüÀ î-À îEÀ îKÀ î{À î£À î»À îÁÀ îòÀ ïÀ ï6À ï<À ï[À ï˜À ï°À ï¶À ïÔÀ ğÀ ğ'À ğ-À ğ\À ğÀ ğµÀ ğ»À ğÕÀ ñÀ ñ À ñ&À ñEÀ ñ‚À ñšÀ ñ À ñ¸À ññÀ ñ÷À ò
À ò>À òDÀ ò[À òyÀ ò}À òÀ ò€À òËÀ òÏÀ óÀ ó\À ó§À óÙÀ óİÀ ôÀ ôÀ ôLÀ ô^À ôzÀ ô€À ôÍÀ ôùÀ ôÿÀ õ2À õ:À õ‡À õÕÀ öÀ öFÀ öVÀ öXÀ öYÀ ö›À ö³À ÷À ÷NÀ ÷–À ÷àÀ ÷÷À øÀ øÀ ørÀ ø}À ø~À øÀ ø¤À øıÀ ùÀ ùÀ ù.À ù4À ù„À ù¿À ùĞÀ ùÑÀ ù÷À ùıÀ úIÀ úvÀ ú|À ú‘À ú—À ú¥À úÃÀ úãÀ úéÀ û1À ûOÀ û¥À ûçÀ üÀ ü"À ü<À üVÀ üpÀ ü{À üƒÀ üÀ ü£À ü¤À ü¶À ü¼À ıÀ ıZÀ ı¦À ıóÀ ş<À şBÀ ş“À şŸÀ ş¥À şµÀ ş»À ÿÀ ÿ_À ÿfÀ ÿhÀ ÿiÀ ÿ¨À ÿ»À 	À YÀ ŒÀ ˜À ™À èÀ7ÀjÀvÀwÀÇÀÀ]À˜À§À©ÀªÀÖÀÀÀFÀJÀŠÀÀÜÀôÀøÀGÀ–ÀİÀ%ÀsÀÀ…ÀÑÀ ÀgÀkÀyÀ}ÀëÀ:À`À¯À½ÀïÀÿÀ'À:ÀDÀcÀ}ÀÀ‚À£À¿ÀÖÀ×À	À	À	fÀ	¨À	ÉÀ	ğÀ	ñÀ
0À
6À
À
ÄÀ
åÀÀÀ)À*ÀnÀÀ‚ÀÄÀØÀÙÀóÀ@ÀqÀwÀÈÀãÀéÀ4ÀÀÎÀîÀÀÀIÀuÀ‹ÀÂÀ×ÀúÀÀÀÀÀaÀgÀµÀËÀæÀúÀ
À&À9ÀCÀ±ÀµÀ¶ÀëÀñÀ=ÀMÀSÀ˜ÀçÀ.À4ÀÀšÀêÀ9ÀƒÀÏÀ$ÀQÀÀƒÀ„ÀÀÀÆÀÀaÀÀ“ÀâÀ0ÀcÀ¯ÀÜÀúÀ-ÀLÀZÀzÀˆÀ°À¿ÀÀÀÀÀiÀ‹À‘ÀÑÀÀ%À5À‰ÀœÀ¦À¹À½À¾ÀïÀõÀDÀ“ÀäÀ0À|ÀÊÀÀ4À:ÀˆÀ±À·ÀÿÀPÀfÀlÀ¢À¨À¶ÀÑÀñÀ	ÀÀGÀ†À¥ÀïÀ ÀÀ2À‚ÀĞÀöÀ ,À 7À XÀ `À fÀ ˆÀ ¼À!À!2À!uÀ!¹À!öÀ"À"À"QÀ"À"‡À"¤À"¾À"ÄÀ"æÀ#À#À#'À#-À#IÀ#lÀ#rÀ#À#“À#¶À#ïÀ#ùÀ#ÿÀ$*À$2À$<À$BÀ$‡À$ÕÀ$ùÀ%À% À%8À%cÀ%´À&À&DÀ&MÀ&SÀ&rÀ&À&¡À&¢À&îÀ'4À':À'‡À'ÑÀ(!À(pÀ(ºÀ)À)@À)AÀ)MÀ)wÀ)yÀ)zÀ)”À)ÉÀ*À*-À*2À*€À*¢À*¾À*ÌÀ*ÍÀ+À+6À+7À+‡À+¢À+£À+øÀ,.À,lÀ,œÀ,¦À,®À,²À,³À,ïÀ-EÀ-‘À-’À-¬À-¿À-×À-ãÀ-ûÀ.HÀ.`À.ªÀ.âÀ.éÀ.ÿÀ/À/À/À/_À/„À/ÆÀ/âÀ/ãÀ0À0À0SÀ0rÀ0sÀ0À0¯À0±À0²À0äÀ1 À1!À1UÀ1YÀ1•À1¯À1³À1ıÀ2FÀ2”À2ÚÀ3%À3NÀ3RÀ3‹À3À3›À3§À3áÀ4"À4@À4À4ØÀ4õÀ5AÀ5`À5À5‡À5À5“À5©À5­À5¹À5ÆÀ6 À6AÀ6À6ÀÀ7À7&À7uÀ7½À7ŞÀ7äÀ7ìÀ7şÀ8HÀ8dÀ8jÀ8¨À8ÄÀ9À9À92À98À9…À9 À9¡À9ÊÀ9ĞÀ:À:À:jÀ:À:À:‚À:¢À:¦À:îÀ;À;À;DÀ;aÀ;xÀ;À;´À;µÀ;äÀ;êÀ<À<CÀ<^À<_À<‡À<À<ÑÀ<×À=(À=.À=oÀ=ŸÀ=ÃÀ=ÄÀ>À>7À>=À>ˆÀ>­À>¿À>ÁÀ>ÂÀ>ÜÀ?(À?-À?vÀ?‘À?–À?ÏÀ?íÀ@	À@À@À@8À@9À@EÀ@€À@À@ÕÀ@õÀ@öÀAÀAÀA"ÀAlÀAmÀAÆÀAëÀAìÀAøÀB#ÀBkÀBÓÀBîÀCÀCrÀC|ÀCµÀCÄÀCìÀD(ÀDjÀDvÀD~ÀD†ÀDŸÀD½ÀDÃÀDàÀDäÀDåÀE!ÀErÀEÂÀEÃÀEÏÀFÀF,ÀF.ÀF/ÀFRÀFVÀF¥ÀFõÀGCÀGfÀGjÀG¼ÀH
ÀH%ÀHeÀHŠÀHÛÀI!ÀImÀI½ÀIĞÀIÔÀJÀJiÀJ¹ÀKÀKTÀK¥ÀKôÀL<ÀLxÀL|ÀLÆÀMÀM`ÀMœÀM ÀMíÀMùÀNÀN2ÀNFÀN[ÀNyÀN„ÀNĞÀNúÀOÀO$ÀODÀOhÀOmÀOoÀOpÀO“ÀO—ÀOæÀP6ÀP„ÀP§ÀP«ÀPÿÀQMÀQ†ÀQŠÀQÜÀR,ÀR8ÀR<ÀR‡ÀRÑÀS!ÀSpÀS¼ÀTÀT\ÀT¤ÀTàÀTäÀU.ÀUxÀUÈÀVÀVÀVUÀVaÀVeÀVŠÀVÀVŞÀW)ÀWtÀWœÀWËÀWçÀWûÀXÀX.ÀX3ÀX[ÀXgÀX¦ÀXÃÀYÀY/ÀY9ÀY€ÀYªÀY´ÀY¼ÀZÀZÀZÀZÀZÀZ6ÀZ:ÀZ…ÀZ‰ÀZÖÀ[%À[dÀ[hÀ[±À\ À\À\À\hÀ\µÀ]À]BÀ]‘À]áÀ^1À^À^¸À^¼À_À_PÀ_„À_ˆÀ_ÕÀ_áÀ_åÀ`
À`À`^À`©À`ôÀaÀaIÀaeÀaÀašÀaÄÀbÀbÀbsÀb²ÀbóÀcÀc@ÀcgÀcnÀc|Àc’Àc–Àc˜Àc™ÀcéÀdÀdÀdÀd]Àd†ÀdŠÀd˜ÀdœÀdæÀeÀeCÀeYÀepÀesÀetÀe¹Àe½ÀeËÀeÏÀfÀfYÀfÀf™ÀfÅÀfËÀgÀg2ÀgeÀg‘Àg¿ÀgÀÀgîÀgôÀhCÀh“ÀháÀi.ÀiYÀi_Ài•Ài©ÀiªÀiÙÀißÀj/Àj~ÀjËÀkÀkCÀkIÀkÀk”Àk•Àk¡ÀkİÀkßÀkàÀl)Àl-Àl|ÀlÊÀmÀm[ÀmˆÀmŠÀm‹ÀméÀn"Àn\ÀnyÀn{Àn|Àn¹Àn½ÀoÀoVÀonÀorÀo¾ÀpÀpNÀpRÀpÀpçÀq7Àq†ÀqÒÀr#ÀrrÀrºÀröÀrúÀsDÀsÀsŞÀtÀt6ÀtJÀtWÀteÀt{ÀtÀt¯ÀtÃÀtØÀtöÀtûÀuÀuLÀuPÀunÀu¤Àu¨Àu©ÀuÑÀuöÀv4ÀvDÀvZÀvrÀvÀv«Àv´ÀvµÀvÒÀwÀwBÀwLÀw•ÀwÁÀwËÀwÓÀwÔÀwåÀx Àx$ÀxJÀxTÀxrÀx¶ÀxÑÀxíÀxøÀyÀy:ÀyZÀy[Ày‡Ày“Ày™Ày›ÀyœÀyéÀyùÀyıÀz4ÀzHÀz’Àz˜ÀzéÀ{8À{‡À{²À{¸À{ğÀ{ûÀ{üÀ|>À|DÀ|•À|æÀ|ìÀ}%À}0À}2À}3À}WÀ}[À}iÀ}mÀ}¼À}âÀ}÷À~+À~1À~À~ÊÀÀÀ!À'ÀvÀÀÀíÀ€À€À€gÀ€µÀ€ÏÀ€ÕÀ€åÀÀ)ÀtÀzÀÈÀ‚À‚HÀ‚QÀ‚œÀ‚ÕÀ‚ÛÀƒ)Àƒ}ÀƒƒÀƒ“ÀƒĞÀƒ×À„À„À„_À„ªÀ„ëÀ„ñÀ…À…À…PÀ…iÀ…~À…€À…À…ÒÀ…ïÀ†?À†bÀ†hÀ†¸À‡À‡RÀ‡›À‡µÀ‡»Àˆ
ÀˆVÀˆÀˆ–ÀˆáÀ‰À‰À‰À‰À‰5À‰À‰×À‰óÀŠÀŠ)ÀŠ*ÀŠ6ÀŠ~ÀŠ™ÀŠ›ÀŠœÀŠÎÀŠÒÀ‹À‹À‹^À‹À‹±À‹µÀ‹ûÀŒ&ÀŒ*ÀŒiÀŒ¬ÀŒÔÀŒØÀÀUÀkÀ‹ÀŒÀ´ÀºÀÀVÀyÀ­ÀİÀôÀøÀùÀ7À=À‚ÀŸÀÃÀÄÀùÀÀÀeÀ’À“ÀÚÀçÀ‘
À‘À‘RÀ‘„À‘±À‘²À‘õÀ’5À’DÀ’JÀ’»À“0À“vÀ“wÀ“ºÀ”À”FÀ”SÀ”¡À”¢À”çÀ•.À•=À•CÀ•°À–!À–sÀ–tÀ–¹À— À—EÀ—ZÀ—´À—µÀ—ûÀ˜?À˜„À˜ËÀ˜ğÀ˜öÀ™cÀ™ÔÀšÀšÀšaÀš¥ÀšêÀ›1À›wÀ›ŸÀ›íÀ›îÀœ1ÀœSÀœYÀœœÀœÀÀœÆÀÀMÀ”ÀØÀÀcÀ‘À—ÀÜÀŸÀŸcÀŸdÀŸ³ÀŸøÀŸşÀ MÀ –À ÚÀ¡À¡À¡LÀ¡›À¡çÀ¡íÀ¢À¢1À¢LÀ¢gÀ¢‚À¢ˆÀ¢‰À¢ØÀ£À£#À£WÀ£]À£¬À£úÀ¤=À¤‡À¤À¤ĞÀ¥À¥kÀ¥‚À¥À¥·À¥ØÀ¥óÀ¦À¦)À¦/À¦0À¦wÀ¦À¦©À¦ªÀ¦ìÀ§À§ À§rÀ§ÀÀ§ÛÀ§ÜÀ¨$À¨aÀ¨ À¨áÀ©'À©kÀ©¯À©»À©ÁÀª-ÀªÀª£À«À«‡À«ÇÀ«ÈÀ¬À¬(À¬.À¬}À¬¢À¬¨À¬ïÀ­#À­$À­fÀ­©À­¹À­×À­ØÀ®À®$À®qÀ®¿À®êÀ¯,À¯-À¯sÀ¯²À¯ïÀ¯õÀ°BÀ°“À°¾À±À±À±MÀ±À±À±ŸÀ±äÀ²(À²CÀ²SÀ²TÀ²¤À²ñÀ³À³À³^À³dÀ³©À³ÈÀ³ÉÀ´	À´8À´UÀ´VÀ´–À´ÆÀ´íÀ´îÀµ#Àµ)ÀµyÀµÆÀ¶À¶PÀ¶VÀ¶§À¶öÀ·HÀ·•À·ßÀ¸-À¸;À¸€À¸”À¸•À¸áÀ¸ôÀ¸úÀ¹JÀ¹˜À¹ÒÀºÀºGÀº˜Àº«Àº±À»(À»,À»-À»|À»­À»³À»ÿÀ¼GÀ¼–À¼åÀ½/À½gÀ½mÀ½¸À¾À¾NÀ¾‚À¾ˆÀ¾ØÀ¿%À¿uÀ¿¸ÀÀÀÀRÀÀ¡ÀÀñÀÁ@ÀÁFÀÁ”ÀÁãÀÂÀÂÀÂnÀÂ¹ÀÂóÀÂõÀÂöÀÃÀÃZÀÃ‚ÀÃÀÃÂÀÃÃÀÄÀÄVÀÄiÀÄjÀÄ£ÀÄÃÀÄÄÀÅÀÅ1ÀÅ2ÀÅ>ÀÅ‚ÀÅÀÅÏÀÅĞÀÆ$ÀÆCÀÆDÀÆÀÆÊÀÆËÀÆ×ÀÇ5ÀÇaÀÇbÀÇnÀÇÔÀÈ
ÀÈÀÈÀÈuÀÈ¡ÀÈ¢ÀÈ®ÀÉÀÉJÀÉKÀÉWÀÉĞÀÊÀÊ ÀÊ,ÀÊ­ÀÊØÀËÀËÀËÀË—ÀËòÀËóÀËÿÀÌ†ÀÌéÀÌêÀÌöÀÍmÀÍ¼ÀÍ½ÀÍÉÀÎHÀÎŸÀÎ ÀÎ¬ÀÎşÀÏÀÏ}ÀÏÀÏ‚ÀĞÀĞ‹ÀĞŒÀĞ˜ÀĞ»ÀĞÜÀĞ÷ÀÑÀÑ-ÀÑ4ÀÑXÀÑ|ÀÑÖÀÑÚÀÑÛÀÒaÀÒîÀÒïÀÒûÀÓÀÓ0ÀÓQÀÓlÀÓ‡ÀÓ¢ÀÓ©ÀÓÒÀÓöÀÔbÀÔfÀÔgÀÔõÀÕÀÕ0ÀÕFÀÕ\ÀÕrÀÕ‰ÀÕÀÕµÀÕ¶ÀÕÂÀÕŞÀÕşÀÖ:ÀÖ>ÀÖ?ÀÖ®ÀÖşÀÖÿÀ×À×'À×GÀ×ƒÀ×‡À×ˆÀ×÷ÀØGÀØHÀØTÀØ•ÀØµÀÙÀÙÀÙÀÙ‹ÀÚ ÀÚÀÚÀÚBÀÚtÀÚxÀÚyÀÚËÀÛÀÛ	ÀÛÀÛ4ÀÛVÀÛzÀÛ~ÀÛÀÛÉÀÛ÷ÀÛøÀÜÀÜGÀÜkÀÜ†ÀÜ®ÀÜüÀİ	ÀİDÀİJÀİNÀİOÀİ¯ÀİñÀİòÀŞdÀŞÄÀŞÅÀŞÑÀßÀß?ÀßZÀß‚ÀßÖÀßãÀà%Àà+Àà/Àà0Àà—ÀààÀàáÀáYÀá¿ÀáÀÀáÌÀâÀâ2Àâ3Àâ?ÀâŒÀâ¥Àâ¦Àâ²ÀâÒÀâõÀãÀã#Àã$Àã„Àã³Àã´ÀãÀÀãŞÀäÀä0ÀäXÀäiÀämÀänÀäÅÀåÀåÀåÀå6Àå\ÀåŠÀå©ÀåºÀå¾Àå¿ÀæÀæQÀæRÀæ^ÀæsÀæÀæÜÀæàÀæáÀç&ÀçKÀçLÀç­Àç÷ÀçøÀèÀè?ÀèlÀèpÀèrÀèsÀèµÀè¹ÀèÇÀé%Àé5ÀéfÀélÀé’Àé¿ÀéÀÀêÀêÀê`ÀêŒÀêÉÀëÀëÀëÀë5Àë;ÀëÀëÒÀëëÀëìÀìÀìÀìpÀìÂÀìŞÀìõÀìöÀí&Àí,Àí|ÀíËÀíçÀííÀî;ÀîŠÀîÙÀï'Àï8Àï}Àï¶Àï¸Àï¹ÀğÀğÀğVÀğ¢ÀğèÀğìÀñ2Àñ6Àñ‚ÀñÑÀñïÀñóÀò=ÀòÀò®ÀòîÀóÀósÀótÀóœÀóÀó©ÀóÛÀóİÀóŞÀô-ÀôGÀô‚Àô­Àô®ÀôÉÀôìÀôíÀôùÀõÀõGÀõhÀõ€ÀõãÀö?Àö³Àö¼ÀöÂÀöÜÀöàÀöáÀöíÀ÷À÷(À÷XÀ÷kÀ÷qÀ÷‰À÷›À÷ŸÀ÷¡À÷¢À÷áÀ÷åÀø-ÀøxÀøÆÀøêÀøîÀù<Àù‹Àù×Àú'ÀúuÀúƒÀú–Àú´ÀúòÀû4ÀûgÀûhÀûÀû¤ÀûíÀü7Àü€Àü—Àü˜Àü½ÀüÃÀıÀıWÀı§ÀıÆÀıİÀıŞÀş	ÀşÀş_Àş¦ÀşôÀÿCÀÿ|Àÿ‚ÀÿĞÀ  À oÀ ¨À ÂÀ ÃÀ âÀ ãÀ3ÀZÀ`À¯ÀüÀÀÀOÀUÀ›ÀÍÀÀÀÀ\ÀbÀ¤ÀèÀ6À“À—À˜À¤ÀÀÀÀJÀÀ¤À¨À©ÀşÀ@ÀAÀeÀÛÀıÀÀÀcÀÀ‘ÀÕÀÀSÀ–ÀÑÀíÀ	 À	À	#À	IÀ	nÀ	wÀ	}À	À	‚À	İÀ
#À
$À
cÀ
ŠÀ À.ÀqÀ‚À†À‡À÷ÀeÀfÀŠÀ À$À(À)À‡À´ÀµÀàÀåÀ:ÀdÀ|À¨À¸ÀÕÀÛÀìÀğÀñÀKÀqÀrÀ¾ÀÄÀÀ%À'À(À]À™ÀªÀâÀãÀ0ÀsÀ}À~ÀÌÀÀFÀOÀPÀÀîÀ1À:À;À‹À™À¢À¤À¥ÀòÀBÀTÀXÀ©À¼ÀÀÀAÀGÀ˜ÀÀíÀ;À‹ÀœÀ¢ÀñÀ÷ÀÀ#À3À9À†ÀŸÀ°ÀÁÀÆÀÇÀáÀøÀùÀ?ÀŠÀ´ÀêÀëÀ÷ÀÀ9À[À~À‚ÀƒÀÀÂÀÃÀÏÀ À"À#ÀtÀÃÀÀ]ÀÀ’ÀÛÀèÀÀ`À±ÀõÀûÀLÀšÀÇÀÀÀ:ÀRÀnÀoÀ½ÀÀ	ÀVÀ~À„À·ÀêÀ À PÀ ƒÀ ‰À ØÀ!$À!*À!8À!xÀ!À!¦À!½À!ÔÀ!ŞÀ!èÀ!îÀ" À"À"'À"-À";À"yÀ"•À"±À"ÍÀ"éÀ"óÀ"ıÀ#À#ŠÀ#À#À#ÛÀ#şÀ$!À$DÀ$gÀ$qÀ${À$À%
À%À%À%_À%…À%«À%ÑÀ%÷À&À&À&;À&RÀ&mÀ&‡À&¥À&¦À&òÀ'À'*À'AÀ'\À'tÀ'À'À'ìÀ(À(/À(FÀ(aÀ(yÀ(¢À(£À(ºÀ(ÙÀ(øÀ)À)À)<À)qÀ)µÀ)şÀ*GÀ*HÀ*`À*lÀ*¹À*ºÀ*ãÀ*øÀ+À+CÀ+ZÀ+dÀ+ŒÀ+¥À+ÄÀ+ÛÀ+åÀ,2À,\À,€À,µÀ,ÙÀ-À-À-_À-eÀ-iÀ-jÀ-vÀ-™À-ÅÀ-ÙÀ-ßÀ-ÿÀ.À.VÀ.xÀ.£À.§À.¨À.´À/%À/&À/2À/SÀ/hÀ/À/¸À/ÑÀ0 À0$À0VÀ0zÀ0¬À0»À0àÀ0æÀ0êÀ0ëÀ0÷À1À1"À19À1rÀ1‹À1ºÀ1ŞÀ2À24À2fÀ2uÀ3À3À3À3À3À3\À3`À3°À3ûÀ4MÀ4cÀ4À4ÀÀ4øÀ5À5MÀ5QÀ5RÀ5vÀ5°À5ÄÀ5ıÀ6À60À6uÀ6‰À6§À6«À6¬À6ÛÀ7 À74À7RÀ7VÀ7WÀ7¥À7ËÀ7èÀ7éÀ8)À8IÀ8JÀ8¯À8äÀ8åÀ98À9iÀ9jÀ9ÎÀ9øÀ9ùÀ:]À:‡À:‰À:ŠÀ:½À:ÁÀ:ÏÀ:ÓÀ;"À;oÀ;¾À;æÀ<2À<]À<zÀ<ÌÀ<ùÀ<úÀ=6À=¥À=şÀ>À>À>PÀ>–À>åÀ?(À?,À?-À?qÀ?ÃÀ@À@SÀ@WÀ@XÀ@œÀ@¢À@ğÀA:ÀAlÀA¸ÀAØÀBÀBÀB~ÀB‚ÀBƒÀBÍÀBÓÀC"ÀCYÀC~ÀCÚÀD"ÀD&ÀD'ÀDxÀDÅÀDìÀDíÀE6ÀEnÀEÀEÀE‘ÀEÃÀFÀFÀF)ÀFNÀFOÀFpÀF´ÀFÀÀF÷ÀFøÀGÀGGÀGHÀGTÀG˜ÀG™ÀG¥ÀGÈÀGôÀHÀHÀH5ÀHeÀH—ÀH›ÀHœÀH¨ÀHğÀHòÀHóÀI+ÀIÀIÀI§ÀI¾ÀIÙÀIÚÀIîÀJ0ÀJ<ÀJsÀJtÀJÀJ§ÀJÒÀJÿÀK0ÀK[ÀKaÀKeÀKfÀKrÀK¼ÀK½ÀKÉÀLÀLÀL!ÀLDÀLpÀL„ÀLŠÀL·ÀLÙÀLûÀM"ÀM&ÀM'ÀM3ÀMfÀMhÀMiÀM›ÀMãÀMäÀMüÀNÀNÀNYÀNeÀNœÀNÀN©ÀNéÀNêÀNöÀO7ÀO8ÀODÀOgÀO“ÀO§ÀO­ÀOÔÀOøÀPÀP!ÀP"ÀP.ÀPcÀPeÀPfÀP—ÀPŞÀPßÀP÷ÀQÀQÀQSÀQ_ÀQ–ÀQ—ÀQ£ÀQâÀQãÀQïÀR/ÀR0ÀR<ÀR_ÀR‹ÀRŸÀR¥ÀRËÀRïÀSÀSÀSÀS%ÀSZÀS\ÀS]ÀSÀSáÀSâÀTÀT$ÀT%ÀT?ÀT…ÀT‘ÀTÈÀTÉÀTÕÀU?ÀU@ÀULÀU¢ÀU£ÀU¯ÀUÒÀUşÀVÀVÀV@ÀVlÀV™ÀVÀVÀVªÀVçÀVéÀVêÀW)ÀW-ÀW}ÀWĞÀXÀXOÀX‹ÀXÀÀXÙÀXíÀY1ÀY5ÀY6ÀYƒÀYÉÀYúÀZÀZ'ÀZXÀZ\ÀZ]ÀZ¡ÀZóÀ["À[;À[OÀ[À[ƒÀ[„À[ÈÀ[ÎÀ\À\fÀ\—À\°À\ÔÀ]À]À],À]fÀ]jÀ]kÀ]À]ĞÀ]éÀ]ıÀ^CÀ^gÀ^kÀ^lÀ^ŸÀ^ÓÀ^ìÀ_ À_VÀ_¬À_åÀ_éÀ_êÀ`*À`JÀ`KÀ`¹Àa ÀaÀajÀa§Àa¨ÀbÀbLÀbMÀb§ÀbìÀbíÀcLÀc‰ÀcŠÀcúÀdMÀdNÀdœÀdÂÀdßÀdáÀdâÀe(Àe]Àe’ÀeÜÀeøÀfÀf"Àf#ÀfBÀfCÀflÀfrÀfÃÀfŞÀföÀgÀg'Àg:ÀgDÀgYÀg]Àg^Àg®ÀgÑÀg×Àh$ÀhnÀh·ÀiÀiÀiLÀi_ÀioÀiÀi«Ài¾ÀiÈÀiÌÀiÎÀiÏÀj$Àj=ÀjAÀjÀjÜÀk)ÀkyÀk}ÀkÒÀl&ÀlÀl×Àm*ÀmSÀmWÀm±ÀmÖÀmÚÀmèÀmìÀn0ÀnzÀnÊÀnôÀo>Ào†Ào­ÀoúÀpHÀpbÀpÀp­ÀqÀqÀqYÀqŸÀq¥ÀqıÀrÀr#Àr†ÀréÀsKÀsTÀsUÀs¦Às¬ÀtÀtbÀtÀt”ÀtîÀuKÀuQÀu·ÀvÀv‚ÀvÀvÀvâÀvèÀw@Àw˜ÀwîÀx	ÀxÀxiÀx¿ÀxÔÀxÚÀy>Ày¢ÀzÀzÀzÀzPÀzVÀz°À{À{À{!À{zÀ{šÀ{ À|À|fÀ|ÈÀ|ÑÀ|ÓÀ|ÔÀ}À}-À}_À}ˆÀ}©À}­À}¾À}ÀÀ}ÁÀ}õÀ~À~WÀ~€À~À~ÁÀ~åÀÀ'ÀFÀJÀ[À]À^À›À½ÀßÀ€À€%À€>À€WÀ€pÀ€À€ƒÀ€„À€ÌÀ€ĞÀ"À5À9ÀGÀKÀÁÀÅÀêÀ‚À‚%À‚tÀ‚ÅÀƒÀƒDÀƒJÀƒ™ÀƒÏÀƒÕÀ„8À„›À„ÿÀ…eÀ…kÀ…¶À…üÀ†À†À†jÀ†½À†ıÀ‡À‡!À‡0À‡JÀ‡hÀ‡À‡ªÀ‡ÏÀ‡òÀˆ.ÀˆAÀˆnÀˆ²ÀˆïÀ‰WÀ‰kÀ‰ÆÀ‰ÊÀ‰ËÀŠÀŠ6ÀŠ<ÀŠ‹ÀŠÜÀ‹&À‹[À‹aÀ‹¯À‹åÀ‹ëÀŒNÀŒ±ÀÀ{ÀÀÒÀÀ3À9À†ÀÙÀÀÀkÀ¹ÀÀQÀ ÀÅÀØÀëÀşÀ‘À‘6À‘^À‘xÀ‘‹À‘¨À‘ÏÀ’À’À’KÀ’ˆÀ’ğÀ’ñÀ“VÀ“²À“öÀ”À”vÀ”ƒÀ”ìÀ•À•À•”À•˜À•™À•éÀ–À–À–XÀ–¦À–áÀ–çÀ—6À—‡À—ÑÀ˜À˜À˜\À˜À˜£À™À™gÀ™ÊÀš/Àš5Àš„ÀšÔÀš÷ÀšıÀ›JÀ›À›İÀ›ïÀœÀœÀœ:ÀœbÀœÀœ¢Àœ¼ÀœãÀ	ÀEÀXÀ…ÀÂÀ*À>À³À·À¸ÀõÀŸÀŸÀŸ…À À 	À ˆÀ ¥À »À ÑÀ æÀ şÀ¡À¡1À¡NÀ¡OÀ¡ïÀ¢À¢"À¢7À¢QÀ¢dÀ¢wÀ¢À¢§À¢ÆÀ¢ÚÀ¢÷À¢øÀ£~À£šÀ£°À£ÆÀ£ŞÀ£ıÀ¤À¤*À¤AÀ¤]À¤^À¤À¤·À¤ÕÀ¤õÀ¥MÀ¥UÀ¥bÀ¥’À¥îÀ¥öÀ¥üÀ¦ À¦À¦À¦AÀ¦iÀ¦À¦•À¦ÑÀ§ À§fÀ§˜À§À§îÀ¨=À¨KÀ¨QÀ¨˜À¨ŞÀ©À©À©WÀ©§À©ôÀªÀª-Àª{ÀªÀª¤ÀªÆÀªÖÀªöÀ«4À«:À«NÀ«ÁÀ«ÚÀ«øÀ«şÀ¬À¬À¬À¬"À¬7À¬GÀ¬KÀ¬LÀ¬ŒÀ¬¬À¬­À­)À­™À­šÀ­åÀ®
À®RÀ®nÀ®pÀ®qÀ®»À®ĞÀ®ÔÀ®şÀ¯NÀ¯ŒÀ¯¨À¯ØÀ¯ìÀ° À°=À°\À°bÀ°rÀ°À°¢À°¬À°°À°±À°ÇÀ°ÈÀ±À±À±\À±¡À±îÀ²À²BÀ²‡À²ĞÀ³À³GÀ³À³ÙÀ³ôÀ´)À´/À´aÀ´¯À´üÀµÀµÀµÀµÀµXÀµ©Àµ÷À¶GÀ¶SÀ¶ À¶ÒÀ¶ÓÀ·À·SÀ·¡À·ÍÀ¸À¸=À¸KÀ¸QÀ¸RÀ¸ŠÀ¸¥À¸³À¸¹À¸ºÀ¸öÀ¹À¹DÀ¹JÀ¹NÀ¹OÀ¹kÀ¹ŠÀ¹‹À¹§À¹ÁÀ¹ÂÀºÀº&Àº'ÀºƒÀº¶Àº·ÀºëÀ»?À»AÀ»BÀ»uÀ»yÀ»®À»öÀ¼FÀ¼”À¼ºÀ¼¾À½À½XÀ½¦À½ïÀ¾(À¾SÀ¾¼À¾ØÀ¾çÀ¿	À¿&À¿-À¿1À¿2À¿NÀ¿OÀ¿À¿»À¿¼À¿ğÀ¿öÀÀDÀÀ’ÀÀİÀÁ+ÀÁ{ÀÁ¥ÀÁ«ÀÁòÀÁøÀÂÀÂ"ÀÂDÀÂcÀÂ~ÀÂˆÀÂÀÂÜÀÂæÀÂìÀÂúÀÃKÀÃvÀÃ§ÀÃØÀÃŞÀÄÀÄ\ÀÄ§ÀÄòÀÅ=ÀÅCÀÅjÀÅ”ÀÅœÀÅ¦ÀÅ¬ÀÅùÀÆNÀÆ_ÀÆeÀÆ¯ÀÆÚÀÇ/ÀÇKÀÇOÀÇPÀÇ†ÀÇŒÀÇäÀÈ'ÀÈ-ÀÈzÀÈ›ÀÈÌÀÉ ÀÉKÀÉOÀÉPÀÉ’ÀÉ˜ÀÉçÀÊ3ÀÊnÀÊzÀÊÀÊ¢ÀÊÄÀÊÔÀÊØÀÊÙÀË>ÀË¤ÀË¥ÀÌÀÌMÀÌNÀÌªÀÌÏÀÌĞÀÍ#ÀÍ?ÀÍAÀÍBÀÍ“ÀÍ—ÀÍºÀÍ÷ÀÎ	ÀÎQÀÎ^ÀÎ_ÀÎ­ÀÎ¾ÀÎ¿ÀÏÀÏ%ÀÏ+ÀÏvÀÏ´ÀÏõÀĞÀĞÀĞÀĞ?ÀĞCÀĞ’ÀĞØÀÑ#ÀÑoÀÑ¿ÀÑåÀÑéÀÒ6ÀÒ„ÀÒÓÀÒãÀÒçÀÓ3ÀÓ‚ÀÓÑÀÔÀÔkÀÔ»ÀÕ
ÀÕWÀÕrÀÕvÀÕÃÀÖÀÖZÀÖ|ÀÖ€ÀÖÏÀ×À×aÀ×²ÀØÀØSÀØvÀØ­ÀØôÀØúÀÙHÀÙ•ÀÙãÀÚ.ÀÚ]ÀÚcÀÚ°ÀÚÙÀÚßÀÛ0ÀÛ~ÀÛÍÀÜ
ÀÜ(ÀÜ.ÀÜ}ÀÜÌÀÜÒÀİ$ÀİMÀİSÀİ£ÀİôÀŞEÀŞ‘ÀŞßÀß*ÀßuÀß…Àß‹ÀßÙÀàÀà	ÀàGÀàMÀà™ÀàêÀá;Àá‡Àá®ÀáºÀáÏÀáíÀâÀâ,ÀâDÀâKÀâŠÀâÕÀâÛÀã2Àã‰ÀãÀãªÀãêÀäÀä;Àä‡ÀäÎÀåÀå&Àå0Àå8Àå>Àå„ÀåÔÀæÀæÀæCÀædÀærÀæ©ÀæÎÀæÜÀæİÀçMÀçÀç•Àç™ÀçšÀçëÀèÀè ÀènÀè»Àé	ÀéTÀéƒÀé‰ÀéÖÀê ÀêlÀê»ÀêÎÀêÔÀë%ÀëtÀë»ÀìÀì]Àì¬ÀìãÀìéÀí8Àí‡ÀíØÀî!ÀîZÀî`Àî°ÀïÀïRÀï¢ÀïìÀğ8Àğ‰Àğ¶Àğ¼Àñ
ÀñZÀñ©Àñ×ÀñİÀòÀò+Àò@Àò]ÀòtÀò™Àò²Àò¹ÀòŞÀóNÀóTÀó—ÀóâÀóèÀô?Àô–ÀôœÀô·Àô÷Àõ-ÀõLÀõ˜ÀõäÀö/Àö<ÀöFÀöNÀöTÀö¨ÀöêÀöğÀöôÀöõÀ÷WÀ÷ŠÀ÷±À÷åÀø#ÀøSÀø†Àø‡Àø×ÀøúÀùÀù%Àù5ÀùMÀù`ÀùjÀùzÀù~ÀùÀùÊÀùïÀú4ÀúPÀúQÀúkÀúµÀú»Àû	ÀûÀû:ÀûNÀû^ÀûzÀûÀû—ÀüÀüÀüÀüÀü]ÀüaÀüÀüáÀüòÀıÀıÀıhÀı²ÀıëÀıñÀş>ÀşÀş£Àş­Àş®ÀşèÀşîÀÿ4Àÿ:Àÿ|Àÿ’Àÿ›ÀÿœÀÿÒÀÿØÀ À 0À ;À =À >À ˆÀ ”À ˜À ·À ÅÀ ıÀÀÀEÀRÀTÀUÀŠÀÀÕÀÀZÀ^À§À÷À@À]ÀaÀ±ÀúÀ/À3À€À¿À×ÀÀ8À>À‡ÀÏÀÀnÀ»ÀşÀÀKÀaÀ±À²ÀúÀ À,À2ÀBÀHÀ™ÀÎÀİÀŞÀ	/À	€À	ÏÀ
À
'À
-À
yÀ
ÊÀÀ`À®ÀøÀşÀKÀQÀuÀ{ÀÉÀÀeÀµÀÚÀàÀ.ÀwÀÈÀÀdÀ´ÀüÀ)À/ÀyÀ’À˜À¦ÀÓÀûÀÀRÀ{À²ÀëÀÀÀ'À1À7À†ÀÔÀ"À@ÀFÀTÀÀÄÀìÀÀCÀzÀ³ÀÍÀÕÀßÀåÀ6À|ÀÆÀÌÀÚÀÀÀrÀ«ÀÅÀÜÀ=ÀvÀÀ˜À¢À¨ÀóÀ<ÀÀÅÀËÀïÀõÀ4À:ÀˆÀÖÀ'ÀrÀÁÀÀZÀ¥ÀöÀGÀbÀhÀxÀ~ÀÎÀğÀ8ÀNÀ{À|À¼ÀÛÀáÀ À&ÀoÀ³ÀÅÀÆÀ"ÀoÀÁÀÇÀ À À ZÀ ªÀ ÌÀ îÀ ïÀ!2À!wÀ!¾À!óÀ!ùÀ"À"4À"5À"…À"ÕÀ"ıÀ"şÀ#MÀ#—À#¨À#®À#ôÀ$À$-À$.À$ƒÀ$¢À$£À$ôÀ%@À%À%¸À%ÛÀ%ÜÀ&,À&gÀ&À&À&âÀ'8À'TÀ'ZÀ'¬À'úÀ(JÀ(wÀ(•À(–À(äÀ(ûÀ)À)WÀ)]À)¡À)§À)ùÀ*AÀ*jÀ*pÀ*ºÀ*ÎÀ+)À+*À+xÀ+—À+À+ôÀ+úÀ,>À,DÀ,–À,ŞÀ-.À-hÀ-iÀ-·À-ËÀ-ÑÀ.'À.-À.qÀ.wÀ.ÉÀ/À/:À/qÀ/rÀ/ÃÀ0À0hÀ0yÀ0À0ÓÀ1&À1xÀ1ÇÀ2À2iÀ2¼À3À3\À3xÀ3~À3¶À4À4\À4«À4íÀ4óÀ5AÀ5hÀ5nÀ5|À5À5¼À5õÀ62À6QÀ6‹À6ÇÀ6ÖÀ6ŞÀ6èÀ6îÀ7?À7‹À7æÀ8:À8JÀ8PÀ8–À8ãÀ9À9À9mÀ9¼À:À: À:5À:RÀ:SÀ:¤À:öÀ;IÀ;OÀ;ŸÀ;ñÀ<AÀ<‘À<ãÀ=7À=ŠÀ=—À=À=ÒÀ=õÀ=öÀ>9À>…À>¢À>ÖÀ>×À?&À?nÀ?tÀ?ÂÀ?ÈÀ@3À@¢À@ÖÀ@×ÀAÀAÀAQÀAlÀA‹ÀAŒÀAÜÀBÀBÀBˆÀB÷ÀC ÀC!ÀCrÀC´ÀCºÀD&ÀD–ÀDÂÀDÃÀEÀEcÀE‰ÀEÀEÔÀFÀFÀF\ÀF­ÀFĞÀFÖÀGAÀG°ÀGÙÀGÚÀH%ÀHwÀHÆÀHéÀHïÀI\ÀIÍÀJÀJÀJCÀJIÀJ‰ÀJÖÀK ÀKtÀKÅÀLÀLAÀLGÀL¶ÀM)ÀM/ÀM‡ÀMåÀMæÀNÀN!ÀNjÀN³ÀNßÀOÀO	ÀOWÀO®ÀOéÀOêÀP9ÀP…ÀP‹ÀPÚÀPóÀPùÀQEÀQÀQ¡ÀQåÀQæÀR-ÀR3ÀRÀRÏÀSÀSiÀS¬ÀS²ÀT ÀTMÀT›ÀTâÀTóÀU:ÀU;ÀU‚ÀU›ÀUÀÀUÁÀVÀVÀV#ÀVnÀV{ÀVÀVÍÀWÀWXÀW^ÀW­ÀWùÀWÿÀXPÀXÀXêÀXğÀY:ÀY†ÀYÓÀZÀZÀZSÀZYÀZ ÀZ¦ÀZìÀ[6À[<À[LÀ[RÀ[¢À[»À\À\À\KÀ\QÀ\¡À\îÀ\ôÀ]:À]„À]ŠÀ]šÀ] À]îÀ^À^XÀ^YÀ^£À^©À^õÀ_À_À_UÀ_¦À_½À_ÃÀ`À`ZÀ`¦À`îÀa>Àa‰ÀaÔÀb#ÀbtÀbÂÀbüÀcÀc)Àc/Àc?ÀcÀcÜÀdÀdUÀdŸÀd ÀdäÀdêÀe;Àe”ÀeçÀf;ÀfsÀfyÀfÉÀgÀgiÀg»ÀhÀh_Àh«Àh±ÀiÀiRÀi§ÀişÀj.Àj‚ÀjĞÀkÀkÀkmÀk¼ÀlÀlUÀlªÀl°ÀmÀmUÀmÀm¤ÀmõÀnÀnÀn$Àn9ÀnbÀnuÀnŒÀn”ÀnšÀnÈÀnşÀoÀo]Ào{ÀoœÀo¢Ào´ÀoãÀpÀp;ÀpoÀp™Àp¸ÀpÔÀqÀq/ÀqMÀq“ÀqÁÀqïÀr ÀrÀrIÀrŒÀr³Àr½ÀrÃÀrÒÀrÚÀräÀrêÀsCÀsIÀsWÀslÀs°ÀsÃÀsÚÀsíÀtÀtÀtÀtBÀtxÀt~Àt×ÀtõÀuÀuÀu.Àu]Àu~ÀuµÀuéÀvÀv>ÀvZÀv—ÀvµÀvÓÀwÀwGÀwuÀw†Àw›ÀwÏÀxÀx(Àx\ÀxÀx¼ÀxÆÀxÌÀxÛÀxãÀxíÀxóÀy<Ày‡ÀyºÀyÀÀyĞÀyÖÀz$Àz;ÀzYÀzˆÀz«ÀzÑÀzøÀ{À{8À{9À{}À{ƒÀ{ÔÀ|-À|€À|ÔÀ}&À}xÀ}¯À}µÀ~À~MÀ~SÀ~¤À~äÀÀÀcÀ­À³ÀÿÀ€LÀ€œÀ€¢À€ıÀÀÀ"À7À`ÀsÀŠÀ’À˜ÀÆÀüÀ‚À‚[À‚yÀ‚šÀ‚ À‚²À‚áÀƒ1Àƒ€ÀƒÑÀƒíÀ„2À„|À„´À„ßÀ…À…>À…eÀ…•À…½À…ÃÀ†À†wÀ†ÑÀ‡À‡?À‡kÀ‡ªÀ‡éÀ‡õÀˆÀˆtÀˆ~Àˆ„Àˆ“Àˆ›Àˆ¥Àˆ«À‰À‰
À‰À‰-À‰qÀ‰„À‰›À‰®À‰ÇÀ‰ÏÀ‰ÕÀŠÀŠ9ÀŠ?ÀŠ˜ÀŠ¶ÀŠ×ÀŠİÀŠïÀ‹À‹nÀ‹½ÀŒÀŒ*ÀŒoÀŒ¹ÀŒ÷À/ÀZÀÀ¹ÀàÀÀ8À>À™ÀğÀKÀ¨ÀóÀ9ÀbÀ|À·ÀÓÀïÀ‘3À‘_À‘‹À‘šÀ‘ÑÀ’À’=À’rÀ’xÀ’ÒÀ“,À“„À“ËÀ“úÀ”À”'À”•À”ŸÀ”¥À”´À”¼À”ÆÀ”ÌÀ”ÜÀ”âÀ•/À•DÀ•eÀ•”À•»À•âÀ–À–0À–RÀ–SÀ– À–¦À–öÀ—À—À—7À—À—À—‘À—ßÀ—ûÀ˜<À˜\À˜¹À˜¿À˜óÀ™À™1À™À™‘À™’À™üÀšqÀšrÀšÎÀ›*À›oÀ›”À›•À›¡À›ïÀœÀœÀœÀœBÀœ\Àœ˜Àœ¥ÀœÉÀ.À4À8À9À›ÀõÀöÀkÀîÀïÀûÀŸLÀŸgÀŸhÀŸtÀŸÓÀŸşÀŸÿÀ À bÀ À ‚À À ñÀ¡"À¡#À¡/À¡nÀ¡oÀ¡ÎÀ¡üÀ¡ıÀ¢	À¢aÀ¢‰À¢ŠÀ¢–À¢ôÀ£ À£!À£-À£UÀ£uÀ£³À£¹À£ÒÀ£ÖÀ£×À¤$À¤UÀ¤VÀ¤bÀ¤À¤²À¤ÎÀ¤âÀ¤æÀ¤çÀ¥7À¥kÀ¥lÀ¥xÀ¥ÔÀ¥ôÀ¦LÀ¦PÀ¦QÀ¦ĞÀ§?À§@À§LÀ§‡À§©À§ÛÀ§ßÀ§àÀ¨3À¨tÀ¨uÀ¨À¨¹À¨êÀ¨îÀ¨ïÀ©HÀ©‡À©ˆÀ©”À©²À©áÀªÀªHÀªLÀªMÀª£ÀªÜÀªİÀªéÀ«À«<À«cÀ«©À«­À«®À¬
À¬IÀ¬JÀ¬VÀ¬‹À¬¹À¬½À¬¾À­ À­VÀ­WÀ­cÀ­˜À­¸À­ØÀ® À®$À®%À®™À¯À¯À¯À¯>À¯kÀ¯oÀ¯pÀ¯ÅÀ°À°À°À°IÀ°iÀ°ÃÀ°ÇÀ°ÈÀ±<À±¾À±¿À±ËÀ±øÀ²À²\À²`À²aÀ²¾À³À³À³+À³fÀ³ˆÀ³ªÀ´À´À´À´mÀ´áÀ´âÀ´îÀµÀµ8Àµ’Àµ–Àµ—À¶À¶À¶À¶šÀ¶ÔÀ¶óÀ·5À·9À·:À·¨À¸À¸À¸&À¸…À¸¥À¹!À¹%À¹&À¹¯À¹ÉÀ¹ÜÀ¹îÀºÀºÀº0ÀºIÀº_Àº‚ÀºÀºÀºªÀºÔÀ»À»À»À»}À»ÛÀ»ÜÀ»èÀ¼$À¼FÀ¼jÀ¼ìÀ½À½SÀ½YÀ½]À½^À½ÛÀ¾eÀ¾fÀ¾rÀ¾·À¾ÙÀ¾øÀ¿À¿NÀ¿À¿³À¿çÀÀÀÀOÀÀÀÀµÀÀêÀÁ#ÀÁYÀÁÀÁ·ÀÂÀÂÀÂÀÂÀÂÁÀÂäÀÂøÀÃÀÃ#ÀÃ:ÀÃRÀÃhÀÃ}ÀÃ”ÀÃ¬ÀÃÏÀÃéÀÄÀÄ	ÀÄÀÄ]ÀÄÀÄ¡ÀÄÀÀÄ÷ÀÅ-ÀÅbÀÅ™ÀÅÑÀÆÀÆ6ÀÆjÀÆŸÀÆØÀÇÀÇSÀÇlÀÇºÀÇÀÀÇÄÀÇÅÀÈvÀÈ™ÀÈ­ÀÈÆÀÈŞÀÈøÀÉÀÉ)ÀÉ>ÀÉUÀÉmÀÉÀÉªÀÉÉÀÉÊÀÉÖÀÉüÀÊ ÀÊMÀÊQÀÊRÀÊ¨ÀÊŞÀÊßÀÊëÀË&ÀËrÀËÀËÂÀËíÀÌ%ÀÌ)ÀÌ*ÀÌ6ÀÌÀÌÚÀÌŞÀÌßÀÌëÀÍ8ÀÍZÀÍ¥ÀÍ«ÀÍòÀÍöÀÍ÷ÀÎ\ÀÎÍÀÎÎÀÎÚÀÏ%ÀÏJÀÏ•ÀÏ™ÀÏšÀĞÀĞzÀĞ{ÀĞ‡ÀĞ¥ÀĞÔÀĞ÷ÀÑÀÑDÀÑeÀÑ…ÀÑ§ÀÑêÀÑëÀÒÀÒ=ÀÒˆÀÒÀÒÛÀÓCÀÓIÀÓJÀÓ‘ÀÓĞÀÓÑÀÓûÀÔÀÔ@ÀÔeÀÔŠÀÔÀÀÔâÀÕÀÕ:ÀÕpÀÕ¤ÀÕØÀÕşÀÖ#ÀÖJÀÖrÀÖxÀÖyÀÖâÀ×#À×[À×\À×‚À×áÀØ'ÀØ.ÀØ/ÀØHÀØ–ÀØœÀØ ÀØ¡ÀØ­ÀØÎÀØıÀÙ$ÀÙKÀÙuÀÙ™ÀÙ¼ÀÙíÀÙîÀÚÀÚCÀÚ‘ÀÚ—ÀÚµÀÛÀÛÀÛUÀÛÎÀÛÔÀÜÀÜÀÜ3ÀÜˆÀÜÒÀÜÙÀÜÚÀÜóÀİAÀİGÀİKÀİLÀİàÀİÿÀŞ"ÀŞ<ÀŞZÀŞnÀŞÀŞ¨ÀŞÁÀŞÖÀŞôÀŞõÀßÀßYÀß¬Àß°Àß±ÀàÀà‚Àà„Àà…Àà³ÀàòÀàóÀá;Àá?ÀásÀáwÀá¾Àâ ÀâBÀâ[ÀâšÀâ ÀâëÀã-ÀãNÀãwÀãxÀã¹Àã¿Àä
ÀäMÀänÀä˜Àä™ÀäÃÀäÉÀåÀågÀå°ÀåàÀåáÀæ#Àæ)Àæ`Àæ¯ÀæşÀçGÀçMÀçÀçëÀèÀèÀènÀè·ÀèĞÀèÖÀé%Àé:ÀéfÀégÀé·ÀéÚÀéìÀéíÀê3Àê9Àê‡ÀêÀê·Àê¸ÀëÀëÀëXÀëŠÀëªÀë¬Àë­ÀëÇÀìÀìaÀì}ÀìƒÀì¹ÀìÕÀìëÀììÀìøÀí)ÀíAÀífÀíšÀí Àí¶ÀîÀî#Àî=ÀîNÀîÀî—Àî¡Àî¨Àî¬Àî­ÀïÀï`ÀïaÀïmÀïšÀï²Àï×ÀğÀğÀğÀğ7Àğ_Àğ•Àğ™ÀğšÀğúÀñ@ÀñAÀñMÀñ`ÀñxÀñˆÀñ Àñ³Àñ½ÀñàÀñğÀñôÀñõÀò@ÀòeÀò©ÀòÅÀòÆÀòàÀòáÀòíÀóÀóÀó,ÀóHÀó[ÀóeÀóÕÀóÙÀóÚÀóæÀôDÀômÀôoÀôpÀô·Àô»Àõ ÀõEÀõfÀõ§ÀõîÀö
Àö@ÀöAÀö|Àö‚ÀöÆÀ÷À÷DÀ÷‰À÷ÅÀ÷İÀ÷ŞÀøÀøÀø^Àø®ÀøóÀùÀùÀùÀùpÀùŒÀù»Àù¼Àú Àú Àú!Àú-ÀúXÀúYÀúeÀú€Àú›ÀúßÀúåÀûÀû8ÀûWÀûkÀû¾ÀüÀü*Àü>ÀüBÀüCÀüœÀüÖÀü×ÀüñÀüóÀüôÀı	ÀıÀıIÀıXÀırÀıxÀıÃÀşÀş(Àş.ÀşoÀşuÀşÄÀşİÀşîÀÿÀÿ;ÀÿVÀÿ«Àÿ¬ÀÿÜÀ  À *À UÀ |À £À ÍÀ ÎÀ şÀÀVÀyÀÀÀÎÀÔÀ"ÀnÀ°ÀÇÀÈÀÀ5À6ÀhÀnÀ¡À§ÀÔÀGÀ}À±ÀµÀ¶ÀòÀøÀ+ÀgÀhÀµÀ»ÀøÀGÀnÀtÀ¸ÀÀPÀrÀ†À™À¯ÀòÀöÀ÷ÀIÀWÀwÀŠÀÀ½ÀäÀëÀïÀğÀ	 À	&À	oÀ	´À	ØÀ	ŞÀ
À
QÀ
›À
æÀ2À€ÀĞÀÀaÀgÀ¶ÀÖÀëÀ#À8ÀOÀdÀsÀ”ÀœÀ©ÀÀÀÛÀêÀÀ4ÀkÀ­À¸ÀÀÀÆÀÊÀËÀÀ
ÀRÀXÀ{ÀÉÀëÀşÀÀÀ0À\À—ÀÇÀöÀüÀ3ÀZÀ`À—À¸À¾ÀÑÀÕÀÖÀâÀÀ'À:À@À[À{ÀÀÈÀÌÀÍÀÙÀÀÀdÀ¶ÀÒÀÀ'ÀAÀGÀHÀ…À»À¼ÀÖÀ#ÀUÀŠÀ‹ÀÄÀÀÀCÀpÀqÀ¨ÀÕÀÖÀ%À_À…À‹ÀŒÀ¤À¨À©ÀµÀøÀúÀûÀBÀFÀ•À«ÀéÀÀÀ[ÀpÀ±ÀöÀ(ÀUÀsÀwÀxÀ²À¸ÀñÀ/ÀtÀ½ÀÀ4À|À·ÀèÀ$À?ÀYÀ…ÀÀ¶À¾ÀÂÀÃÀôÀúÀ3ÀpÀ«ÀÜÀÀ,ÀFÀ€ÀˆÀ±À¹À½À¾À À VÀ WÀ ´À!À!À!^À!ªÀ!«À!ßÀ!üÀ"À"À"+À",À"UÀ"[À"¬À"ÇÀ"ßÀ"ïÀ#À##À#-À#BÀ#FÀ#GÀ#—À#ºÀ#ÀÀ$À$WÀ$¤À$ñÀ%?À%]À%pÀ%€À%ŸÀ%¼À%ÏÀ%ÙÀ%éÀ%íÀ%îÀ&9À&^À&ªÀ&ÆÀ&ÈÀ&ÉÀ'À'À'gÀ'À' À'ÙÀ'ßÀ(/À(À(›À(¡À(ïÀ)BÀ)ƒÀ)ÀÀ)ßÀ)ıÀ*À*.À*AÀ*gÀ*ŠÀ*‹À*ÖÀ+À+cÀ+•À+ÍÀ+íÀ+ñÀ+òÀ,À,"À,]À,nÀ,oÀ,šÀ, À,ÛÀ,íÀ,îÀ- À-&À-]À-vÀ-wÀ-ÇÀ-êÀ-ğÀ.;À.`À.rÀ.sÀ.ÁÀ.İÀ.ãÀ/.À/{À/ŒÀ/’À/àÀ0À0QÀ0SÀ0TÀ0´À0ÒÀ0ÓÀ1À1À1bÀ1´À1ÎÀ1ÔÀ2"À2uÀ2¶À2óÀ3À3/À3GÀ3`À3sÀ3™À3 À3´À3ÊÀ4À4'À4uÀ4yÀ4zÀ4ÜÀ5/À50À5™À6'À6(À67À68À6‘À6­À6®À6ºÀ6åÀ6æÀ6öÀ6÷À7QÀ7nÀ7oÀ7{À7©À7ªÀ7ÁÀ7ÂÀ8#À8GÀ8HÀ8TÀ8—À8˜À8¤À8ğÀ9À9À9À9hÀ9›À9µÀ9»À9ğÀ:À:À:À:IÀ:dÀ:À:¿À:şÀ;!À;_À;€À;¶À;¼À;İÀ;ÿÀ< À<*À<eÀ<wÀ<{À<|À<çÀ==À=?À=@À=uÀ=¥À=¦À=ŞÀ=âÀ>,À>9À>|À>}À>ÌÀ>áÀ>äÀ?1À?NÀ?QÀ?À? À?²À?µÀ?ÀÀ?ôÀ?÷À@2À@oÀ@tÀ@wÀ@–À@ÆÀ@ËÀ@ÒÀ@ÕÀA*ÀA€ÀA¬ÀA¯ÀBÀB9ÀBoÀB¶ÀBúÀC7ÀCKÀCwÀCŒÀCÀCËÀCÚÀDÀD"ÀD/ÀDLÀDRÀDXÀDhÀDÀD›ÀDŸÀDºÀD¼ÀD½ÀEÀEZÀE^ÀE®ÀEşÀF3ÀFnÀF³ÀF´ÀFéÀGÀGÀGTÀGoÀGpÀG|ÀG’ÀGìÀHÀHÀHdÀHÀH“ÀH±ÀHµÀH·  dart.ui€¬ M_rectIsValid_rrectIsValid_offsetIsValid_matrix4IsValid_radiusIsValid_scaleAlphaColor	BlendModeFilterQuality	StrokeCap
StrokeJoinPaintingStyleClipPaint
ColorSpaceImageByteFormatPixelFormatImage_Image	FrameInfoCodec_NativeCodecinstantiateImageCodecinstantiateImageCodecFromBufferinstantiateImageCodecWithSize_getDefaultImageSizeTargetImageSizedecodeImageFromList_decodeImageFromListAsyncdecodeImageFromPixelsPathFillTypePathOperationEngineLayer_NativeEngineLayerPath_NativePathTangentPathMetricsPathMetricIterator
PathMetric_PathMeasure	BlurStyle
MaskFilterColorFilter_ColorFilterImageFilter_MatrixImageFilter_GaussianBlurImageFilter_DilateImageFilter_ErodeImageFilter_ComposeImageFilter_ImageFilterShaderTileMode_encodeColorList_encodePointList_encodeTwoPointsGradientImageShaderFragmentProgramFragmentShader
VertexModeVertices	PointModeClipOpCanvas_NativeCanvasPicture_NativePicturePictureRecorder_NativePictureRecorderShadowImmutableBufferImageDescriptor_NativeImageDescriptor	_futurizePictureRasterizationException ë